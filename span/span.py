# span/main.py

#SPectral ANalysis software (SPAN).
#Written by Daniele Gasparri#

# THIS IS THE VERSION OPTIMIZED FOR ALL THE OPERATING SYSTEMS WITH AT LEAST 900 PIX SCREEN VERTICAL RESOLUTION

"""
    Copyright (C) 2020-2025, Daniele Gasparri

    E-mail: daniele.gasparri@gmail.com

    SPAN is a GUI interface that allows to modify and analyse 1D spectra.
    It is provided "as is" without any warranty whatsoever.
    Permission to use for non-commercial purposes is granted.
    Permission to modify for personal or internal use is granted,
    provided that this copyright and disclaimer are included unchanged
    at the beginning of the file. All other rights are reserved.
    In particular, redistribution of the code is not allowed.

    How to run: just compile the code with Python 3.X and use the pre-loaded example files
    to play with the GUI.
    Check the Python packages needed in the "readme_span.txt" to run this source code.

"""



######################################################################################
#Version histories
#Version 6.3 (20250205):
#Major modification to the main GUI for non-mobile devices in order to keep clean the main panel. The spectral manipulation tasks are now grouped in a secondary panel called Spectra manipulation. Removed the GIST pipeline for copyright issues.
#Added the two component stellar fitting for the stars and kinematics task.
# Major modifications to the 'DataCube extraction' sub-program. Added the visualisation of the spectral bins before extraction and the manual binning mode by drawing custom regions on the datacube.

#Version 6.2 (20250115):
#Added the option to insert a custom template set in pPXF .npz format for the 'Stellar populations and SFH' task
#Major changes to the 'cube_extract' module to improve efficiency

#Version 6.1 (20250107):
#Major change to the spectra manipulation frame. Re-arranged the spectra math tasks and introduced the possobility for the user to re-order the spectra manipulation tasks.
#Added the dust parametrization for the 'Stars and gas kinematics' tasks.

#Version 6.0 (20241118):
#Major change to the layout and the structure of the main span code. Now the code recognizes the operating system used and adapts the layout. No need to compile different files for different operating system anymore.

#Version 5.8 (20241114):
# Modified the 'Stars and gas kinematics' and the 'Stellar populations and SFH' tasks to deal with cosmological redshift galaxy spectra, fixed some minor bugs, cleaned the code and rearranged the plots generated for better clarity.
# Fixed a minor bug within the user defined FIST mask file used for GIST pipeline tasks that generated an error when the mask file does not have any masked spaxel.
#Modified and updated the mapviewer module of the GIST pipeline which is now embedded in the source code version of SPAN and as a standalone program in the executable distribution.
#Modified the Stellar populations and SHF task to deal either with log10 ages and linear ages. Now the results compared to the GIST pipeline are very similar. Minor differences are due to the different flux normalization of the templates in the luminosity weighted ages and metals. GIST normalizes considering the whole template band (bolometric) while SPAN normalizes to the V band.
# The modification that allows to deal with log10 or linear ages required to modify the mean_age_met and plot functions of pPXF stored in the modules: sps_util (for pre-loaded libraries included with pPXF), miles_util for dealing with custom (E)MILES, sMILES_util for dealing with sMILES and alpha/Fe and xshooter_ppxf for dealing with the XSL SSP models.
# Changed from ASCII files to FITS 1d format the residual, emission corrected and best template spectra generated by the stellar populations and SFH task.
# Fixed a bug in the Line-strength analysis and the Lick/IDS option that caused wrong measurements when the emission correction was disabled and doppler correction enabled.
# Changed the fitting parameters of the Lick/IDS measurements when pPXF must be applied to correct the emission, estimate sigma or doppler correction. Now the templates are convolved to the resolution of the spectra (if greater than the spectra) to a better estimation of the kinematics.
# Introduced the save_fits2d function in the utilities module in order to save 2d fits table for the templates, gas and residuals from the Stellar population and SFH task.
# Fixed the plots generated by the Line-strength analysis task in the 'Process all' mode.
# Some cleaning of the code
# Modified the show_sampling function of the utilities module: since SPAN linearize the input spectra, there is no need anymore to show if the spectra is linear or not.
# Added the selection of custom EMILES SSP templates als for kinematics
# Now it is possible to insert any sMILES template in the spectralTemplates/sMILES_afeh folder to work with alpha/Fe in the 'tellar populations and SFH' task.
# Otimized the code of the functions in the span_function folder

#Version 5.7 (20241029):
#Major changes to GIST pipeline-based sub-programs ('Cube extraction' and 'GIST pipeline') to be more flexible and more user friendly. Introduced the datacube dynamic visualisation in a matplotlib window and the 'Generate mask' button that allows the user to graphically generate a spectral mask to be used by GIST. Now the information stored in the GIST fits structures regarding the bins (S/N, coordinates...) are also stored in a ASCII txt file and more accessible.
#Major changes to the "Stellar populations and SFH" task to include: sMILES models with alpha/Fe, dust absorption (replacing the obsolete reddening keyword of pPXF), uncertainties estimation with bootstrap simulations, auto noise estimation for the fitting so that Chi2 = 1 for non regularized fits and masking user defined spectral regions. Improved plots, now plotting also the alpha/Fe-[Z/H] weights. Saving the luminosity and mass weights.
#Stellar and gas kinematics: fixed the xshooter library that could not be used with spetra with R = constant resolution.
# Changed the Dopcor task, now called 'Doppler/z correction': now the user can correct the spectra both with radial velocity values and redshift (z).
# Adjusted the layout of the 'Cross-corr parameters' and 'Sigma parameters' windows. Added and improved the cross-correlation task: now it can consider also the cosmological redshift instead only velocity values.
# Minor changes to the layout of the 'Cube extraction' and 'GIST pipeline'.
# Added the help files for the 'Cube extraction' and 'GIST pipeline'.
# Incorporated an updated version of the Mapviewer GUI application included with GIST to visualise the plots/maps of the analysys.
# Modified the 'printstatus' class of the GIST pipeline to not show percentage of the progress bar. This greatly speeds up the 'GIST pipeline' workout.
# The user defined parameters are saved now also for the sub-programs.
# Corrected minor bugs in the system_span read_spec function and added the read_datacube function.
# Corrected minor bugs in the spec_analysis.py module

#Version 5.6 (20240824):
#Modified the "Stars and kinematics" task to include more parameters.

#Version 5.5 (20240724):
#Integrated the GPR Machine learning for Lick/IDS analysis. Corrected minor bugs.

#Version 5.4 (20240527):
#Integrated the full GIST pipeline. Added the xshooter SSP library (XSL) of Verro et al. 2022 to 'Stars and gas kinematics' and 'Stellar populations and SFH' tasks. Added the custom (E)MILES template selection for 'Stellar populations and SFH' task, the possibility to mask the emission lines and an algorithm to find automatically the best ppxf parameters for stellar populations: noise and Regul. err. Changed the format of the fits file saved in the 'Convert spectrum to' task. Corrected minor bugs.

#Version 5.3 (20240515):
#Integrated a modified version of the GIST pipeline in order to bin and extract data cube spectra. Rearranged the Open spectra frame. Changeg the names of some spectral analysis tasks.

#Version 5.2 (20240505):
#Embedd freesimplegui, improved ppxf stellar populations with more parameters and better plots.

#Version 5.1 (20240502):
#Changed Pysimplegui with Freesimplegui since pysimplegui is not free anymore. Added pixel noise to ppxf stellar populations layout and changed the file format of saved plots, from eps to high resolution png.

#Version 5.0 (20240221):
#Rearranged the spectra pre-processing framework by incorporating crop and wavelet cleaning tasks.
#Added parameters buttons to sigma clip cleaning (now dynamic cleaning), dopcor, and heliocor.
#Fixed a bug in the "Compare with" task.
#Introduced the continuum modeling task, allowing for a more refined way to model and subtract (or divide) the continuum of the spectra.

#Version 4.7 (20240201):
#Adapted the code to the new release of ppxf. Ppxf is no longer included in the code package and must be installed via pip.
#Provided the option to choose between three stellar libraries for the ppxf tasks (kinematics and stellar populations).
#Added the capability to save all parameters and load them.
#Implemented some minor changes to the layout.

#Version 4.6 (20240114):
#Included the emission correction and interpolation of the Lick/IDS indices in the EW measurement task. This provides information about the age, metallicity, and alpha-enhancement of the stellar populations of galaxies using the models of Thomas 2010.
#Implemented Monte Carlo simulations to estimate uncertainties on stellar parameters via Lick/IDS index interpolation.

#Version 4.5 (20231221):
#Added the Lick/IDS index measurements and sigma correction in the EW task.

#Version 4.4 (20230215):
#Introduced the 2D spectra extraction standalone panel (still experimental), enabling the correction and extraction of long-slit 1D spectra from a 2D fits wavelength-calibrated images.

#Version 4.3 (20230207):
#Added the plot window to display the results generated by SPAN.
#Implemented the "match rows" feature in the text editor to match and merge rows of two ASCII files, space-separated, with one column in common.

#Version 4.2 (20231203):
#Introduced the fits header editor button with three possible operations on the fits files:
#Modify the keyword of a single file.
#Modify the keywords of a list of files.
#Extract a keyword from a list of fits files.

#Version 4.1 (20231202):
#Added the blackbody fitting task.

#Version 4.0 (20231123):
#Adjusted the layout of the spectral analysis.
#Added the terminal output.
#Fixed various bugs.
#Rectified the progress bar.
#Introduced the text editor and the menu bar.

#Version 3.5 (20221120):
#Added the ppxf algorithm for kinematics and stellar populations.

#Version 3.4 (20221114):
#Included the Line(s) fitting task.
#Corrected minor bugs.

#Version 3.3 (20221109):
#Modified the Cross-correlation calculation.
#Fixed a bug that caused the program to crash if two spectral analysis tasks were selected.
#Implemented checks and existing conditions on the spectral analysis files and values.

#Version 3.2 (20221106):
#Added tooltips to the tasks/buttons for better clarification of their functions.

#Version 3.1 (20221105):
#Rearranged the GUI.
#Fixed a bug in the sigma coefficient calculation task.

#Version 3.0 (20221104):
#Implemented key values instead of increasing numbers in the GUI. This allows adding and modifying entries without changing all the value numbers.

#Version 2.95 (20220128):
#Added the calculation of the equivalent width (EW) and uncertainties also in magnitude.

#Version 2.9 (20220119):
#Incorporated SNR determination in the EW task. Now, when measuring the EW, the program also provides the SNR calculated in the pseudo-continuum bands.

#Version 2.7 (20211124):
#Adjusted the Sigma coeff and EW correct tasks to be truly standalone, with a proper cycle and progress bar.

#Version 2.6 (20211123):
#Adjusted the position of the preview result button to fit the low resolution of my screen after the upgrade of PySimpleGUI, which enlarged my window automatically and without reason.

#Version 2.5 (20211123):
#Added a progress meter for the "Process All" event.

#Version 2.4 (20211122):
#Now you can finally process just one spectrum!

#Version 2.3 (20211122):
#Added the degrade function in lambda (FWHM) to degrade the spectrum to a certain FWHM in Angstrom.

#Version 2.2 (20210927):
#Adjusted the utility menu and added the possibility to save the SNR of the spectra to a file.

#Version 2.1 (20210916):
#Rearranged the utility menu and introduced the conversion of flux from Jansky to MKS and MKS f_lambda.

#Version 2.0 (20210630):
#Added the 'compare spectra' utility.
#Improved the sigma clipping, now called the clean task.
#Rearranged the tasks in the pre-processing and processing frames.
#Enhanced the plot for velocity dispersion measurements.
#Implemented a check on the existence of the loaded spectra.

#Version 1.9 (20210626):
#Some cosmetic changes to the graphical layout.

#Version 1.8 (20210626):
#Added the save plot option in the spectral analysis frame.
#Improved plots of the sigma coeff determination task.

#Version 1.7 (20210615):
#Changed the file names of the result files to include a timestamp, preventing overwriting of older files. Changed the name of the probram.

#Version 1.6 (20200711):
#Added the task to measure the resolution of the selected spectra in the Utility tab. Some major changes to layout.

#Version 1.0 (202006015):
#Changing to the read_spec function for the 1dFit spec, excluding PyAstronomy.pyasl since it is not working with the standalone version of the program. Now the program is called SPAN and not SPEIM anymore. Welcome SPAN!

####################################################################################
####################################################################################
################ LET'S START #######################################################


#GUI import
from span.FreeSimpleGUI_local import FreeSimpleGUI as sg

#SPAN functions import
from span.span_functions import system_span as stm
from span.span_functions import utilities as uti
from span.span_functions import spec_manipul as spman
from span.span_functions import spec_math as spmt
from span.span_functions import linestrength as ls
from span.span_functions import spec_analysis as span
from span.span_functions import cube_extract as cubextr

#python imports
import numpy as np
import pandas as pd
import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
from matplotlib.colors import LogNorm
import matplotlib.backends.backend_tkagg
from matplotlib.ticker import MultipleLocator
from matplotlib.backend_bases import MouseButton
from matplotlib.widgets import Slider

from astropy.coordinates import SkyCoord, EarthLocation
from astropy.table import Table
from astropy.io import fits
from scipy.signal import argrelextrema
from scipy import interpolate
from skimage.measure import label, regionprops

import time
import datetime

import os
import glob
import io
import sys
import json
import urllib.request
import zipfile

BASE_DIR = os.path.dirname(os.path.abspath(__file__))

def main():

    # all events, keys and values of the program in order to store them in a .json configuration file
    def save_settings(filename, keys, events, values):
        data = {
            'keys': keys,
            'events': events,
            'values': {
                'spec_list': values['spec_list'],
                'wave_units_nm': values['wave_units_nm'],
                'wave_units_a': values['wave_units_a'],
                'wave_units_mu': values['wave_units_mu'],
                'show_hdr': values['show_hdr'],
                'show_step': values['show_step'],
                'show_res': values['show_res'],
                'lambda_res_left': values['lambda_res_left'],
                'lambda_res_right': values['lambda_res_right'],
                'convert_spec': values['convert_spec'],
                'convert_to_txt': values['convert_to_txt'],
                'convert_to_fits': values['convert_to_fits'],
                'compare_spec': values['compare_spec'],
                'spec_to_compare': values['spec_to_compare'],
                'convert_flux': values['convert_flux'],
                'convert_to_fnu': values['convert_to_fnu'],
                'convert_to_fl': values['convert_to_fl'],
                'show_snr': values['show_snr'],
                'wave_snr': values['wave_snr'],
                'delta_wave_snr': values['delta_wave_snr'],

                'cropping': cropping_spectrum,
                'cropping_low_wave': cropping_low_wave,
                'cropping_high_wave': cropping_high_wave,
                'sigma_clip': sigma_clipping,
                'clip_factor': clip_factor,
                'res_spec_for_sigma_clip': sigma_clip_resolution,
                'single_vel_clip' : sigma_clip_single_vel,
                'clip_to_vel': sigma_clip_single_value,
                'file_for_clip': sigma_clip_have_file,
                'sigma_clip_file': sigma_clip_sigma_file,
                'wavelet_cleaning': wavelet_cleaning,
                'sigma_wavelets': sigma_wavelets,
                'wavelets_layers': wavelets_layers,
                'dopcor': dop_cor,

                'dopcor_value': dop_cor_single_shot_vel,
                'dop_cor_have_vel': dop_cor_have_vel,
                'dop_cor_have_z': dop_cor_have_z,
                'file_for_dopcor': dop_cor_have_file,
                'dopcor_file': dop_cor_file,
                'dopcor_single_value': dop_cor_single_shot,
                'helio_corr': helio_corr,
                'file_for_helio': helio_have_file,
                'helio_file': helio_file,
                'helio_single_value': helio_single_shot,
                'helio_location': helio_single_shot_location,
                'helio_date': helio_single_shot_date,
                'helio_ra': ra_obj,
                'helio_dec': dec_obj,

                'rebin': rebinning,
                'rebin_pix_lin': rebinning_linear,
                'rebin_step_pix': rebin_step_pix,
                'rebin_sigma_lin': rebinning_log,
                'rebin_step_sigma': rebin_step_sigma,

                'degrade_resolution': degrade,
                'is_initial_res_r': is_initial_res_r,
                'degrade_from_r': initial_res_r,
                'res_degrade_to_r': res_degrade_to_r,
                'degrade_to_r': final_res_r,
                'res_degrade_to_fwhm': res_degrade_to_fwhm,
                'final_res_r_to_fwhm': final_res_r_to_fwhm,
                'is_initial_res_fwhm': is_initial_res_fwhm,
                'degrade_from_l': initial_res_fwhm,
                'degrade_to_l': final_res_fwhm,

                'norm_spec': normalize_wave,
                'norm_wave': norm_wave,

                'cont_sub': continuum_sub,
                'cont_model_filtering' : cont_model_filtering,
                'cont_model_poly' : cont_model_poly,
                'markers_cont_operations' : cont_math_operation,
                'cont_want_to_maks' : cont_want_to_maks,
                'cont_mask_ranges' : cont_mask_ranges_str,
                'cont_poly_degree' : cont_poly_degree,

                'broadening_spec': sigma_broad,
                'sigma_to_add': sigma_to_add,
                'add_noise': add_noise,
                'noise_to_add': noise_to_add,

                'filter_denoise' : filter_denoise,
                'moving_average' : moving_average,
                'box_moving_avg' : box_moving_avg,
                'box_moving_avg_size' : box_moving_avg_size,
                'gauss_moving_avg' : gauss_moving_avg,
                'gauss_moving_avg_kernel' : gauss_moving_avg_kernel,
                'low_pass_filter' : low_pass_filter,
                'lowpass_cut_off' : lowpass_cut_off,
                'lowpass_order' : lowpass_order,
                'bandpass_filter' : bandpass_filter,
                'bandpass_lower_cut_off' : bandpass_lower_cut_off,
                'bandpass_upper_cut_off' : bandpass_upper_cut_off,
                'bandpass_order' : bandpass_order,
                'avg_all': average_all,

                'norm_avg_all': norm_and_average,
                'none': do_nothing,
                'sum_all': sum_all,
                'norm_sum_all': normalize_and_sum_all,
                'use_for_spec_an': use_for_spec_an,
                'subtract_norm_avg': subtract_normalized_avg,
                'subtract_norm_spec': subtract_normalized_spec,
                'spec_to_sobtract': spectra_to_subtract,
                'add_pedestal': add_pedestal,
                'pedestal_to_add': pedestal_to_add,
                'multiply': multiply,
                'multiply_factor': multiply_factor,
                'derivatives' : derivatives,
                'reorder_op' : reorder_op,
                'current_order': current_order,

                'bb_fitting': values['bb_fitting'],
                'xcorr': values['xcorr'],
                'sigma_measurement': values['sigma_measurement'],
                'ew_measurement': values['ew_measurement'],
                'line_fitting': values['line_fitting'],
                'ppxf_kin': values['ppxf_kin'],
                'ppxf_pop': values['ppxf_pop'],
                'sigma_coeff': sigma_coeff,
                'sigma_corr': sigma_corr,
                'save_intermediate_files': values['save_intermediate_files'],
                'save_plots': values['save_plots'],

                #Blackbody parameters
                'left_wave_bb': wave1_bb,
                'right_wave_bb': wave2_bb,
                't_guess_bb': t_guess,

                #Cross-corr parameters
                'xcorr_template': template_crosscorr,
                'xcorr_template_wave_nm': lambda_units_template_crosscorr_nm,
                'xcorr_template_wave_a': lambda_units_template_crosscorr_a,
                'xcorr_template_wave_mu': lambda_units_template_crosscorr_mu,
                'xcorr_smooth_template': smooth_template_crosscorr,
                'xcorr_smooth_template_value': smooth_value_crosscorr,
                'xcorr_left_lambda': low_wave_corr,
                'xcorr_right_lambda': high_wave_corr,
                'is_vel_xcorr': is_vel_xcorr,
                'is_z_xcorr': is_z_xcorr,
                'xcorr_low_vel': low_vel_corr,
                'xcorr_high_vel': high_vel_corr,
                'low_z_corr': low_z_corr,
                'high_z_corr': high_z_corr,

                #Velocity dispersion parameters
                'sigma_template': template_sigma,
                'lambda_units_template_sigma_nm': lambda_units_template_sigma_nm,
                'lambda_units_template_sigma_a': lambda_units_template_sigma_a,
                'lambda_units_template_sigma_mu': lambda_units_template_sigma_mu,
                'band_cat': band_cat,
                'band_halpha': band_halpha,
                'band_nad': band_nad,
                'band_h': band_h,
                'band_k': band_k,
                'resolution_spec': resolution_spec,
                'resolution_template': resolution_template,
                'band_custom': band_custom,
                'low_wave_sigma': low_wave_sigma,
                'high_wave_sigma': high_wave_sigma,
                'low_wave_cont': low_wave_cont,
                'high_wave_cont': high_wave_cont,

                #Line-strength parameters
                'ew_idx_file': have_index_file,
                'idx_file': index_file,
                'single_index': single_index,
                'left_wave_blue_cont': idx_left_blue,
                'right_wave_blue_cont': idx_right_blue,
                'left_wave_red_cont': idx_left_red,
                'right_wave_red_cont': idx_right_red,
                'left_line': idx_left_line,
                'right_line': idx_right_line,
                'ew_lick': lick_ew,
                'lick_constant_fwhm': lick_constant_fwhm,
                'spec_lick_res_fwhm': spec_lick_res_fwhm,
                'lick_constant_r': lick_constant_r,
                'spec_lick_res_r': spec_lick_res_r,
                'lick_correct_emission': lick_correct_emission,
                'z_guess_lick_emission': z_guess_lick_emission,
                'dop_correction_lick': dop_correction_lick,
                'correct_ew_sigma': correct_ew_sigma,
                'radio_lick_sigma_auto': radio_lick_sigma_auto,
                'radio_lick_sigma_single': radio_lick_sigma_single,
                'sigma_single_lick': sigma_single_lick,
                'radio_lick_sigma_list': radio_lick_sigma_list,
                'sigma_lick_file': sigma_lick_file,
                'stellar_parameters_lick': stellar_parameters_lick,
                'ssp_model': ssp_model,
                'ew_corr_idx_file': have_index_file_corr,
                'idx_corr_file': index_file_corr,
                'ew_corr_single_idx': single_index_corr,
                'stellar_spectra_coeff_file': stellar_spectra_coeff_file,
                'sigma_coeff_sample_list': stellar_spectra_coeff_file,
                'sigma_coeff_sample_list_wave_nm': lambda_units_coeff_nm,
                'sigma_coeff_sample_list_wave_a': lambda_units_coeff_a,
                'sigma_coeff_sample_list_wave_mu': lambda_units_coeff_mu,
                'sigma_coeff_sample_smooth': smooth_stellar_sample,
                'sigma_coeff_sample_smooth_sigma': smooth_value_sample,
                'sigma_file': sigma_vel_file,
                'ew_file_to_correct': ew_list_file,
                'coeff_sigma_file': sigma_coeff_file,

                #Line(s) fitting parameters
                'cat_fit': cat_band_fit,
                'line_fit_single': usr_fit_line,
                'emission_line': emission_line,
                'left_wave_fitting': low_wave_fit,
                'right_wave_fitting': high_wave_fit,
                'y0': y0,
                'x0': x0,
                'a': a,
                'sigma': sigma,
                'm': m,
                'c': c,

                #Stars and gas kinematics parameters
                'left_wave_ppxf_kin': wave1_kin,
                'right_wave_ppxf_kin': wave2_kin,
                'stellar_library_kin': stellar_library_kin,
                'constant_resolution_lambda': constant_resolution_lambda,
                'ppxf_resolution': resolution_kin,
                'constant_resolution_r': constant_resolution_r,
                'ppxf_resolution_r': resolution_kin_r,
                'sigma_guess_kin': sigma_guess_kin,
                'redshift_guess_kin': redshift_guess_kin,
                'additive_degree_kin': additive_degree_kin,
                'gas_kin': gas_kin,
                'no_gas_kin': no_gas_kin,
                'kin_best_noise': kin_best_noise,
                'with_errors_kin': with_errors_kin,
                'kin_moments': kin_moments,
                'ppxf_kin_noise': ppxf_kin_noise,
                'ppxf_kin_preloaded_lib': ppxf_kin_preloaded_lib,
                'ppxf_kin_custom_lib': ppxf_kin_custom_lib,
                'ppxf_kin_lib_folder': ppxf_kin_lib_folder,
                'ppxf_kin_custom_temp_suffix': ppxf_kin_custom_temp_suffix,
                'ppxf_kin_tie_balmer': ppxf_kin_tie_balmer,
                'ppxf_kin_dust_stars': ppxf_kin_dust_stars,
                'ppxf_kin_dust_gas': ppxf_kin_dust_gas,
                'ppxf_kin_two_stellar_components': ppxf_kin_two_stellar_components,
                'ppxf_kin_age_model1': ppxf_kin_age_model1,
                'ppxf_kin_met_model1': ppxf_kin_met_model1,
                'ppxf_kin_age_model2': ppxf_kin_age_model2,
                'ppxf_kin_met_model2': ppxf_kin_met_model2,
                'ppxf_kin_vel_model1': ppxf_kin_vel_model1,
                'ppxf_kin_sigma_model1': ppxf_kin_sigma_model1,
                'ppxf_kin_vel_model2': ppxf_kin_vel_model2,
                'ppxf_kin_sigma_model2': ppxf_kin_sigma_model2,
                'ppxf_kin_mask_emission': ppxf_kin_mask_emission,
                'ppxf_kin_mc_sim': ppxf_kin_mc_sim,

                #Stellar populations and SFH parameters
                'left_wave_ppxf_pop': wave1_pop,
                'right_wave_ppxf_pop': wave2_pop,
                'resolution_ppxf_pop': res_pop,
                'sigma_guess_pop': sigma_guess_pop,
                'ppxf_z_pop': z_pop,
                'gas_pop': pop_with_gas,
                'ppxf_pop_tie_balmer': ppxf_pop_tie_balmer,
                'ppxf_pop_dust_stars': ppxf_pop_dust_stars,
                'ppxf_pop_dust_gas': ppxf_pop_dust_gas,
                'ppxf_pop_noise': ppxf_pop_noise,
                'ppxf_min_age': ppxf_min_age,
                'ppxf_max_age': ppxf_max_age,
                'ppxf_min_met': ppxf_min_met,
                'ppxf_max_met': ppxf_max_met,
                'no_gas_pop': pop_without_gas,
                'regul_err': regul_err,
                'additive_degree': additive_degree,
                'multiplicative_degree': multiplicative_degree,
                'stellar_library': stellar_library,
                'ppxf_err_pop': with_errors,
                'ppxf_pop_preloaded_lib':ppxf_pop_preloaded_lib,
                'ppxf_pop_custom_lib':ppxf_pop_custom_lib,
                'ppxf_pop_lib_folder':ppxf_pop_lib_folder,
                'ppxf_pop_custom_npz':ppxf_pop_custom_npz,
                'ppxf_pop_npz_file':ppxf_pop_npz_file,
                'ppxf_pop_mask':ppxf_pop_mask,
                'ppxf_custom_temp_suffix':ppxf_custom_temp_suffix,
                'ppxf_best_param':ppxf_best_param,
                'ppxf_best_noise_estimate':ppxf_best_noise_estimate,
                'ppxf_frac_chi':ppxf_frac_chi,
                'ppxf_pop_convolve':ppxf_pop_convolve,
                'ppxf_pop_want_to_mask':ppxf_pop_want_to_mask,
                'ppxf_pop_mask_ranges_str':ppxf_pop_mask_ranges_str,
                'ppxf_pop_error_nsim':ppxf_pop_error_nsim,
                'ppxf_pop_lg_age':ppxf_pop_lg_age,
                'stellar_parameters_lick_ppxf': stellar_parameters_lick_ppxf,
                'ssp_model_ppxf': ssp_model_ppxf,
                'interp_model_ppxf': interp_model_ppxf,

                # Long-slit (2D) extraction parameters
                'file_path': file_path_spec_extr,
                'trace_y_range': trace_y_range_str,
                'poly_degree': poly_degree_str,
                'extract_y_range':extract_y_range_str,
                'snr': snr_threshold_str,
                'pix_scale': pixel_scale_str,

                #cube extraction parameters
                'ifs_run_id': ifs_run_id,
                'ifs_input': ifs_input,
                'ifs_redshift': ifs_redshift,
                'ifs_routine_read': ifs_routine_read_default,
                'ifs_origin': ifs_origin,
                'ifs_lmin_tot': ifs_lmin_tot,
                'ifs_lmax_tot': ifs_lmax_tot,
                'ifs_min_snr_mask': ifs_min_snr_mask,
                'ifs_mask': ifs_mask,
                'ifs_target_snr': ifs_target_snr,
                'ifs_preloaded_routine': ifs_preloaded_routine,
                'ifs_user_routine': ifs_user_routine,
                'ifs_user_routine_file': ifs_user_routine_file,
                'ifs_manual_bin': ifs_manual_bin,
                'ifs_voronoi': ifs_voronoi,
            }
        }
        with open(filename, 'w') as file:
            json.dump(data, file)

    #function to load the .json configuration file
    def load_settings(filename):
        try:
            with open(filename, 'r') as file:
                data = json.load(file)
                return data['keys'], data['events'], data['values']
        except FileNotFoundError:
            return [], [], {}


#***************************************************************************************************************#


    ################ FreeSimpleGUI User Interface construction ####################
    listbox1 = ['Load a spectra file list and click Load!']
    default_spectra_list = os.path.join(BASE_DIR, "example_files", "xshooter_vis_sample_list_spectra.dat")

    sg.SetOptions(tooltip_time=1000) #tooltip time after mouse over


    #************************************************************************************
    #************************************************************************************
    #Layout optimized for Windows systems

    #Building the main panel#
    layout_windows = [
                [sg.Menu([
                    ['&File', ['&Load!', '&Save parameters...', 'Load parameters...', 'Restore default parameters', 'E&xit']],
                    ['&Edit', ['&Copy', '&Paste', 'Clear all tas&ks', 'Clean output', 'Show result folder', 'Change result folder...']],
                    ['&Window', ['Long-slit extraction', 'DataCube extraction', 'Text editor', 'FITS header editor', 'Plot data', 'Spectra manipulation']],
                    ['P&rocess',['Pl&ot', 'Pre&view spec.']],
                    ['&Analysis', ['Preview res&ult', 'Proc&ess selected', 'Process a&ll']],
                    ['&Help', ['&Quick start', '&Read me', 'Tips and tricks']],
                    ['&About', ['About SPAN', 'Version', 'Read me']]
                    ])
                ],

                [sg.Frame('Prepare and load spectra', [
                [sg.Text('1. Extract 1D spectra from 2D or 3D FITS images', font = ('', 11 ,'bold'))],
                [sg.Button('Long-slit extraction', tooltip='Stand alone program to extract 1D spectra from 2D fits',button_color= ('black','light blue')), sg.Button('DataCube extraction', tooltip='Stand alone program to extract 1D spectra from data cubes',button_color= ('black','light blue'))],
                [sg.HorizontalSeparator()],
                [sg.Text('2. Generate a spectra list containing 1D spectra', font = ('', 11 ,'bold'))],
                [sg.Button('Generate spectra list containing 1D spectra', key = 'listfile',tooltip='If you do not have a spectra file list, you can generate here')],
                # [sg.Text('', font = ("Helvetica", 1))],
                [sg.HorizontalSeparator()],
                [sg.Text('3. Browse the spectra list or just one spectrum', font = ('', 11 ,'bold'))],
                [sg.InputText(default_spectra_list, size=(34, 1), key='spec_list' ), sg.FileBrowse(tooltip='Load an ascii file list of spectra or a single (fits, txt) spectrum')],
                [sg.Checkbox('I browsed a single spectrum', font = ('Helvetica', 10, 'bold'), key='one_spec',tooltip='Check this if you want to load just one spectrum instead a text file containing the names of the spectra')],
                [sg.Text('Wavelength of the spectra is in:',tooltip='Set the correct wavelength units of your spectra: Angstrom, nm, mu'), sg.Radio('nm', "RADIO2", default=True, key = 'wave_units_nm' ), sg.Radio('A', "RADIO2", key = 'wave_units_a'), sg.Radio('mu', "RADIO2" , key = 'wave_units_mu')],
                [sg.HorizontalSeparator()],
                [sg.Text('4. Finally load the browsed spectra to SPAN', font = ('', 11 ,'bold'))],
                [sg.Button('Load!', font = ("Helvetica", 11, 'bold'),button_color=('black','light green'), size = (11,1)), sg.Push(), sg.Button('Plot',button_color=('black','light gray'), size = (10,1))],
                ], font=("Helvetica", 14, 'bold'), title_color = 'orange'), sg.Listbox(values = listbox1, size=(46, 19), key='-LIST-', horizontal_scroll=True),

                #Utility frame
                sg.Frame('Utilities', [
                [sg.Checkbox('Show the header of the selected spectrum', font = ('Helvetica', 11, 'bold'), key = 'show_hdr',tooltip='Show fits header')],
                [sg.Checkbox('Show the wavelenght step of the spectrum', font = ('Helvetica', 11, 'bold'), key = 'show_step',tooltip='Show spectrum wavelength step')],
                [sg.Checkbox('Estimate the resolution:', font = ('Helvetica', 11, 'bold'), key = 'show_res',tooltip='Show resolution, by fitting a sky emission line within the wavelength 1(W1) and wavelength 2(W2) values'),sg.Text('W1'), sg.InputText('550', size = (5,1), key = 'lambda_res_left'), sg.Text('W2'), sg.InputText('565', size = (5,1), key = 'lambda_res_right')],
                [sg.HorizontalSeparator()],
                [sg.Checkbox('Convert the spectrum to:', font = ('Helvetica', 11, 'bold'), key = 'convert_spec',tooltip='Convert one or all the spectra from fits to ASCII and viceversa'), sg.Radio('Text', "RADIOCONV", default = True, key = 'convert_to_txt'), sg.Radio('FITS', "RADIOCONV", key = 'convert_to_fits')],
                [sg.Checkbox('Compare spectrum with: ', font = ('Helvetica', 11, 'bold'), key = 'compare_spec',tooltip='Compare the selected spectrum with any other loaded spectrum'), sg.InputText('Spec.', size = (11,1), key = 'spec_to_compare'), sg.FileBrowse(tooltip='Load the 1D spectrum (ASCII or fits)to use as comparison')],
                [sg.Checkbox('Convert Flux', font = ('Helvetica', 11, 'bold'), key = 'convert_flux',tooltip='Convert the flux from Jansky to F_lambda and viceversa'), sg.Radio('Jy-->F_nu', "FLUX", default = True, key = 'convert_to_fnu'), sg.Radio('Jy-->F_l', "FLUX", key = 'convert_to_fl'),sg.Button('See plot',button_color=('black','light gray')), sg.Text(' ', font = ('Helvetica', 1)) ],
                [sg.Checkbox('S/N:', font = ('Helvetica', 11, 'bold'), key = 'show_snr',tooltip='Show the S/N of the selected spectrum centered on an user defined wavelength(W)'), sg.Text(' W.'), sg.InputText('645', size = (4,1), key = 'wave_snr'), sg.Text('+/-'), sg.InputText(3, size = (3,1), key = 'delta_wave_snr'), sg.Button('Save one',button_color=('black','light gray')), sg.Button('Save all',button_color=('black','light gray'))],
                [sg.HorizontalSeparator()],
                [sg.Text('Spectra manipulation panel:', font = ('Helvetica', 11, 'bold')), sg.Push(), sg.Button('Spectra manipulation', size = (18,1),button_color= ('black','light blue'), font=("Helvetica", 10, 'bold'), tooltip='Open the spectra manipulation panel to modify the spectra')],
                [sg.HorizontalSeparator()],
                [sg.Text('Tools:', font = ('Helvetica', 11, 'bold')), sg.Push(), sg.Button('Text editor', tooltip='Stand alone simple text editor',button_color= ('black','light blue')),sg.Button('FITS header editor', tooltip='Stand alone FITS header editor',button_color= ('black','light blue')), sg.Button('Plot data', tooltip='Stand alone data plotter. ASCII files with spaced rows',button_color= ('black','light blue'))],
                ], font=("Helvetica", 12, 'bold')),

                #Buttons to perform the utility actions
                sg.Frame('Utility Actions',[
                [sg.Text('')],
                [sg.Button('Show info',button_color=('black','light gray'), size = (11,1))],
                [sg.Text('',font=("Helvetica", 5))],
                [sg.Text('')],
                [sg.HorizontalSeparator()],
                [sg.Button('One',button_color=('black','light gray'), size = (5,1)), sg.Button('All',button_color=('black','light gray'), size = (4,1))],
                [sg.Button('Compare',button_color=('black','light gray'), size = (11,1))],
                [sg.Button('One',button_color=('black','light gray'), size = (5,1), key = ('convert_one')), sg.Button('All',button_color=('black','light gray'), size = (4,1), key = 'convert_all')],
                [sg.Button('Show snr',button_color=('black','light gray'), size = (11,1))],
                [sg.HorizontalSeparator()],
                [sg.Button('Preview spec.',button_color=('black','light gray'), size = (11,1), font=("Helvetica", 10),tooltip='View the modified version of the selected spectrum')],
                [sg.HorizontalSeparator()],
                [sg.Text('')],
                [sg.Text('',font=("Helvetica", 1))],
                ] ,font=("Helvetica", 10, 'bold'))],
                [sg.HorizontalSeparator()],
                [sg.Text('',font=("Helvetica", 1))],

                #Spectral analysis frame
                [sg.Frame('Spectral analysis', [

                #1) Black-body fitting
                [sg.Checkbox('Planck Blackbody fitting', font = ('Helvetica', 12, 'bold'), key = 'bb_fitting',tooltip='Blackdoby Planck function fitting. Works fine for stellar spectra and wide wavelength range'),sg.Push(), sg.Button('Blackbody parameters',button_color= ('black','light blue'), size = (22,1))],

                #2) Cross-correlation
                [sg.Checkbox('Cross-correlation', font = ('Helvetica', 12, 'bold'), key = 'xcorr',tooltip='Cross-correlating a band with a template. Works better with continuum normalisation. Use Kinematics for more accurate results'),sg.Push(), sg.Button('Cross-corr parameters',button_color= ('black','light blue'), size = (22,1))],

                #3) Velocity disperion measurement
                [sg.Checkbox('Velocity dispersion', font = ('Helvetica', 12, 'bold'), key = 'sigma_measurement',tooltip='Fitting a band with a template. Rough but fast. Use Kinematics for accurate science results'),sg.Push(), sg.Button('Sigma parameters',button_color= ('black','light blue'), size = (22,1))],

                #4) Line-strength
                [sg.Checkbox('Line-strength analysis', font = ('Helvetica', 12, 'bold'), key = 'ew_measurement',tooltip='Equivalent width measurement for a list of indices, a single user defined index and Lick/IDS indices'),sg.Push(), sg.Button('Line-strength parameters',button_color= ('black','light blue'), size = (22,1))],

                #5) Line fitting
                [sg.Checkbox('Line(s) fitting', font = ('Helvetica', 12, 'bold'), key = 'line_fitting',tooltip='User line or automatic CaT band fitting with gaussian functions'),sg.Push(), sg.Button('Line fitting parameters',button_color= ('black','light blue'), size = (22,1))],

                #6) Kinematics with ppxf
                [sg.Checkbox('Stars and gas kinematics', font = ('Helvetica', 12, 'bold'), key = 'ppxf_kin',tooltip='Perform the fitting of a spectral region and gives the kinematics'),sg.Push(), sg.Button('Kinematics parameters',button_color= ('black','light blue'), size = (22,1))  ],

                #7) Stellar populations with ppxf
                [sg.Checkbox('Stellar populations and SFH', font = ('Helvetica', 12, 'bold'), key = 'ppxf_pop',tooltip='Perform the fitting of a spectral region and gives the properties of the stellar populations'),sg.Push(), sg.Button('Population parameters',button_color= ('black','light blue'), size = (22,1))  ],
                ], font=("Helvetica", 14, 'bold'), title_color='yellow'),

                # Buttons to perform the spectral analysis actions
                sg.Frame('An. Actions',[
                [sg.Button('Help me',button_color=('black','orange'), size = (12,1))],
                [sg.Text('')],
                [sg.Button('Preview result',button_color=('black','light gray'),tooltip='Preview all the results of the Spectral analysis frame', size = (12,2), font=("Helvetica", 10, 'bold'))],
                [sg.Text('')],
                [sg.Text('')],
                [sg.Text('')],
                [sg.Text('')],
                [sg.Text('', font = ('Helvetica',16))],
                ],font=("Helvetica", 9, 'bold')),

                #COMMENT THE FOLLOWING THREE LINES TO HAVE THE EXTERNAL OUTPUT
                sg.Frame('Output', [
                [sg.Output(size=(81, 14), key='-OUTPUT-', font = ('Helvetica', 11))],
                ] ,font=("Helvetica", 12, 'bold')),

                ],

                #General buttons at the end of the panel
                [sg.Button('Process selected', button_color=('white','orange'), size=(15, 1),tooltip='Process the selected spectrum by performing all the enabled tasks'), sg.Button('Process all', button_color=('white','red'), size=(15, 1), tooltip='Process all the loaded spectra by performing all the enabled tasks'), sg.Checkbox('Save intermediate files, if any', default = True, text_color = 'lightgreen', key = 'save_intermediate_files', tooltip='Check this if you want to save all the spectra for any of the Spectra manipulation tasks selected', font = ('Helvetica', 10, 'bold')), sg.Checkbox('Save plots', default = False, text_color='yellow', key = 'save_plots', tooltip='To save all the plots generated by the Spectral Analysis tasks activated and the Process All mode', font = ("Helvetica", 10, 'bold')), sg.Push(), sg.Exit(size=(15, 1),tooltip='See you soon!')]

                    ]


    #************************************************************************************
    #************************************************************************************
    #Layout optimized for Linux systems

    #Building the main panel#
    layout_linux = [
                [sg.Menu([
                    ['&File', ['&Load!', '&Save parameters...', 'Load parameters...', 'Restore default parameters', 'E&xit']],
                    ['&Edit', ['&Copy', '&Paste', 'Clear all tas&ks', 'Clean output', 'Show result folder', 'Change result folder...']],
                    ['&Window', ['Long-slit extraction', 'DataCube extraction', 'Text editor', 'FITS header editor', 'Plot data', 'Spectra manipulation']],
                    ['P&rocess',['Pl&ot', 'Pre&view spec.']],
                    ['&Analysis', ['Preview res&ult', 'Proc&ess selected', 'Process a&ll']],
                    ['&Help', ['&Quick start', '&Read me', 'Tips and tricks']],
                    ['&About', ['About SPAN', 'Version', 'Read me']]
                    ])
                ],

                [sg.Frame('Prepare and load spectra', [
                [sg.Text('1. Extract spectra from 2D or 3D FITS', font = ('', 11 ,'bold'))],
                [sg.Button('Long-slit extraction', tooltip='Stand alone program to extract 1D spectra from 2D fits',button_color= ('black','light blue')), sg.Button('DataCube extraction', tooltip='Stand alone program to extract 1D spectra from data cubes',button_color= ('black','light blue'))],
                [sg.HorizontalSeparator()],
                [sg.Text('2. Generate a spectra list with 1D spectra', font = ('', 11 ,'bold'))],
                [sg.Button('Generate spectra list containing 1D spectra', key = 'listfile',tooltip='If you do not have a spectra file list, you can generate here')],
                # [sg.Text('', font = ("Helvetica", 1))],
                [sg.HorizontalSeparator()],
                [sg.Text('3. Browse the spectra list or one spectrum', font = ('', 11 ,'bold'))],
                [sg.InputText(default_spectra_list, size=(34, 1), key='spec_list' ), sg.FileBrowse(tooltip='Load an ascii file list of spectra or a single (fits, txt) spectrum')],
                [sg.Checkbox('I browsed a single spectrum', font = ('Helvetica', 10, 'bold'), key='one_spec',tooltip='Check this if you want to load just one spectrum instead a text file containing the names of the spectra')],
                [sg.Text('Wavelength of the spectra is in:',tooltip='Set the correct wavelength units of your spectra: Angstrom, nm, mu'), sg.Radio('nm', "RADIO2", default=True, key = 'wave_units_nm' ), sg.Radio('A', "RADIO2", key = 'wave_units_a'), sg.Radio('mu', "RADIO2" , key = 'wave_units_mu')],
                [sg.HorizontalSeparator()],
                [sg.Text('4. Finally load the spectra to SPAN', font = ('', 11 ,'bold'))],
                [sg.Button('Load!', font = ("Helvetica", 11, 'bold'),button_color=('black','light green'), size = (11,1)), sg.Push(), sg.Button('Plot',button_color=('black','light gray'), size = (10,1))],
                ], font=("Helvetica", 14, 'bold'), title_color = 'orange'), sg.Listbox(values = listbox1, size=(48, 21), key='-LIST-', horizontal_scroll=True, font=("Helvetica", 11) ),

                #Utility frame
                sg.Frame('Utilities', [
                [sg.Checkbox('Show the header of the selected spectrum', font = ('Helvetica', 11, 'bold'), key = 'show_hdr',tooltip='Show fits header')],
                [sg.Checkbox('Show the wavelenght step of the spectrum', font = ('Helvetica', 11, 'bold'), key = 'show_step',tooltip='Show spectrum wavelength step')],
                [sg.Checkbox('Estimate the resolution:', font = ('Helvetica', 11, 'bold'), key = 'show_res',tooltip='Show resolution, by fitting a sky emission line within the wavelength 1(W1) and wavelength 2(W2) values'),sg.Text('W1'), sg.InputText('550', size = (4,1), key = 'lambda_res_left'), sg.Text('W2'), sg.InputText('565', size = (4,1), key = 'lambda_res_right')],
                [sg.HorizontalSeparator()],
                [sg.Checkbox('Convert the spectrum to:', font = ('Helvetica', 11, 'bold'), key = 'convert_spec',tooltip='Convert one or all the spectra from fits to ASCII and viceversa'), sg.Radio('Text', "RADIOCONV", default = True, key = 'convert_to_txt'), sg.Radio('FITS', "RADIOCONV", key = 'convert_to_fits')],
                [sg.Checkbox('Compare with: ', font = ('Helvetica', 11, 'bold'), key = 'compare_spec',tooltip='Compare the selected spectrum with any other loaded spectrum'), sg.InputText('Spec.', size = (7,1), key = 'spec_to_compare'), sg.FileBrowse(tooltip='Load the 1D spectrum (ASCII or fits)to use as comparison')],
                [sg.Checkbox('Convert Flux', font = ('Helvetica', 11, 'bold'), key = 'convert_flux',tooltip='Convert the flux from Jansky to F_lambda and viceversa'), sg.Radio('Jy-->F_nu', "FLUX", default = True, key = 'convert_to_fnu'), sg.Radio('Jy-->F_l', "FLUX", key = 'convert_to_fl'),sg.Button('See plot',button_color=('black','light gray')), sg.Text(' ', font = ('Helvetica', 1)) ],
                [sg.Checkbox('S/N:', font = ('Helvetica', 11, 'bold'), key = 'show_snr',tooltip='Show the S/N of the selected spectrum centered on an user defined wavelength(W)'), sg.Text(' W.'), sg.InputText('645', size = (4,1), key = 'wave_snr'), sg.Text('+/-'), sg.InputText(3, size = (3,1), key = 'delta_wave_snr'), sg.Button('Save one',button_color=('black','light gray')), sg.Button('Save all',button_color=('black','light gray'))],
                [sg.HorizontalSeparator()],

                [sg.Text('Spectra manipulation panel:', font = ('Helvetica', 11, 'bold')),sg.Button('Spectra manipulation', size = (18,1),button_color= ('black','light blue'), font=("Helvetica", 10, 'bold'), tooltip='Open the spectra manipulation panel to modify the spectra')],
                [sg.HorizontalSeparator()],
                [sg.Text('Tools:', font = ('Helvetica', 11, 'bold')), sg.Push(), sg.Button('Text editor', tooltip='Stand alone simple text editor',button_color= ('black','light blue')),sg.Button('FITS header editor', tooltip='Stand alone FITS header editor',button_color= ('black','light blue')), sg.Button('Plot data', tooltip='Stand alone data plotter. ASCII files with spaced rows',button_color= ('black','light blue'))],
                [sg.Text('',font=("Helvetica", 5))],
                ], font=("Helvetica", 12, 'bold')),

                #Buttons to perform the utility actions
                sg.Frame('Utility Actions',[
                [sg.Text('')],
                [sg.Button('Show info',button_color=('black','light gray'), size = (11,1))],
                [sg.Text('')],
                [sg.HorizontalSeparator()],
                [sg.Button('One',button_color=('black','light gray'), size = (3,1)), sg.Button('All',button_color=('black','light gray'), size = (2,1))],
                [sg.Button('Compare',button_color=('black','light gray'), size = (11,1))],
                [sg.Button('One',button_color=('black','light gray'), size = (3,1), key ='convert_one'), sg.Button('All',button_color=('black','light gray'), size = (2,1), key = 'convert_all')],
                [sg.Button('Show snr',button_color=('black','light gray'), size = (11,1))],
                [sg.HorizontalSeparator()],
                [sg.Button('Preview spec.',button_color=('black','light gray'), size = (12,1), font=("Helvetica", 10, 'bold'),tooltip='View the modified version of the selected spectrum')],
                [sg.HorizontalSeparator()],
                [sg.Text('')],
                [sg.Text('',font=("Helvetica", 8))],
                ] ,font=("Helvetica", 10, 'bold'))],
                [sg.HorizontalSeparator()],
                [sg.Text('',font=("Helvetica", 1))],

                #Spectral analysis frame
                [sg.Frame('Spectral analysis', [

                #1) Black-body fitting
                [sg.Checkbox('Planck Blackbody fitting', font = ('Helvetica', 12, 'bold'), key = 'bb_fitting',tooltip='Blackdoby Planck function fitting. Works fine for stellar spectra and wide wavelength range'),sg.Push(), sg.Button('Blackbody parameters',button_color= ('black','light blue'), size = (22,1))],

                #2) Cross-correlation
                [sg.Checkbox('Cross-correlation', font = ('Helvetica', 12, 'bold'), key = 'xcorr',tooltip='Cross-correlating a band with a template. Works better with continuum normalisation. Use Kinematics for more accurate results'),sg.Push(), sg.Button('Cross-corr parameters',button_color= ('black','light blue'), size = (22,1))],

                #3) Velocity disperion measurement
                [sg.Checkbox('Velocity dispersion', font = ('Helvetica', 12, 'bold'), key = 'sigma_measurement',tooltip='Fitting a band with a template. Rough but fast. Use Kinematics for accurate science results'),sg.Push(), sg.Button('Sigma parameters',button_color= ('black','light blue'), size = (22,1))],

                #4) Line-strength
                [sg.Checkbox('Line-strength analysis', font = ('Helvetica', 12, 'bold'), key = 'ew_measurement',tooltip='Equivalent width measurement for a list of indices, a single user defined index and Lick/IDS indices'),sg.Push(), sg.Button('Line-strength parameters',button_color= ('black','light blue'), size = (22,1))],

                #5) Line fitting
                [sg.Checkbox('Line(s) fitting', font = ('Helvetica', 12, 'bold'), key = 'line_fitting',tooltip='User line or automatic CaT band fitting with gaussian functions'),sg.Push(), sg.Button('Line fitting parameters',button_color= ('black','light blue'), size = (22,1))],

                #6) Kinematics with ppxf
                [sg.Checkbox('Stars and gas kinematics', font = ('Helvetica', 12, 'bold'), key = 'ppxf_kin',tooltip='Perform the fitting of a spectral region and gives the kinematics'),sg.Push(), sg.Button('Kinematics parameters',button_color= ('black','light blue'), size = (22,1))  ],

                #7) Stellar populations with ppxf
                [sg.Checkbox('Stellar populations and SFH', font = ('Helvetica', 12, 'bold'), key = 'ppxf_pop',tooltip='Perform the fitting of a spectral region and gives the properties of the stellar populations'),sg.Push(), sg.Button('Population parameters',button_color= ('black','light blue'), size = (22,1))  ],
                ], font=("Helvetica", 14, 'bold'), title_color='yellow'),

                # Buttons to perform the spectral analysis actions
                sg.Frame('An. Actions',[
                [sg.Button('Help me',button_color=('black','orange'), size = (12,1))],
                [sg.Text('')],
                [sg.Button('Preview result',button_color=('black','light gray'),tooltip='Preview all the results of the Spectral analysis frame', size = (12,2), font=("Helvetica", 10, 'bold'))],
                [sg.Text('')],
                [sg.Text('')],
                [sg.Text('')],
                [sg.Text('')],
                [sg.Text('', font = ('Helvetica',24))],

                ],font=("Helvetica", 9, 'bold')),

                #COMMENT THE FOLLOWING THREE LINES TO HAVE THE EXTERNAL OUTPUT
                sg.Frame('Output', [
                [sg.Output(size=(88, 16), key='-OUTPUT-' , font=('Helvetica', 11))],
                ] ,font=("Helvetica", 12, 'bold')),

                ],

                #General buttons at the end of the panel
                [sg.Button('Process selected', button_color=('white','orange'), size=(15, 1),tooltip='Process the selected spectrum by performing all the enabled tasks'), sg.Button('Process all', button_color=('white','red'), size=(15, 1), tooltip='Process all the loaded spectra by performing all the enabled tasks'), sg.Checkbox('Save intermediate files, if any', default = True, text_color = 'lightgreen', key = 'save_intermediate_files', tooltip='Check this if you want to save all the spectra for any of the tasks selected', font = ('Helvetica', 10, 'bold')), sg.Checkbox('Save plots', default = False, text_color='yellow', key = 'save_plots', tooltip='To save all the plots generated by the Spectral Analysis tasks activated and the Process All method', font = ("Helvetica", 10, 'bold')), sg.Push(), sg.Exit(size=(15, 1),tooltip='See you soon!')]

                    ]




    #************************************************************************************
    #************************************************************************************
    #Layout optimized for MacOS systems
    layout_macos = [
                [sg.Menu([
                    ['&File', ['&Load!', '&Save parameters...', 'Load parameters...', 'Restore default parameters', 'E&xit']],
                    ['&Edit', ['&Copy', '&Paste', 'Clear all tas&ks', 'Show result folder', 'Change result folder...']],
                    ['&Window', ['Long-slit extraction', 'DataCube extraction', 'Text editor', 'FITS header editor', 'Plot data', 'Spectra manipulation']],
                    ['P&rocess',['Pl&ot', 'Pre&view spec.']],
                    ['&Analysis', ['Preview res&ult', 'Proc&ess selected', 'Process a&ll']],
                    ['&Help', ['&Quick start', '&Read me', 'Tips and tricks']],
                    ['&About', ['About SPAN', 'Version', 'Read me']]
                    ])
                ],

                [sg.Frame('Prepare and load spectra', [
                [sg.Text('1. Extract spectra from 2D or 3D FITS', font = ('', 14 ,'bold'))],
                [sg.Button('Long-slit extraction', tooltip='Stand alone program to extract 1D spectra from 2D fits',button_color= ('black','light blue')), sg.Button('DataCube extraction', tooltip='Stand alone program to extract 1D spectra from data cubes',button_color= ('black','light blue'))],
                [sg.HorizontalSeparator()],
                [sg.Text('2. Generate a 1D spectra list', font = ('', 14 ,'bold'))],
                [sg.Button('Generate spectra list containing 1D spectra', key = 'listfile',tooltip='If you do not have a spectra file list, you can generate here')],
                # [sg.Text('', font = ("Helvetica", 1))],
                [sg.HorizontalSeparator()],
                [sg.Text('3. Browse the list or one spectrum', font = ('', 14 ,'bold'))],
                [sg.InputText(default_spectra_list, size=(34, 1), key='spec_list' ), sg.FileBrowse(tooltip='Load an ascii file list of spectra or a single (fits, txt) spectrum')],
                [sg.Checkbox('I browsed a single spectrum', key='one_spec',tooltip='Check this if you want to load just one spectrum instead a text file containing the names of the spectra')],
                [sg.Text('Wavelength of the spectra is in:',tooltip='Set the correct wavelength units of your spectra: Angstrom, nm, mu', font = ('Helvetica', 14)), sg.Radio('nm', "RADIO2", default=True, key = 'wave_units_nm' ), sg.Radio('A', "RADIO2", key = 'wave_units_a'), sg.Radio('mu', "RADIO2" , key = 'wave_units_mu')],
                [sg.HorizontalSeparator()],
                [sg.Text('4. Finally load the spectra to SPAN', font = ('', 14 ,'bold'))],
                [sg.Button('Load!', font = ("Helvetica", 11, 'bold'),button_color=('black','light green'), size = (11,1)), sg.Push(), sg.Button('Plot',button_color=('black','light gray'), size = (10,1))],
                ], font=("Helvetica", 14, 'bold'), title_color = 'orange'), sg.Listbox(values = listbox1, size=(47, 22), key='-LIST-', horizontal_scroll=True, font=("Helvetica", 11) ),

                #Utility frame
                sg.Frame('Utilities', [
                [sg.Checkbox('Show the header of the selected spectrum',key = 'show_hdr',tooltip='Show fits header')],
                [sg.Checkbox('Show the wavelenght step of the spectrum', key = 'show_step',tooltip='Show spectrum wavelength step')],
                [sg.Checkbox('Estimate the resolution:', key = 'show_res',tooltip='Show resolution, by fitting a sky emission line within the wavelength 1(W1) and wavelength 2(W2) values'),sg.Text('W1'), sg.InputText('550', size = (4,1), key = 'lambda_res_left'), sg.Text('W2'), sg.InputText('565', size = (4,1), key = 'lambda_res_right')],
                [sg.HorizontalSeparator()],
                [sg.Checkbox('Convert the spectrum to:', key = 'convert_spec',tooltip='Convert one or all the spectra from fits to ASCII and viceversa'), sg.Radio('Text', "RADIOCONV", default = True, key = 'convert_to_txt'), sg.Radio('FITS', "RADIOCONV", key = 'convert_to_fits')],
                [sg.Checkbox('Compare with: ', key = 'compare_spec',tooltip='Compare the selected spectrum with any other loaded spectrum'), sg.InputText('Spec.', size = (7,1), key = 'spec_to_compare'), sg.FileBrowse(tooltip='Load the 1D spectrum (ASCII or fits)to use as comparison')],
                [sg.Checkbox('Convert Flux', key = 'convert_flux',tooltip='Convert the flux from Jansky to F_lambda and viceversa'), sg.Radio('Jy-->F_nu', "FLUX", default = True, key = 'convert_to_fnu'), sg.Radio('Jy-->F_l', "FLUX", key = 'convert_to_fl'),sg.Button('See plot',button_color=('black','light gray')) ],
                [sg.Checkbox('S/N:', key = 'show_snr',tooltip='Show the S/N of the selected spectrum centered on an user defined wavelength(W)'), sg.Text(' W.'), sg.InputText('645', size = (4,1), key = 'wave_snr'), sg.Text('+/-'), sg.InputText(3, size = (3,1), key = 'delta_wave_snr'), sg.Button('Save one',button_color=('black','light gray')), sg.Button('Save all',button_color=('black','light gray'))],
                [sg.HorizontalSeparator()],

                [sg.Text('Spectra manipulation panel:'),sg.Button('Spectra manipulation', size = (18,1),button_color= ('black','light blue'), tooltip='Open the spectra manipulation panel to modify the spectra')],
                [sg.HorizontalSeparator()],
                [sg.Text('Tools:'), sg.Push(), sg.Button('Text editor', tooltip='Stand alone simple text editor',button_color= ('black','light blue')),sg.Button('FITS header editor', tooltip='Stand alone FITS header editor',button_color= ('black','light blue')), sg.Button('Plot data', tooltip='Stand alone data plotter. ASCII files with spaced rows',button_color= ('black','light blue'))],
                [sg.Text('',font=("Helvetica", 5))],
                ], font=("Helvetica", 15, 'bold')),


                #Buttons to perform the utility actions
                sg.Frame('Utility Actions',[
                [sg.Text('')],
                [sg.Button('Show info',button_color=('black','light gray'), size = (11,1))],
                [sg.Text('')],
                [sg.HorizontalSeparator()],
                [sg.Button('One',button_color=('black','light gray'), size = (4,1)), sg.Button('All',button_color=('black','light gray'), size = (4,1))],
                [sg.Button('Compare',button_color=('black','light gray'), size = (11,1))],
                [sg.Button('One',button_color=('black','light gray'), size = (4,1), key ='convert_one'), sg.Button('All',button_color=('black','light gray'), size = (4,1), key = 'convert_all')],
                [sg.Button('Show snr',button_color=('black','light gray'), size = (11,1))],
                [sg.HorizontalSeparator()],
                [sg.Button('Preview spec.',button_color=('black','light gray'), size = (11,1), font=("Helvetica", 14, 'bold'),tooltip='View the modified version of the selected spectrum')],
                [sg.HorizontalSeparator()],
                [sg.Text('')],
                [sg.Text('',font=("Helvetica", 8))],
                ] ,font=("Helvetica", 10, 'bold'))],
                [sg.HorizontalSeparator()],
                [sg.Text('',font=("Helvetica", 1))],
                [sg.HorizontalSeparator()],

                #Spectral analysis frame
                [sg.Frame('Spectral analysis', [

                #1) Black-body fitting
                [sg.Checkbox('Planck Blackbody fitting ', font = ('Helvetica', 16, 'bold'), key = 'bb_fitting',tooltip='Blackdoby Planck function fitting. Works fine for stellar spectra and wide wavelength range'), sg.Text('    '), sg.Button('Blackbody parameters',button_color= ('black','light blue'), size = (22,1)), sg.Text('          '), sg.Checkbox('Cross-correlation', font = ('Helvetica', 16, 'bold'), key = 'xcorr',tooltip='Cross-correlating a band with a template. Works better with continuum normalisation. Use Kinematics for more accurate results'),sg.Push(), sg.Button('Cross-corr parameters',button_color= ('black','light blue'), size = (22,1))],

                #2) Velocity dispersion measurement
                [sg.Checkbox('Velocity dispersion   ', font = ('Helvetica', 16, 'bold'), key = 'sigma_measurement',tooltip='Fitting a band with a template. Rough but fast. Use Kinematics for accurate science results'),sg.Text('              '), sg.Button('Sigma parameters',button_color= ('black','light blue'), size = (22,1)), sg.Text('          '), sg.Checkbox('Line(s) fitting', font = ('Helvetica', 16, 'bold'), key = 'line_fitting',tooltip='User line or automatic CaT band fitting with gaussian functions'),sg.Push(), sg.Button('Line fitting parameters',button_color= ('black','light blue'), size = (22,1))],

                #3) Line-strength
                [sg.Checkbox('Line-strength analysis  ', font = ('Helvetica', 16, 'bold'), key = 'ew_measurement',tooltip='Equivalent width measurement for a list of indices, a single user defined index and Lick/IDS indices'), sg.Text('        '), sg.Button('Line-strength parameters',button_color= ('black','light blue'), size = (22,1)), sg.Text('          '),sg.Checkbox('Kinematics', font = ('Helvetica', 16, 'bold'), key = 'ppxf_kin',tooltip='Perform the fitting of a spectral region and gives the kinematics'),sg.Push(), sg.Button('Kinematics parameters',button_color= ('black','light blue'), size = (22,1))  ],

                #4) Stellar populations with ppxf
                [sg.Checkbox('Stellar populations and SFH  ', font = ('Helvetica', 16, 'bold'), key = 'ppxf_pop',tooltip='Perform the fitting of a spectral region and gives the properties of the stellar populations'), sg.Button('Population parameters',button_color= ('black','light blue'), size = (22,1))  ],
                ], font=("Helvetica", 14, 'bold'), title_color='yellow'),

                # Buttons to perform the spectral analysis actions
                sg.Frame('An. Actions',[
                [sg.Button('Help me',button_color=('black','orange'), size = (12,1))],
                [sg.Text('')],
                [sg.Button('Preview result',button_color=('black','light gray'),tooltip='Preview all the results of the Spectral analysis frame', size = (12,1), font=("Helvetica", 14, 'bold'))],

                ],font=("Helvetica", 14, 'bold')),


                ],
                [sg.HorizontalSeparator()],

                #General buttons at the end of the panel
                [sg.Button('Process selected', button_color=('white','orange'), size=(15, 1),tooltip='Process the selected spectrum by performing all the enabled tasks'), sg.Button('Process all', button_color=('white','red'), size=(15, 1), tooltip='Process all the loaded spectra by performing all the enabled tasks'), sg.Checkbox('Save intermediate files, if any', default = True, text_color = 'lightgreen', key = 'save_intermediate_files', tooltip='Check this if you want to save all the spectra for any of the tasks selected', font = ('bold')), sg.Checkbox('Save plots', default = False, text_color='yellow', key = 'save_plots', tooltip='To save all the plots generated by the Spectral Analysis tasks activated and the Process All method', font = ("Helvetica", 14, 'bold')), sg.Push(), sg.Exit(size=(15, 1),tooltip='See you soon!')]

                    ]


    #************************************************************************************
    #Layout optimized for Android systems

    #Building the main panel#
    layout_android = [

                [sg.Frame('Prepare and load spectra', [
                [sg.Text('1. Extract 1D spectra and/or generate a spectra list', font = ('Helvetica', 11, 'bold'))],
                [sg.Button('Long-slit extraction', tooltip='Stand alone program to extract 1D spectra from 2D fits',button_color= ('black','light blue'), size=(13, 1)), sg.Button('DataCube extraction', tooltip='Stand alone program to extract 1D spectra from data cubes',button_color= ('black','light blue'), size=(11, 1)), sg.Button('Gen. spectra list', key = 'listfile',tooltip='If you do not have a spectra file list, you can generate here', size=(14, 1))],
                [sg.Text('', font = ("Helvetica", 1))],
                [sg.Text('2. Browse the spectra list or just one spectrum', font = ('Helvetica', 11, 'bold'))],
                [sg.InputText(default_spectra_list, size=(21, 1), key='spec_list' ), sg.FileBrowse(tooltip='Load an ascii file list of spectra or a single (fits, txt) spectrum'), sg.Checkbox('It is a spectrum', font = ('Helvetica', 10, 'bold'), key='one_spec',tooltip='Check this if you want to load just one spectrum instead a text file containing the names of the spectra')],
                [sg.Text('W. scale:',tooltip='Set the correct wavelength units of your spectra: Angstrom, nm, mu'), sg.Radio('nm', "RADIO2", default=True, key = 'wave_units_nm' ), sg.Radio('A', "RADIO2", key = 'wave_units_a'), sg.Radio('mu', "RADIO2" , key = 'wave_units_mu'), sg.Push(), sg.Button('Load!', font = ('Helvetica', 11, 'bold'),button_color=('black','light green'), size = (6,1)), sg.Button('Plot',button_color=('black','light gray'), size = (4,1))],
                ], font=("Helvetica", 14, 'bold'), title_color = 'orange'), sg.Listbox(values = listbox1, size=(47, 10), key='-LIST-', horizontal_scroll=True),

                #Utility frame
                sg.Frame('Utilities', [
                [sg.Checkbox('HDR', font = ('Helvetica', 10, 'bold'), key = 'show_hdr',tooltip='Show fits header'), sg.Checkbox('Step', font = ('Helvetica', 10, 'bold'), key = 'show_step',tooltip='Show spectrum wavelength step'), sg.Checkbox('Res.:', font = ('Helvetica', 10, 'bold'), key = 'show_res',tooltip='Show resolution, by fitting a sky emission line within the wavelength 1(W1) and wavelength 2(W2) values'),sg.Text('W1'), sg.InputText('550', size = (4,1), key = 'lambda_res_left'), sg.Text('W2'), sg.InputText('565', size = (4,1), key = 'lambda_res_right')],
                [ sg.Checkbox('Convert spectrum to:', font = ('Helvetica', 10, 'bold'), key = 'convert_spec',tooltip='Convert one or all the spectra from fits to ASCII and viceversa'), sg.Radio('Text', "RADIOCONV", default = True, key = 'convert_to_txt'), sg.Radio('FITS', "RADIOCONV", key = 'convert_to_fits')],
                [sg.Checkbox('Compare with: ', font = ('Helvetica', 10, 'bold'), key = 'compare_spec',tooltip='Compare the selected spectrum with any other loaded spectrum'), sg.InputText('Spec.', size = (7,1), key = 'spec_to_compare'), sg.FileBrowse(tooltip='Load the 1D spectrum (ASCII or fits)to use as comparison')],
                [sg.Checkbox('Convert Flux', font = ('Helvetica', 10, 'bold'), key = 'convert_flux',tooltip='Convert the flux from Jansky to F_lambda and viceversa'), sg.Radio('Jy-->F_nu', "FLUX", default = True, key = 'convert_to_fnu'), sg.Radio('Jy-->F_l', "FLUX", key = 'convert_to_fl'),sg.Button('See plot',button_color=('black','light gray')) ],
                [sg.Checkbox('S/N:', font = ('Helvetica', 10, 'bold'), key = 'show_snr',tooltip='Show the S/N of the selected spectrum centered on an user defined wavelength(W)'), sg.Text(' W.'), sg.InputText('645', size = (4,1), key = 'wave_snr'), sg.Text('+/-'), sg.InputText(3, size = (3,1), key = 'delta_wave_snr'), sg.Button('Save one',button_color=('black','light gray')), sg.Button('Save all',button_color=('black','light gray'))]  ], font=("Helvetica", 12, 'bold')),

                #Buttons to perform the utility actions
                sg.Frame('Utility Actions',[
                [sg.Button('Show info',button_color=('black','light gray'), size = (10,1))],
                [sg.Button('One',button_color=('black','light gray'), size = (3,1)), sg.Button('All',button_color=('black','light gray'), size = (3,1))],
                [sg.Button('Compare',button_color=('black','light gray'), size = (10,1))],
                [sg.Button('One',button_color=('black','light gray'), size = (3,1), key ='convert_one'), sg.Button('All',button_color=('black','light gray'), size = (3,1), key = 'convert_all')],
                [sg.Button('Show snr',button_color=('black','light gray'), size = (10,1))],
                ] ,font=("Helvetica", 10, 'bold'))],
                [sg.HorizontalSeparator()],


                [sg.Frame('Spectral analysis', [

                #1) Black-body fitting
                [sg.Checkbox('Planck Blackbody fitting', font = ('Helvetica', 12, 'bold'), key = 'bb_fitting',tooltip='Blackdoby Planck function fitting. Works fine for stellar spectra and wide wavelength range'),sg.Push(), sg.Button('Blackbody parameters',button_color= ('black','light blue'), size = (22,1))],

                #2) Cross-correlation
                [sg.Checkbox('Cross-correlation', font = ('Helvetica', 12, 'bold'), key = 'xcorr',tooltip='Cross-correlating a band with a template. Works better with continuum normalisation. Use Kinematics for more accurate results'),sg.Push(), sg.Button('Cross-corr parameters',button_color= ('black','light blue'), size = (22,1))],

                #3) Velocity disperion measurement
                [sg.Checkbox('Velocity dispersion', font = ('Helvetica', 12, 'bold'), key = 'sigma_measurement',tooltip='Fitting a band with a template. Rough but fast. Use Kinematics for accurate science results'),sg.Push(), sg.Button('Sigma parameters',button_color= ('black','light blue'), size = (22,1))],

                #4) Line-strength
                [sg.Checkbox('Line-strength analysis', font = ('Helvetica', 12, 'bold'), key = 'ew_measurement',tooltip='Equivalent width measurement for a list of indices, a single user defined index and Lick/IDS indices'),sg.Push(), sg.Button('Line-strength parameters',button_color= ('black','light blue'), size = (22,1))],

                #5) Line fitting
                [sg.Checkbox('Line(s) fitting', font = ('Helvetica', 12, 'bold'), key = 'line_fitting',tooltip='User line or automatic CaT band fitting with gaussian functions'),sg.Push(), sg.Button('Line fitting parameters',button_color= ('black','light blue'), size = (22,1))],

                #6) Kinematics with ppxf
                [sg.Checkbox('Stars and gas kinematics', font = ('Helvetica', 12, 'bold'), key = 'ppxf_kin',tooltip='Perform the fitting of a spectral region and gives the kinematics'),sg.Push(), sg.Button('Kinematics parameters',button_color= ('black','light blue'), size = (22,1))  ],

                #7) Stellar populations with ppxf
                [sg.Checkbox('Stellar populations and SFH', font = ('Helvetica', 12, 'bold'), key = 'ppxf_pop',tooltip='Perform the fitting of a spectral region and gives the properties of the stellar populations'),sg.Push(), sg.Button('Population parameters',button_color= ('black','light blue'), size = (22,1))  ],
                ], font=("Helvetica", 14, 'bold'), title_color='yellow'),

                # Buttons to open the spectral manipulation panel and perform the spectral analysis actions
                sg.Frame('Actions',[
                [sg.Button('Spectra manipulation', size = (12,2),button_color= ('black','light blue'), font=("Helvetica", 10, 'bold'), tooltip='Open the spectra manipulation panel to modify the spectra', key = 'Spectra manipulation')],
                [sg.Button('Preview spec.',button_color=('black','light gray'), size = (12,2), font=("Helvetica", 10, 'bold'),tooltip='View the modified version of the selected spectrum')],
                [sg.Text('', font = ('Helvetica',1))],
                [sg.HorizontalSeparator()],
                [sg.Text('', font = ('Helvetica',1))],
                [sg.Button('Preview result',button_color=('black','light gray'),tooltip='Preview the results of the Spectral analysis frame', size = (12,2), font=("Helvetica", 10, 'bold'))],
                [sg.Text('')],
                [sg.Button('Help me',button_color=('black','orange'), size = (12,1),tooltip='Getting help for the spectral analysis')],

                ],font=("Helvetica", 9, 'bold')),

                #COMMENT THE FOLLOWING THREE LINES TO HAVE THE EXTERNAL OUTPUT
                sg.Frame('Output', [
                [sg.Output(size=(80, 14), key='-OUTPUT-' , font=('Helvetica', 11))],
                ] ,font=("Helvetica", 12, 'bold')),

                ],

                #General buttons at the end of the panel
                [sg.Push(), sg.Button('Change result folder...', button_color=('black','light blue')), sg.Button('Save parameters...', button_color=('black','light blue'), tooltip='Save the current parameters in a json file'), sg.Button('Load parameters...', button_color=('black','light blue'), tooltip='Load the saved parameters'), sg.Button('Restore default parameters', button_color=('black','light blue'), tooltip='Restore the default parameters'), sg.Button('Clear all tasks', button_color=('black','light blue'), tooltip='De-activate all the tasks, including from the spectral manipulation panel'), sg.Button('Clean output', button_color=('black','light blue'), tooltip='Delete the output window'), sg.Button('Read me', button_color=('black','orange'), tooltip='Open the SPAN readme'), sg.Button('Quick start', button_color=('black','orange'), tooltip='A fast guide to begin using SPAN'), sg.Button('Tips and tricks', button_color=('black','orange'), tooltip='Some tricks to master SPAN')],

                [sg.Button('Process selected', button_color=('white','orange'), size=(15, 1),tooltip='Process the selected spectrum by performing all the enabled tasks'), sg.Button('Process all', button_color=('white','red'), size=(15, 1), tooltip='Process all the loaded spectra by performing all the enabled tasks'), sg.Checkbox('Save intermediate files, if any', default = True, text_color = 'lightgreen', key = 'save_intermediate_files', tooltip='Check this if you want to save all the spectra for any of the tasks selected', font = ('Helvetica', 10, 'bold')), sg.Checkbox('Save plots', default = False, text_color='yellow', key = 'save_plots', tooltip='To save all the plots generated by the Spectral Analysis tasks activated and the Process All method', font = ("Helvetica", 10, 'bold')), sg.Push(),sg.Button('Text editor', tooltip='Stand alone simple text editor',button_color= ('black','light blue')),sg.Button('FITS header editor', tooltip='Stand alone FITS header editor',button_color= ('black','light blue')), sg.Button('Plot data', tooltip='Stand alone data plotter. ASCII files with spaced rows',button_color= ('black','light blue')), sg.Push(), sg.Exit(size=(15, 1),tooltip='See you soon!')]

                    ]


    #************************************************************************************
    #Function to recognize the operating system
    def get_layout():
        current_os = os.name  # 'posix' for Linux/Mac, 'nt' for Windows
        if current_os == "nt":
            #for discarding the scaling factor of Windows
            import ctypes
            ctypes.windll.shcore.SetProcessDpiAwareness(1)

            scale_win = 1.5
            fontsize = sg.set_options(font=("Helvetica", 11))
            default_size = 11
            return layout_windows, scale_win, fontsize, default_size
        elif current_os == "posix":
            # Further check between Linux e macOS
            if "ANDROID_BOOTLOGO" in os.environ:  # Check for Android
                scale_win = 2.25
                fontsize = sg.set_options(font=("Helvetica", 10))
                default_size = 10
                return layout_android, scale_win, fontsize, default_size
            elif os.uname().sysname == "Darwin":  # Check for macOS
                scale_win = 1
                fontsize = sg.set_options(font=("Helvetica", 14))
                default_size = 14
                return layout_macos, scale_win, fontsize, default_size
            else:  # Linux
                scale_win = 1.5
                fontsize = sg.set_options(font=("Helvetica", 10))
                default_size = 10
                return layout_linux, scale_win, fontsize, default_size
        else:
            print ("Operating system not recognized. Using Linux layout") # In case the system is not recognized, using the Linux layout
            scale_win = 1.5
            fontsize = sg.set_options(font=("Helvetica", 10))
            return layout_linux, scale_win, fontsize, default_size
            #exit()



    # Loading the correct layout
    layout, scale_win, fontsize, default_size = get_layout()

    #Creating the main GUI
    window1 = sg.Window('SPAN - SPectral ANalysis - 6.3 --- Daniele Gasparri ---', layout,finalize=True, scaling = scale_win)


    keys = []
    events = []
    values = {}

    ############# Initialization of the variables needed to succesfully open the panel ###########
    #necessary to set the existence conditions of the spectra loaded
    spec_names = np.zeros(5)





    #Function to check is the spectralTemplates folder is available
    SPECTRAL_TEMPLATES_DIR = os.path.join(BASE_DIR, "spectralTemplates")

    # Link to my website to download the spectralTemplates folder
    DOWNLOAD_URL = "https://www.danielegasparri.com/spectralTemplates.zip"

    # Temporary path to save the zipped file
    TEMP_ZIP_PATH = os.path.join(BASE_DIR, "spectralTemplates.zip")


    def download_and_extract_files():
        """DOwnload the zip file, esxtratc and put in the span/ folder"""
        try:
            # download
            sg.popup("Downloading spectral templates... Please wait.", title="SPAN Download", keep_on_top=True)
            urllib.request.urlretrieve(DOWNLOAD_URL, TEMP_ZIP_PATH)

            # extract
            with zipfile.ZipFile(TEMP_ZIP_PATH, "r") as zip_ref:
                zip_ref.extractall(BASE_DIR)

            # deleting the zip file
            os.remove(TEMP_ZIP_PATH)

            # congratulation!
            sg.popup("Download completed! SPAN is now ready to use.", title="SPAN Success", keep_on_top=True)

        except Exception as e:
            sg.popup_error(f"Error downloading auxiliary files:\n{str(e)}", title="SPAN Error", keep_on_top=True)


    def check_and_download_spectral_templates():
        """Checking if the spectralTemplates/ exists."""
        if not os.path.exists(SPECTRAL_TEMPLATES_DIR):
            # If spectralTemplates does not exist, I should download it, if the user agrees
            choice = sg.popup_yes_no(
                "SPAN must download an extract the spectralTemplates folder to work properly. Do you want to continue? Estimated size = 330MB. This might take a while...\n \nYou can also download the folder here: https://www.danielegasparri.com/spectralTemplates.zip , unzip the folder and put in the root folder of span",
                title="SPAN Missing Files",
                keep_on_top=True
            )

            if choice == "Yes":
                download_and_extract_files()
            else:
                sg.popup(
                    "Without the required files, SPAN functionalities are limited, but you can still perform some tasks.",
                    title="SPAN Warning",
                    keep_on_top=True
                )


    # calling the function to check
    check_and_download_spectral_templates()



    #Functions to check, select and change the result folder
    # Config file
    config_file = os.path.join(BASE_DIR, "system_files", "config.json")

    def save_config_folder(data):
        """Save the result path to a JSON file."""
        with open(config_file, 'w') as f:
            json.dump(data, f)

    def load_config():
        """ Load the result path folder from the JSON file."""
        if os.path.exists(config_file):
            with open(config_file, 'r') as f:
                return json.load(f)
        return {}

    def ask_user_for_result_path():
        """Ask user to select a folder to store the results of SPAN."""
        sg.theme('LightBlue')
        layout = [
            [sg.Text("Select the path to store the SPAN_results folder:")],
            [sg.InputText(), sg.FolderBrowse()],
            [sg.Button("Confirm"), sg.Button("Cancel")]
        ]
        window = sg.Window("Select folder", layout)

        while True:
            event, values = window.read()
            if event in (sg.WINDOW_CLOSED, "Cancel"):
                window.close()
                return None
            if event == "Confirm" and values[0]:
                window.close()
                return values[0]
            sg.popup("Please, select a valid path")

    def create_result_structure(base_path):
        """Creating the directory structure"""
        result_data = os.path.join(base_path, 'SPAN_results')
        subdirectories = [
            'spec', 'SNR', 'black_body', 'xcorr', 'vel_disp',
            'ew', 'line_fitting', 'ppxf_kin', 'ppxf_pop',
            'sigma_coeff', 'plots'
        ]
        os.makedirs(result_data, exist_ok=True)
        for subdir in subdirectories:
            os.makedirs(os.path.join(result_data, subdir), exist_ok=True)
        return result_data

    def change_result_path(config_folder):
        """Function to allow the user to change the result directory directly in the GUI"""
        new_path = ask_user_for_result_path()
        if new_path:
            config_folder["result_path"] = new_path
            save_config_folder(config_folder)
            create_result_structure(new_path)  # Assicura che la struttura sia ricreata
            sg.popup(f"The new SPAN-result folder now is in: {new_path}")
        else:
            sg.popup("Path of the SPAN_result folder has not changed")


    #Checking if the result folder exist. If not, the user can select the path where to create it.
    config_folder = load_config()
    if "result_path" not in config_folder or not os.path.exists(config_folder["result_path"]):
        # Ask the user to select a path if is missing from the JSON config file.
        result_path = ask_user_for_result_path()
        if result_path:
            config_folder["result_path"] = result_path
            save_config_folder(config_folder)
        else:
            sg.popup("No path selected, the program will close")
            exit()

    # Verifying and creating the directory structure
    result_path = config_folder["result_path"]
    result_data = create_result_structure(result_path)
    # sg.popup(f"The results of SPAN will be stored in: {result_data}")

    #creating the result subdirectories
    result_spec_dir = result_data+'/spec'
    result_spec = result_spec_dir+'/'
    result_snr_dir = result_data+'/SNR'
    result_bb_dir = result_data+'/black_body'
    result_xcorr_dir = result_data+'/xcorr'
    result_vel_disp_dir = result_data+'/vel_disp'
    result_ew_data_dir = result_data+'/ew'
    result_line_fitting_dir = result_data+'/line_fitting'
    result_ppxf_kin_data_dir = result_data+'/ppxf_kin'
    result_ppxf_pop_data_dir = result_data+'/ppxf_pop'
    result_sigma_coeff_dir = result_data+'/sigma_coeff'
    result_plot_dir = result_data+'/plots'
    result_long_slit_extract = result_data+'/longslit_extracted'

    ########## SETTING UP THE DEFAULT PARAMETERS FOR THE TASKS ###################
    current_order = None
    reorder_op = False

    #DYNAMIC CLEANING PARAMETERS
    clip_factor = 2.5
    sigma_clip_resolution = 1600
    sigma_clip_single_vel = True
    sigma_clip_single_value = 30
    sigma_clip_have_file = False
    sigma_clip_sigma_file = os.path.join(BASE_DIR, "example_files", "txt_sample_files", "sigma_clip_data.dat")

    #DENOISING PARAMETERS
    moving_average = True
    box_moving_avg = True
    box_moving_avg_size = 11
    gauss_moving_avg = False
    gauss_moving_avg_kernel = 5
    low_pass_filter = False
    lowpass_cut_off = 0.1
    lowpass_order = 4
    bandpass_filter = False
    bandpass_lower_cut_off = 0.1
    bandpass_upper_cut_off = 0.5
    bandpass_order = 4

    #DOPCOR DEFAULT PARAMETERS
    dop_cor_single_shot_vel = 0
    dop_cor_have_file = False
    dop_cor_file = os.path.join(BASE_DIR, "example_files", "txt_sample_files", "dopcor_file.dat")
    dop_cor_single_shot = True
    dop_cor_have_vel = True
    dop_cor_have_z = False

    #HELIOCOR DEFAULT PARAMETERS
    helio_have_file = False
    helio_file = os.path.join(BASE_DIR, "example_files", "txt_sample_files", "file_helio.dat")
    helio_single_shot = True
    helio_single_shot_location = 'Paranal'
    helio_single_shot_date = '2016-6-4'
    ra_obj = 4.88375
    dec_obj = 35.0436389

    #DEGRADE RESOLUTION PARAMETERS
    is_initial_res_r = True
    initial_res_r = 1600
    res_degrade_to_r = True
    final_res_r = 600
    res_degrade_to_fwhm = False
    final_res_r_to_fwhm = 8.4
    is_initial_res_fwhm = False
    initial_res_fwhm = 2.51
    final_res_fwhm = 8.4

    #CONTINUUM SUBTRACTION PARAMETERS
    markers_cont_operations = ['subtract', 'divide']
    cont_math_operation = markers_cont_operations[0]
    cont_model_filtering = True
    cont_model_poly = False
    cont_want_to_maks = False
    cont_mask_ranges_str = '[(655, 666), (485, 490),(585, 595)]'
    cont_mask_ranges = eval(cont_mask_ranges_str)
    cont_poly_degree = 5

    #BLACKBODY DEFAULT PARAMETERS
    wave1_bb = 600.
    wave2_bb = 900.
    t_guess = 4000.

    #CROSS-CORRELATION DEFAULT PARAMETERS
    lambda_units_template_crosscorr = 'a'
    smooth_template_crosscorr = False
    smooth_value_crosscorr = 0.
    low_wave_corr = 840.
    high_wave_corr = 880.
    is_vel_xcorr = True
    is_z_xcorr= False
    low_vel_corr = -1000
    high_vel_corr = 1000
    lambda_units_template_crosscorr_nm = False
    lambda_units_template_crosscorr_a = True
    lambda_units_template_crosscorr_mu = False
    wave_interval_corr = np.array([low_wave_corr,high_wave_corr])
    real_low_wave_corr = np.min(wave_interval_corr)
    real_high_wave_corr = np.max(wave_interval_corr)
    vel_interval_corr = np.array([low_vel_corr,high_vel_corr])
    low_z_corr = 0
    high_z_corr = 0.1
    z_interval_corr = np.array([low_z_corr,high_z_corr])
    template_crosscorr = os.path.join(BASE_DIR, "example_files", "templates", "template_emiles.dat")

    #SIGMA VEL DEFAULT PARAMETERS
    lambda_units_template_sigma = 'a'
    lambda_units_template_sigma_nm = False
    lambda_units_template_sigma_a = True
    lambda_units_template_sigma_mu = False
    band_cat = True
    band_halpha = False
    band_nad = False
    band_h = False
    band_k = False
    band_custom = False
    resolution_spec = 5000
    resolution_template = 0
    low_wave_sigma = 840
    high_wave_sigma = 890
    low_wave_cont = 856
    high_wave_cont = 864
    band_sigma = np.array([844., 872.])
    cont_sigma = np.array([856.,864.])
    template_sigma = os.path.join(BASE_DIR, "example_files", "templates", "emiles_template_extended_younger.dat")

    #EW DEFAULT VALUES
    index_file = os.path.join(BASE_DIR, "example_files", "index_list_sample.txt")
    have_index_file = False
    single_index = False
    idx_left_blue = 847.4
    idx_right_blue = 848.4
    idx_left_red = 856.3
    idx_right_red = 857.7
    idx_left_line = 848.4
    idx_right_line = 851.3
    index_usr = np.array([idx_left_blue, idx_right_blue, idx_left_red, idx_right_red, idx_left_line, idx_right_line]).T

    # FOR LICK/IDS INDEX MEASUREMENTS
    lick_ew = True
    lick_constant_fwhm = True
    spec_lick_res_fwhm = 3.5
    lick_constant_r = False
    spec_lick_res_r = 5000
    radio_lick_sigma_single = False
    radio_lick_sigma_list = False
    radio_lick_sigma_auto = True
    sigma_lick_file = os.path.join(BASE_DIR, "example_files", "results", "sigma_data_ngc5806_bins_new.dat")
    sigma_single_lick = 100
    correct_ew_sigma = True
    sigma_lick_coeff_file = os.path.join(BASE_DIR, "system_files", "sigma_coeff_lick.dat")
    lick_index_file = os.path.join(BASE_DIR, "system_files", "lick_indices.dat")
    lick_correct_emission = True
    z_guess_lick_emission = 0.
    lick_ssp_models = ['Thomas2010', 'xshooter', 'miles', 'smiles']
    ssp_model = lick_ssp_models[0]
    interp_modes = ['griddata', 'GPR']
    interp_model = interp_modes[1]
    stellar_parameters_lick = True
    dop_correction_lick = True
    stellar_library_lick = 'emiles'

    #FIT LINES DEFAULT VALUES
    emission_line = False
    low_wave_fit = 845
    high_wave_fit = 870
    y0 = 1
    x0 = 850
    a = -0.8
    sigma = 0.5
    m = 0.1
    c = 1
    cat_band_fit = True
    usr_fit_line = False
    wave_interval_fit = np.array([low_wave_fit,high_wave_fit])
    guess_param = [y0,x0,a,sigma,m,c]
    real_cat1 = 849.8
    real_cat2 = 854.2
    real_cat3 = 866.2
    index_ca1 = [847.4,848.4,856.3,857.7,848.4,851.3]
    index_ca2 = [847.4,848.4,856.3,857.7,852.2,856.2]
    index_ca3 = [861.9,864.2,870,872.5,864.2,868.2]

    #PPXF KINEMATICS DEFAULT PARAMETERS
    wave1_kin = 480
    wave2_kin = 550
    resolution_kin = 3.5
    resolution_kin_r = 1600
    sigma_guess_kin = 100
    redshift_guess_kin = 0
    constant_resolution_lambda = True
    constant_resolution_r = False
    markers_ppxf_kin = ['emiles', 'galaxev', 'fsps', 'xshooter']
    stellar_library_kin = markers_ppxf_kin[0]
    additive_degree_kin = 4
    kin_moments = 4
    gas_kin = False
    no_gas_kin = True
    ppxf_kin_noise = 0.0163
    kin_best_noise = False
    with_errors_kin = False
    ppxf_kin_preloaded_lib = True
    ppxf_kin_custom_lib = False
    ppxf_kin_lib_folder = os.path.join(BASE_DIR, "spectralTemplates", "EMILES_BASTI_BASE_KU_FITS")
    ppxf_kin_custom_temp_suffix = 'Eku1.30*.fits'
    ppxf_kin_tie_balmer = False
    ppxf_kin_dust_stars = False
    ppxf_kin_dust_gas = False
    ppxf_kin_two_stellar_components = False
    ppxf_kin_age_model1 = 2
    ppxf_kin_met_model1 = 0
    ppxf_kin_age_model2 = 12
    ppxf_kin_met_model2 = 0
    ppxf_kin_vel_model1 = 200
    ppxf_kin_sigma_model1 = 200
    ppxf_kin_vel_model2 = 0
    ppxf_kin_sigma_model2 = 50
    ppxf_kin_mask_emission = True
    ppxf_kin_mc_sim = 20


    #PPXF STELLAR POPULATION PARAMETERS
    pop_with_gas = True
    pop_without_gas = False
    wave1_pop = 480
    wave2_pop = 550
    res_pop = 3.5
    z_pop = 0
    sigma_guess_pop = 100
    fit_components = ('with_gas')
    with_errors = False
    regul_err = 0.02
    additive_degree = -1
    multiplicative_degree = 7
    ppxf_pop_tie_balmer = False
    markers_ppxf = ['emiles', 'galaxev', 'fsps', 'xshooter', 'sMILES']
    stellar_library = markers_ppxf[0]
    ppxf_pop_noise = 0.0163
    ppxf_min_age = 0.
    ppxf_max_age = 16.
    ppxf_min_met = -2.5
    ppxf_max_met = 0.8
    age_range_array = np.array([ppxf_min_age, ppxf_max_age])
    met_range_array = np.array([ppxf_min_met, ppxf_max_met])
    ppxf_pop_preloaded_lib = True
    ppxf_pop_custom_lib = False
    ppxf_pop_lib_folder = os.path.join(BASE_DIR, "spectralTemplates", "EMILES_BASTI_BASE_KU_FITS")
    ppxf_pop_custom_npz = False
    ppxf_pop_npz_file = os.path.join(BASE_DIR, "spectralTemplates", "spectra_emiles_9.0.npz")
    ppxf_pop_mask = False
    ppxf_custom_temp_suffix = 'Eku1.30*.fits'
    ppxf_best_param = False
    ppxf_best_noise_estimate = False
    ppxf_frac_chi = 0.30
    ppxf_pop_convolve = False
    ppxf_pop_dust_stars = False
    ppxf_pop_dust_gas = False
    ppxf_pop_want_to_mask = False
    ppxf_pop_mask_ranges_str = '[(518, 521)]'
    ppxf_pop_mask_ranges_str_default = ppxf_pop_mask_ranges_str
    ppxf_pop_mask_ranges = eval(ppxf_pop_mask_ranges_str)
    ppxf_pop_mask_ranges_default = ppxf_pop_mask_ranges
    ppxf_pop_error_nsim = 20
    ppxf_pop_lg_age = True
    stellar_parameters_lick_ppxf = False
    lick_ssp_models_ppxf = ['Thomas2010', 'xshooter', 'miles', 'smiles']
    ssp_model_ppxf = lick_ssp_models[3]
    interp_modes_ppxf = ['griddata', 'GPR']
    interp_model_ppxf = interp_modes[1]

    #SIGMA COEFF PARAMETERS
    sigma_coeff = False
    stellar_spectra_coeff_file = os.path.join(BASE_DIR, "example_files", "sample_templates.txt")
    lambda_units_coeff_nm = False
    lambda_units_coeff_a = True
    lambda_units_coeff_mu = False
    lambda_units_coeff = 'a'
    smooth_stellar_sample = False
    smooth_value_sample = 0
    same_idx_ew_task = True
    have_index_file_corr = True
    index_file_corr = os.path.join(BASE_DIR, "example_files", "index_list_sample.txt")
    single_index_corr = False
    idx_left_blue_sigma = 847.4
    idx_right_blue_sigma = 848.4
    idx_left_red_sigma = 856.3
    idx_right_red_sigma = 857.7
    idx_left_line_sigma = 848.4
    idx_right_line_sigma = 851.3

    #SIGMA CORR DEFAULT PARAMETERS
    sigma_corr = False
    sigma_vel_file = os.path.join(BASE_DIR, "example_files", "results", "sigma_data.dat")
    ew_list_file = os.path.join(BASE_DIR, "example_files", "results", "ew_data.dat")
    sigma_coeff_file = os.path.join(BASE_DIR, "example_files", "results", "sigma_coeff.dat")

    #2D LONG-SLIT EXTRACTION DEFAULT PARAMETERS
    file_path_spec_extr = os.path.join(BASE_DIR, "example_files", "spectra/NGC5806_image.fits")
    trace_y_range_str = "(300, 600)"
    poly_degree_str = "1"
    extract_y_range_str = "(300, 600)"
    snr_threshold_str = "20"
    pixel_scale_str = "0.252"

    #CUBE EXTRACTION DEFAULT PARAMETERS
    ifs_run_id = 'test'
    ifs_input = ''
    ifs_output = result_data +'/'#'.'
    ifs_redshift = 0.008764
    ifs_parallel = False
    ifs_ncpu = 1
    ifs_lfs_data_default = 'None'
    ifs_template = 'None' #'lsf_MILES'
    ifs_ow_config = False
    ifs_ow_output = False
    ifs_routine_read = ['MUSE_WFM', 'MUSE_WFMAOE', 'MUSE_WFMAON', 'MUSE_NFM', 'MUSE_NFMAO', 'CALIFA_V500', 'CALIFA_V1200']
    ifs_routine_read_default = 'MUSE_WFM'
    ifs_debug = False
    ifs_origin = '14,14'
    ifs_lmin_tot = 480
    ifs_lmax_tot = 550
    ifs_lmin_snr_default = 480
    ifs_lmax_snr_default = 550
    ifs_mask_method = 'default'
    ifs_min_snr_mask = 0
    ifs_mask = 'none'
    ifs_bin_method = 'voronoi'
    ifs_target_snr = 50
    ifs_covariance = 0
    ifs_prepare_method = 'default'
    ifs_preloaded_routine = True
    ifs_user_routine = False
    ifs_user_routine_file = 'MUSE_WFM'
    ifs_manual_bin = False
    ifs_voronoi = True

    #PARAMETERS IN THE SPECTRA MANIPULATION PANEL
    # Spectra pre-processing default parameters
    cropping_spectrum = False
    cropping_low_wave = 480
    cropping_high_wave = 550
    sigma_clipping = False
    wavelet_cleaning = False
    sigma_wavelets = 0.02
    wavelets_layers = 3
    filter_denoise = False
    dop_cor = False
    helio_corr = False

    # Spectra processing frame default parameters
    rebinning = False
    rebinning_log = False
    rebinning_linear = True
    rebin_step_pix = 0.02
    rebin_step_sigma = 60
    degrade = False
    normalize_wave = False
    norm_wave = 500
    sigma_broad = False
    sigma_to_add = 0
    add_noise = False
    noise_to_add = 10
    continuum_sub = False

    # Math frame default parameters
    average_all = False
    norm_and_average = False
    do_nothing = True
    sum_all = False
    normalize_and_sum_all = False
    use_for_spec_an = False
    subtract_normalized_avg = False
    subtract_normalized_spec = False
    spectra_to_subtract = 'Spectrum to subtract'
    add_pedestal = False
    pedestal_to_add = 0
    multiply = False
    multiply_factor = 1
    derivatives = False
        # End parameter definitions


    #variables to prevent the program to crash in case some of the list spectra loaded are not valid
    spectra_number = 0
    fatal_condition = 0

    # FOR PLOT
    file_to_plot = os.path.join(BASE_DIR, "example_files", "results", "NGC5320_populations.dat")



    #TIPS WINDOW, ONLY FOR DESKTOP VERSIONS
    if layout != layout_android:
        def show_tips_window(first_run):
            layout = [[sg.Text("Welcome to SPAN, a Python GUI software for 1D spectra operations and analysis", font = ('Helvetica', 16, 'bold'))],
                    [sg.Text('')],
                    [sg.Text("Here are some suggestions for you:", font = ('Helvetica', 16))],
                    [sg.Text("1. Load the example spectra by clicking the button Load!", font = ('Helvetica', 16))],
                    [sg.Text("2. Look at the plot by clicking the button Plot", font = ('Helvetica', 16))],
                    [sg.Text("3. Perform operations on the selected spectrum by opening the Spectra manipulation panel", font = ('Helvetica', 16))],
                    [sg.Text("4. View the result by clicking the Preview spec. button", font = ('Helvetica', 16))],
                    [sg.Text("5. If you are satisfied, click Process selected, or Process all to save the new spectra", font = ('Helvetica', 16))],
                    [sg.HorizontalSeparator()],
                    [sg.Text('')],
                    [sg.Text('Did you know?', font = ('Helvetica', 16, 'bold'))],
                    [sg.Text("- You can perform a lot of spectral analysis on the loaded spectra, or the modified version from", font = ('Helvetica', 16))],
                    [sg.Text("  the Spectra manipulation panel", font = ('Helvetica', 16))],
                    [sg.Text("- You will also find some useful tools to modify a data file, a fits header,", font = ('Helvetica', 16))],
                    [sg.Text("  to plot the data generated by the Spectral analysis tasks and to extract 1D spectra", font = ('Helvetica', 16))],
                    [sg.Text("  from 2D calibrated fits files or data cubes", font = ('Helvetica', 16))],
                    [sg.Text('')],
                    [sg.Checkbox("Don't show this window again", default=not first_run, key='check')],
                    [sg.Button("OK")]]

            window = sg.Window("SPAN tips", layout, modal=True)

            while True:
                event, values = window.read()

                if event == sg.WINDOW_CLOSED or event == 'OK':
                    break

            window.close()

            # Saves the user's choice to show suggestions or not
            save_config(os.path.join(BASE_DIR, "system_files", "config.ini"), show_tips=not values['check'])

        def save_config(file_path, show_tips=True):
            config = {
                'show_tips': show_tips
            }
            with open(file_path, 'w') as config_file:
                for key, value in config.items():
                    config_file.write(f"{key}={value}\n")

        def load_config(file_path):
            config = {}
            with open(file_path, 'r') as config_file:
                for line in config_file:
                    key, value = line.strip().split('=')
                    config[key] = bool(value.lower() == 'true')
            return config

        sg.theme('DefaultNoMoreNagging')

        # Check if it is the first execution
        if not os.path.exists(os.path.join(BASE_DIR, "system_files", "config.ini")):
            show_tips_window(True)
            save_config(os.path.join(BASE_DIR, "system_files", "config.ini"), show_tips=True)
        else:
            config = load_config(os.path.join(BASE_DIR, "system_files", "config.ini"))
            if config['show_tips']:
                show_tips_window(False)


    #**************************************************************
    #INITIALIZING THE MAIN GUI PANEL

    print ('***********************************************')
    print ('********* Welcome to SPAN version 6.3 *********')
    print ('********* Written by Daniele Gasparri *********')
    print ('***********************************************')
    print ('')
    print ('SPAN is a GUI Python software to perform operations and analysis on 1D reduced spectra')
    print ('')
    print ('This is the output where the infos are showed.')
    print ('If you prefer the external output, just comment the lines 719-721; 841-843; 1032-1034 depending on your operating system')
    print ('')
    print ('If you just click the Load! button, the example files are loaded and you can make some practise.')
    print ('')
    print ('NOTE: all the SPAN wavelength units are expressed in nm, except where clearly stated (yes, I know you prefer Angstrom)')
    print ('***********************************************')
    print ('SPAN will save the results in ', result_data)

    # starting the dynamic GUI window
    while True:

        #variables to see if at least I did a task and it's worth to save the results
        task_done = 0
        task_done2 = 0
        task_spec = 0
        task_spec2 = 0
        util_task = 0
        timestamp = time.strftime("%Y%m%d_%H%M%S")

        window, event, values = sg.read_all_windows()

        if event in (sg.WIN_CLOSED, 'Exit'):
            break

        if event == 'Show result folder':
            sg.popup(f"The SPAN_result folder is in: {result_data}")

        # If the user wants to change the SPAN_results directory
        if event == 'Change result folder...':
            change_result_path(config_folder)

            # Verifying and creating the directory structure
            result_path = config_folder["result_path"]
            result_data = create_result_structure(result_path)

            #creating the new SPAN_results subdirectories
            result_spec_dir = result_data+'/spec'
            result_spec = result_spec_dir+'/'
            result_snr_dir = result_data+'/SNR'
            result_bb_dir = result_data+'/black_body'
            result_xcorr_dir = result_data+'/xcorr'
            result_vel_disp_dir = result_data+'/vel_disp'
            result_ew_data_dir = result_data+'/ew'
            result_line_fitting_dir = result_data+'/line_fitting'
            result_ppxf_kin_data_dir = result_data+'/ppxf_kin'
            result_ppxf_pop_data_dir = result_data+'/ppxf_pop'
            result_sigma_coeff_dir = result_data+'/sigma_coeff'
            result_plot_dir = result_data+'/plots'
            ifs_output = result_data +'/'#'.'
            print('')
            print ('SPAN will now save the results in ', result_data)


    # def handle_clipboard(event, window):
        if event in ('Copy', 'Paste'):
            widget = window.find_element_with_focus()
            try:
                if event == 'Copy':
                    text = widget.get()  # Prende il testo dal widget
                    sg.clipboard_set(text)  # Usa la clipboard di PySimpleGUI

                elif event == 'Paste':
                    text = sg.clipboard_get()
                    widget.update(text)  # Aggiorna il widget con il contenuto della clipboard
            except Exception as e:
                continue


        if event == 'Clean output':
            window['-OUTPUT-'].update('')

    #****************** Initializing and checking the variables of the spectra frame ******************

        spectra_list = values['spec_list']
        spectra_list_name = os.path.splitext(os.path.basename(spectra_list))[0]

        #create a spectra list file
        if event == 'listfile':
            list_layout = [
            [sg.Text("Select the folder with the spectra:")],
            [sg.InputText(key='-FOLDER-'), sg.FolderBrowse()],
            [sg.Button('Save')],
            ]

            list_window = sg.Window('Generate spectra list containing 1D spectra', list_layout)

            while True:
                list_event, list_values = list_window.read()

                if list_event == sg.WINDOW_CLOSED:
                    break
                elif list_event == 'Save':
                    folder_path = list_values['-FOLDER-']
                    if folder_path:
                        file_list = stm.get_files_in_folder(folder_path)
                        output_file = os.path.basename(os.path.normpath(folder_path)) +'_spectra_list.txt'
                        stm.save_to_text_file(file_list, output_file)
                        sg.Popup('Spectra file list saved in the current working directory', output_file, 'You can now load this list file')

                        #updating the spectra list
                        window1['spec_list'].update(output_file)
                        spectra_list = output_file
                        spectra_list_name = os.path.splitext(os.path.basename(spectra_list))[0]

            list_window.close()

        #assigning lambda units of the spectra
        if (values['wave_units_nm'] == True):
            lambda_units = 'nm'
        if (values['wave_units_a'] == True):
            lambda_units = 'a'
        if (values['wave_units_mu'] == True):
            lambda_units = 'mu'

        if event == 'About SPAN':
            sg.popup ('SPAN is a Python 3.X 1D spectra analysis tool. It can modify the spectra and perform measurements, using both built-in and external (e.g. ppxf) algorithms')
        if event == 'Version':
            sg.popup ('This is version 6.3 with improved and semplified layout')


        # In the case I want to deselect all the active tasks in the main panel in one click
        if event == 'Clear all tasks':
            print ('All tasks cleared')
            window ['show_hdr']. Update (value = False)
            window ['show_step']. Update (value = False)
            window ['show_res']. Update (value = False)
            window ['convert_spec']. Update (value = False)
            window ['compare_spec']. Update (value = False)
            window ['convert_flux']. Update (value = False)
            window ['show_snr']. Update (value = False)

            cropping_spectrum = False
            sigma_clipping = False
            wavelet_cleaning = False
            filter_denoise = False
            dop_cor = False
            helio_corr = False

            # Spectra processing frame default parameters
            rebinning = False
            rebinning_log = False
            rebinning_linear = True
            degrade = False
            normalize_wave = False
            sigma_broad = False
            add_noise = False
            continuum_sub = False

            # Math frame default parameters
            average_all = False
            norm_and_average = False
            do_nothing = True
            sum_all = False
            normalize_and_sum_all = False
            use_for_spec_an = False
            subtract_normalized_avg = False
            subtract_normalized_spec = False
            spectra_to_subtract = 'Spectrum to subtract'
            add_pedestal = False
            multiply = False
            derivatives = False
            reorder_op = False

            window ['bb_fitting']. Update (value = False)
            window ['xcorr']. Update (value = False)
            window ['sigma_measurement']. Update (value = False)
            window ['ew_measurement']. Update (value = False)
            window ['line_fitting']. Update (value = False)
            window ['ppxf_kin']. Update (value = False)
            window ['ppxf_pop']. Update (value = False)
            window ['save_plots']. Update (value = False)



    #**************************************************************************************************
    #**************************************************************************************************
    #**************************************************************************************************
    #**************************************************************************************************
    #**************************************************************************************************
    #**************************************************************************************************
    #******************* Initializing and checking the variables of the utility frame *****************

        #1) show the header
        show_hdr = values['show_hdr']

        #2) show the sampling
        show_sample = values['show_step']

        #3) show resolution and check on the input values
        show_resolution = values['show_res']
        if show_resolution == True:
            try:
                res_wave1 = float(values['lambda_res_left'])
            except ValueError:
                sg.popup('Wave is not a number!')
                continue

            try:
                res_wave2 = float(values['lambda_res_right'])
            except ValueError:
                sg.popup('Wave is not a number!')
                continue
            if res_wave1 >= res_wave2:
                sg.popup('Wave1 must be SMALLER than Wave2')
                continue

        #4) convert to ASCII or FITS
        convert = values['convert_spec']
        convert_ascii = values['convert_to_txt']
        convert_fits = values['convert_to_fits']

        #5) compare the spectrum with another
        compare_spec = values['compare_spec']
        spec_compare_file = values['spec_to_compare']

        #6) convert the flux units
        convert_flux = values['convert_flux']
        convert_to_fnu = values['convert_to_fnu']
        convert_to_flambda = values['convert_to_fl']

        #7) show the snr and check on the input values
        show_snr = values['show_snr']
        if show_snr == True:
            try:
                snr_wave = float(values['wave_snr'])
            except ValueError:
                sg.popup('Wave interval is not a number!')
                continue

            try:
                epsilon_wave_snr = float(values['delta_wave_snr'])
            except ValueError:
                sg.popup('Epsilon wave is not a number!')
                continue



    #**************************************************************
    #********** Initializing and checking the Spectra manipulation panel for the mobile version **********

        if event == 'Spectra manipulation':
            sg.theme('DarkBlue3')
            spec_layout = [

            #Spectra pre-processing
            [sg.Frame('Spectra pre-processing', [
            [sg.Checkbox('Cropping', key ='cropping', font = ('Helvetica', 10, 'bold'), default = cropping_spectrum, tooltip='Crop the spectrum to a user defined wavelength range'), sg.Text('Lower wave'), sg.InputText(cropping_low_wave, key = 'cropping_low_wave', size = (5,1)), sg.Text('Upper wave'), sg.InputText(cropping_high_wave, key = 'cropping_high_wave', size = (5,1))],

            [sg.Checkbox('Dynamic cleaning', font = ('Helvetica', 10, 'bold'), key = 'sigma_clip', default = sigma_clipping,tooltip='Perform sigma clipping to erase spikes'), sg.Push(), sg.Button('Clean parameters',button_color= ('black','light blue'), size = (23,1))],

            [sg.Checkbox('Wavelet cleaning', font = ('Helvetica', 10, 'bold'), key = 'wavelet_cleaning', default = wavelet_cleaning,tooltip='Perform wavelet cleaning of the spectrum'), sg.Text('sigma:'),sg.InputText(sigma_wavelets, key = 'sigma_wavelets', size = (4,1)), sg.Text('Wavelet layers:'), sg.InputText(wavelets_layers, key = 'wavelets_layers', size = (3,1))],

            [sg.Checkbox('Filtering and denoising', font = ('Helvetica', 10, 'bold'), key = 'filter_denoise', default = filter_denoise,tooltip='Filters to smooth the spectrum'), sg.Push(), sg.Button('Denoise parameters',button_color= ('black','light blue'), size = (23,1))],

            [sg.Checkbox('Doppler/z correction', font = ('Helvetica', 10, 'bold'), key = 'dopcor', default = dop_cor,tooltip='Doppler and redshift correction of spectrum, from a list file or from a fixed radial velocity or z value'), sg.Push(), sg.Button('Dopcor parameters',button_color= ('black','light blue'), size = (23,1))],

            [sg.Checkbox('Heliocentric correction', font = ('Helvetica', 10, 'bold'), key = 'helio_corr', default = helio_corr,tooltip='Heliocentric correction, from a formatted file or by inserting the location, time and object coordinates (RA and Dec) manually'), sg.Push(), sg.Button('Heliocor parameters',button_color= ('black','light blue'), size = (23,1))],

            ], font=("Helvetica", 12, 'bold'), title_color = 'lightgreen'),

            #2) spectra processing
            sg.Frame('Spectra processing', [
            [sg.Checkbox('Rebin', font = ('Helvetica', 10, 'bold'), key = 'rebin', default = rebinning,tooltip='Rebinning the spectrum, to a linear wavelength step (nm) or to a linear sigma step (km/s)'), sg.Radio('pix lin.', "RADIO1", default=rebinning_linear, key = 'rebin_pix_lin'), sg.InputText(rebin_step_pix, size = (4,1), key = 'rebin_step_pix'), sg.Radio('sigma lin.', "RADIO1", default = rebinning_log, key = 'rebin_sigma_lin'), sg.InputText(rebin_step_sigma, size = (3,1), key = 'rebin_step_sigma')],
            [sg.Checkbox('Degrade resolution', font = ('Helvetica', 10, 'bold'), key = 'degrade_resolution', default = degrade,tooltip='Degrade resolution to a user defined value'), sg.Push(), sg.Button('Degrade parameters',button_color= ('black','light blue'), size = (20,1))],

            [sg.Checkbox('Normalise spectrum to:', font = ('Helvetica', 10, 'bold'), key = 'norm_spec', default = normalize_wave,tooltip='Normalise the flux to a user defined wavelength'), sg.InputText(norm_wave, size = (6,1), key = 'norm_wave'), sg.Text('nm')],

            [sg.Checkbox('Sigma broadening', font = ('Helvetica', 10, 'bold'), key = 'broadening_spec', default = sigma_broad,tooltip='Broad the spectrum by adding a user defined sigma (km/s). This will NOT be the total sigma broadening of your spectrum!'), sg.Text('Add sigma (km/s): ', font = ('Helvetica', 10)), sg.InputText(sigma_to_add, size = (4,1), key = 'sigma_to_add')],
            [sg.Checkbox('Add noise', font = ('Helvetica', 10, 'bold'), key = 'add_noise', default = add_noise,tooltip='Adding poissonian noise to the spectrum'), sg.Text('Signal to Noise (S/N) to add:'), sg.InputText(noise_to_add, size = (5,1), key = 'noise_to_add')],

            [sg.Checkbox('Continuum modelling', font = ('Helvetica', 10, 'bold'), key = 'cont_sub', default = continuum_sub,tooltip='Perform the continuum estimation to subtract or divide to the spectrum'), sg.Push(), sg.Button('Continuum parameters',button_color= ('black','light blue'), size = (20,1))],
            [sg.Text('', font = ("Helvetica", 1))],

            ], font=("Helvetica", 12, 'bold'),title_color = 'lightgreen'),

            #3) spectra math
            sg.Frame('Spectra math', [
            [sg.Checkbox('Subtract normalised average', font = ('Helvetica', 10, 'bold'), key = 'subtract_norm_avg', default = subtract_normalized_avg,tooltip='Normalise and subtract to the selected spectrum the normalised average of all the spectra')],
            [sg.Checkbox('Subtract norm. spec.', font = ('Helvetica', 10, 'bold'), key = 'subtract_norm_spec', default = subtract_normalized_spec,tooltip='Normalise and subtract to the selected spectrum a user selected spectrum'), sg.InputText(spectra_to_subtract, size = (17,1), key = 'spec_to_sobtract'), sg.FileBrowse(tooltip='Load a spectrum (ASCII or fits) to be normalised and subtracted')],
            [sg.Checkbox('Add constant', font = ('Helvetica', 10, 'bold'), key = 'add_pedestal', default = add_pedestal,tooltip='Simply add a constant value to the spectrum'), sg.InputText(pedestal_to_add, size = (7,1), key = 'pedestal_to_add'), sg.Checkbox('Multiply by:', font = ('Helvetica', 11, 'bold'), key = 'multiply', default = multiply,tooltip='Multiply the spectrum by a constant'), sg.InputText(multiply_factor , size = (7,1), key = 'multiply_factor')],
            [sg.Checkbox('Calculate first and second derivatives', default = derivatives, key = 'derivatives', font = ('Helvetica', 10, 'bold'),tooltip='Calculate the derivative of the spectra')],
            [sg.HorizontalSeparator()],
            [sg.Radio('Average all', "RADIOMATH", key = 'avg_all', default = average_all,tooltip='Average all the loaded spectra'), sg.Radio('Norm. and average all', "RADIOMATH", key = 'norm_avg_all', default = norm_and_average,tooltip='First normalise, then average all the loaded spectra'), sg.Radio('Nothing', "RADIOMATH", key = 'none', default = do_nothing,tooltip='Select this option if you DO NOT want to combine the spectra', font = ('Helvetica', 11, 'bold'))],
            [sg.Radio('Sum all', "RADIOMATH", key = 'sum_all', default = sum_all,tooltip='Sum all the loaded spectra'), sg.Radio('Norm. and sum all', "RADIOMATH", key = 'norm_sum_all', default = normalize_and_sum_all,tooltip='First normalise, then sum all the loaded spectra'), sg.Checkbox('Use for spec. an.', text_color = 'yellow', key = 'use_for_spec_an', default = use_for_spec_an,tooltip='Select this to use the combined spectrum for the spectral analysis', font = ('Helvetica', 11, 'bold'))],
            ],font=("Helvetica", 12, 'bold'))],

            [sg.Checkbox('Reorder', key = 'reorder_op', default = reorder_op, tooltip='Activate in case you want to perform the spectra manipulation tasks in different order'), sg.Button('Reorder tasks', tooltip='Change the order of the spectra manipulation tasks'), sg.Push(), sg.Button('I need help',button_color=('black','orange'), size = (11,1)), sg.Button('Confirm',button_color= ('white','black'), size = (18,1))]
            ]


            spec_window = sg.Window('Spectra manipulation parameters', spec_layout)



            while True:
                spec_event, spec_values = spec_window.read()

                if spec_event == sg.WIN_CLOSED:
                    break

                # Assigning parameters from the GUI
                reorder_op = spec_values['reorder_op']
                # Spectra pre-processing
                cropping_spectrum = spec_values['cropping']
                sigma_clipping = spec_values['sigma_clip']
                wavelet_cleaning = spec_values['wavelet_cleaning']
                filter_denoise = spec_values['filter_denoise']
                dop_cor = spec_values['dopcor']
                helio_corr = spec_values['helio_corr']

                #spectra processing
                rebinning = spec_values['rebin']
                rebinning_log = spec_values['rebin_sigma_lin']
                rebinning_linear = spec_values['rebin_pix_lin']
                degrade = spec_values['degrade_resolution']
                normalize_wave = spec_values['norm_spec']
                sigma_broad = spec_values['broadening_spec']
                add_noise = spec_values['add_noise']
                continuum_sub = spec_values['cont_sub']

                #math parameters
                average_all = spec_values['avg_all']
                norm_and_average = spec_values['norm_avg_all']
                do_nothing = spec_values['none']
                sum_all = spec_values['sum_all']
                normalize_and_sum_all = spec_values['norm_sum_all']
                use_for_spec_an = spec_values['use_for_spec_an']
                subtract_normalized_avg = spec_values['subtract_norm_avg']
                subtract_normalized_spec = spec_values['subtract_norm_spec']
                spectra_to_subtract = spec_values['spec_to_sobtract']
                add_pedestal = spec_values['add_pedestal']
                multiply = spec_values['multiply']
                derivatives = spec_values['derivatives']


            #********** Initializing and checking the variables of the Spectra pre-processing frame **********
                # Creating the dictionary of the spectra manipulation tasks to be user in case of re-ordering for Android devices.
                available_operations = [
                    ("Cropping", "cropping_spectrum", cropping_spectrum),
                    ("Dynamic cleaning", "sigma_clipping", sigma_clipping),
                    ("Wavelet cleaning", "wavelet_cleaning", wavelet_cleaning),
                    ("Filtering and denoise", "filter_denoise", filter_denoise),
                    ("Doppler/z correction", "dop_cor", dop_cor),
                    ("Heliocentric correction", "helio_corr", helio_corr),
                    ("Rebinning", "rebining", rebinning),
                    ("Degrade resolution", "degrade", degrade),
                    ("Normalise spectrum", "normalize_wave", normalize_wave),
                    ("Velocity dispersion broadening", "sigma_broad", sigma_broad),
                    ("Add noise", "add_noise", add_noise),
                    ("Continuun modelling", "continuum_sub", continuum_sub),

                    ("Subtract normalised average", "subtract_normalized_avg",subtract_normalized_avg),
                    ("Subtract norm. spec","subtract_normalized_spec",subtract_normalized_spec),
                    ("Add constant", "add_pedestal", add_pedestal),
                    ("Multiply by", "multiply", multiply),
                    ("Calculate first and second derivatives", "derivatives",derivatives),
                ]

                # Select only the tasks activated
                active_operations = [op[:2] for op in available_operations if op[2]]

                # Check if a previous current_order exists and match the activated tasks
                if current_order is None or set([op[1] for op in current_order]) != set([op[1] for op in active_operations]):
                    current_order = active_operations.copy()

                # Making a copy
                reordered_operations = current_order.copy()

                if spec_event == 'Reorder tasks':

                    # reordering windows layout
                    layout_reorder = [
                        [sg.Text("Please, re-order the tasks:")],
                        [sg.Listbox([op[0] for op in reordered_operations], size=(40, 12), key="-OP_LIST-", select_mode=sg.LISTBOX_SELECT_MODE_SINGLE)],
                        [sg.Button("Move up"), sg.Button("Move down"), sg.Button("Confirm"), sg.Button("Cancel")],
                    ]

                    # creating thw window
                    window_reorder = sg.Window("Order the tasks", layout_reorder)

                    sorting_cond = 0
                    while True:
                        event_reorder, values_reorder = window_reorder.read()

                        if event_reorder == sg.WINDOW_CLOSED or event_reorder == "Cancel":
                            reordered_operations = current_order.copy()
                            break

                        elif event_reorder == "Move up":
                            selected = values_reorder["-OP_LIST-"]
                            if selected:
                                idx = [op[0] for op in reordered_operations].index(selected[0])
                                if idx > 0:
                                    #change the order of the tasks
                                    reordered_operations[idx], reordered_operations[idx - 1] = reordered_operations[idx - 1], reordered_operations[idx]
                                    #update the Listbox
                                    window_reorder["-OP_LIST-"].update([op[0] for op in reordered_operations])

                        elif event_reorder == "Move down":
                            selected = values_reorder["-OP_LIST-"]
                            if selected:
                                idx = [op[0] for op in reordered_operations].index(selected[0])
                                if idx < len(reordered_operations) - 1:
                                    #change the order of the tasks
                                    reordered_operations[idx], reordered_operations[idx + 1] = reordered_operations[idx + 1], reordered_operations[idx]
                                    #update the Listbox
                                    window_reorder["-OP_LIST-"].update([op[0] for op in reordered_operations])

                        elif event_reorder == "Confirm":
                            sorting_cond = 1
                            #Save the new task order
                            current_order = reordered_operations.copy()
                            active_operations = current_order.copy()

                            #Activate the reorder checkbox automatically
                            spec_window['reorder_op'].update(True)
                            break

                    window_reorder.close()

                    if sorting_cond == 1 and len(reordered_operations) != 0:
                        print("Ordered tasks:")
                        for op in reordered_operations:
                            print(op[0])
                    if sorting_cond == 1 and len(reordered_operations) == 0:
                        print('No active tasks')


                #Initializing the values and parameters of the spectra manipulation panel

                #1) CROPPING PARAMETERS
                if cropping_spectrum == True:
                    try:
                        cropping_low_wave = float(spec_values['cropping_low_wave'])
                        cropping_high_wave = float(spec_values['cropping_high_wave'])
                    except:
                        sg.popup ('Cropping parameters not valid')
                        continue


                #2) DYNAMIC CLEANING PARAMETERS
                if spec_event  == ('Clean parameters'):

                    sg.theme('LightBlue1')
                    clean_layout = [
                        [sg.Text('Sigma to clip:',tooltip='Clipping factor'), sg.InputText(clip_factor, size = (3,1), key = 'clip_factor'), sg.Text('Res. (R)',tooltip='Spectrum resolution'), sg.InputText(sigma_clip_resolution, size = (5,1), key = 'res_spec_for_sigma_clip'), sg.Radio('Velocity dispersion (km/s)', "RADIOCLIP", default = sigma_clip_single_vel, key = 'single_vel_clip', tooltip='Velocity dispersion'), sg.InputText(sigma_clip_single_value, size = (4,1), key = 'clip_to_vel')],
                        [sg.Radio('R and sigma vel file', "RADIOCLIP", default = sigma_clip_have_file, key = 'file_for_clip',tooltip='ASCII file with R and sigma to perform sigma clipping for all the loaded spectra'), sg.InputText(sigma_clip_sigma_file, size=(14, 1), key = 'sigma_clip_file'), sg.FileBrowse(tooltip='Load an ASCII file containing: Name of the spectrum, Resolution (R), sigma (km/s), in the same order of the original spectra list')],
                        [sg.Push(), sg.Button('Confirm',button_color= ('white','black'), size = (18,1))]
                        ]

                    print ('*** Clean spectra window open. The main panel will be inactive until you close the window ***')
                    clean_window = sg.Window('Clean spectra parameters', clean_layout)

                    while True:
                        clean_event, clean_values = clean_window.read()

                        if clean_event == sg.WIN_CLOSED:
                            break

                        try:
                            clip_factor = float(clean_values['clip_factor'])
                            sigma_clip_single_value = float(clean_values['clip_to_vel'])
                            sigma_clip_resolution = int(clean_values['res_spec_for_sigma_clip'])
                            if clip_factor <=0:
                                sg.popup('Invalid sigma clip factor. Must be > 0!')
                                continue
                        except ValueError:
                            sg.popup('Sigma clip factor is not a number!')
                            continue

                        sigma_clip_single_vel = clean_values['single_vel_clip']
                        sigma_clip_have_file = clean_values['file_for_clip']
                        sigma_clip_sigma_file = clean_values['sigma_clip_file']

                        if clean_event == 'Confirm':
                            print ('Clean parameters confirmed. This main panel is now active again')
                            print ('')
                            break

                    clean_window.close()


                #3) WAVELET PARAMETERS
                if wavelet_cleaning == True:

                    try:
                        sigma_wavelets = float(spec_values['sigma_wavelets'])
                        wavelets_layers = int(spec_values['wavelets_layers'])
                    except:
                        sg.popup('Wavelet parameters not valid')
                        continue
                    if sigma_wavelets <= 0 or wavelets_layers <= 0:
                        sg.Popup ('Wavelet parameters must be greater than zero!')
                        continue
                    if wavelets_layers > 20:
                        sg.Popup ('Wavelet layers must be smaller than 20. Try again')
                        continue



                #4) FILTERING AND DENOISINS PARAMETERS
                if spec_event == 'Denoise parameters':

                    sg.theme('LightBlue1')
                    denoise_layout = [
                    [sg.Checkbox('Moving average:', font = ('Helvetiva', 11, 'bold'), default = moving_average, key = 'moving_average'), sg.Radio('Simple box:', "MOVAVG", default = box_moving_avg, key = 'box_moving_avg', font = ('Helvetica', 11, 'bold')), sg.Text('Box size (pix):'), sg.InputText(box_moving_avg_size, key = 'box_moving_avg_size', size = (7,1)),sg.Radio('Gaussian kernel:', "MOVAVG", default = gauss_moving_avg, key = 'gauss_moving_avg'), sg.Text('Sigma kernel (pix):'), sg.InputText(gauss_moving_avg_kernel, key = 'gauss_moving_avg_kernel', size = (5,1))],

                    [sg.HorizontalSeparator()],
                    [sg.Checkbox('Low-pass filter (Butterworth)', font = ('Helvetiva', 11, 'bold'), default = low_pass_filter, key = 'low_pass_filter'), sg.Text('Cut-off:'), sg.InputText(lowpass_cut_off, key = 'lowpass_cut_off', size = (7,1)), sg.Text('Filter order:'), sg.InputText(lowpass_order, key = 'lowpass_order', size = (7,1))],
                    [sg.Checkbox('Band-pass filter (Butterworth)', font = ('Helvetiva', 11, 'bold'), default = bandpass_filter, key = 'bandpass_filter'), sg.Text('lower Cut-off:'), sg.InputText(bandpass_lower_cut_off, key = 'bandpass_lower_cut_off', size = (7,1)), sg.Text('upper Cut-off:'), sg.InputText(bandpass_upper_cut_off, key = 'bandpass_upper_cut_off', size = (7,1)), sg.Text('Filter order:'), sg.InputText(bandpass_order, key = 'bandpass_order', size = (7,1))],
                    [sg.Push(), sg.Button('Confirm',button_color= ('white','black'), size = (18,1))]
                    ]

                    print ('*** Denoise window open. The main panel will be inactive until you close the window ***')
                    denoise_window = sg.Window('Denoise parameters', denoise_layout)

                    while True:
                        denoise_event, denoise_values = denoise_window.read()

                        if denoise_event == sg.WIN_CLOSED:
                            break

                        moving_average = denoise_values['moving_average']
                        box_moving_avg = denoise_values['box_moving_avg']
                        gauss_moving_avg = denoise_values['gauss_moving_avg']
                        low_pass_filter = denoise_values['low_pass_filter']
                        bandpass_filter = denoise_values['bandpass_filter']

                        try:
                            if moving_average ==True and box_moving_avg == True:
                                box_moving_avg_size = int(denoise_values['box_moving_avg_size'])
                            if moving_average == True and gauss_moving_avg == True:
                                gauss_moving_avg_kernel = float(denoise_values['gauss_moving_avg_kernel'])
                                if gauss_moving_avg_kernel <= 0 or gauss_moving_avg_kernel > 1000:
                                    sg.Popup('Gauss kernel must be greater than zero and smaller than 1000')
                                    gauss_moving_avg_kernel = 5
                                    continue

                            if low_pass_filter == True:
                                lowpass_cut_off = float(denoise_values['lowpass_cut_off'])
                                if lowpass_cut_off <=0 or lowpass_cut_off >= 1:
                                    sg.Popup ('Low-pass cut-off must be greater than 0 and smaller than 1')
                                    lowpass_cut_off = 0.1
                                    continue
                                lowpass_order = int(denoise_values['lowpass_order'])
                                if lowpass_order <=0 or lowpass_order >30:
                                    sg.Popup ('Filter order must be between 1 and 30')
                                    lowpass_order = 4
                                    continue
                            if bandpass_filter == True:
                                bandpass_lower_cut_off = float(denoise_values['bandpass_lower_cut_off'])
                                bandpass_upper_cut_off = float(denoise_values['bandpass_upper_cut_off'])
                                if bandpass_lower_cut_off >= bandpass_upper_cut_off:
                                    sg.Popup ('Lower cut-off must be greater than lower cut-off')
                                    bandpass_lower_cut_off = 0.1
                                    bandpass_upper_cut_off = 0.5
                                    continue
                                if bandpass_lower_cut_off <=0 or bandpass_lower_cut_off >= 1 or bandpass_upper_cut_off <=0 or bandpass_upper_cut_off >= 1:
                                    sg.Popup('Bandpass cut-offs must be greater than 0 and smaller than 1')
                                    bandpass_lower_cut_off = 0.1
                                    bandpass_upper_cut_off = 0.5
                                    continue
                                bandpass_order = int(denoise_values['bandpass_order'])
                                if bandpass_order <=0 or bandpass_order >30:
                                    sg.Popup ('Bandpass filter order must be between 1 and 30')
                                    bandpass_order = 4
                                    continue
                        except:
                            sg.Popup ('Parameters not valid!')
                            box_moving_avg_size = 11
                            gauss_moving_avg_kernel = 5
                            lowpass_cut_off = 0.1
                            lowpass_order = 4
                            continue


                        if denoise_event == 'Confirm':
                            print ('Denoise parameters confirmed. This main panel is now active again')
                            print ('')
                            break

                    denoise_window.close()


                #5) DOPPLER CORRECTION PARAMETERS
                if spec_event  == ('Dopcor parameters'):

                    sg.theme('LightBlue1')
                    dopcor_layout = [

                        [sg.Radio ('I have a velocity value', "RADIODOPVALUE", default = dop_cor_have_vel, key = 'dop_cor_have_vel', font = ('Helvetica', 11, 'bold'), tooltip='Usually a velocity value is used for stars and local (z < 0.01) galaxies'), sg.Radio ('I have a redshift (z) value', "RADIODOPVALUE", default = dop_cor_have_z, key = 'dop_cor_have_z', font = ('Helvetica', 11, 'bold'), tooltip='Usually a redshift (z) value is used for galaxies and has a cosmological meaning')],
                        [sg.HorizontalSeparator()],
                        [sg.Radio ('I have a list file: ', "RADIODOP", default = dop_cor_have_file, key = 'file_for_dopcor', tooltip='You can imput an ASCII file with the names of your spectra and a velocity or z value to correct. Check the readme_span file for details'), sg.InputText(dop_cor_file, size=(14, 1), key = 'dopcor_file'), sg.FileBrowse(tooltip='Load an ASCII file containing: Name of the spectrum, radial velocity to correct (km/s), in the same order of the original spectra list')],
                        [sg.Radio('Single value: ', "RADIODOP", default = dop_cor_single_shot, key ='dopcor_single_value', tooltip='Using the same velocity or z value for all the spectra loaded'), sg.Text('Rec vel (km/s) or z: '), sg.InputText(dop_cor_single_shot_vel, size = (8,1), key = 'dopcor_value')],
                        [sg.Push(), sg.Button('Confirm',button_color= ('white','black'), size = (18,1))]
                        ]

                    print ('*** Dopcor parameters window open. The main panel will be inactive until you close the window ***')
                    dopcor_window = sg.Window('Dopcor parameters', dopcor_layout)

                    while True:
                        dopcor_event, dopcor_values = dopcor_window.read()

                        if dopcor_event == sg.WIN_CLOSED:
                            break

                        dop_cor_have_file = dopcor_values['file_for_dopcor']
                        dop_cor_file = dopcor_values['dopcor_file']
                        dop_cor_single_shot = dopcor_values['dopcor_single_value']
                        dop_cor_have_vel = dopcor_values['dop_cor_have_vel']
                        dop_cor_have_z = dopcor_values['dop_cor_have_z']


                        try:
                            dop_cor_single_shot_vel = float(dopcor_values['dopcor_value'])
                            if dop_cor_have_z == True and dop_cor_single_shot_vel > 100:
                                sg.popup('Warning: the redshift (z) value inserted seems way too large. It is a velocity instead?')
                                continue
                        except ValueError:
                            sg.popup('Dopcor value is not a number!')
                            continue

                        if dopcor_event == 'Confirm':
                            print ('Dopcor parameters confirmed. This main panel is now active again')
                            print ('')
                            break

                    dopcor_window.close()


                #6) HELIOCENTRIC CORRECTION PARAMETERS
                if spec_event  == ('Heliocor parameters'):

                    sg.theme('LightBlue1')
                    heliocor_layout = [

                        [sg.Radio ('I have a file with location, date, RA and Dec. for all the spectra:', "RADIOHEL", default = helio_have_file, key = 'file_for_helio'), sg.InputText(helio_file, size = (37,1), key = 'helio_file'), sg.FileBrowse(tooltip='Load an ASCII file containing: Location, Date (YYYY-MM-DD), RA, Dec.')],
                        [sg.Radio('Single correction', "RADIOHEL", default = helio_single_shot, key = 'helio_single_value'), sg.Text('Location:'), sg.InputText(helio_single_shot_location, size = (11,1), key = 'helio_location'), sg.Text('Date:'), sg.InputText(helio_single_shot_date, size = (10,1), key = 'helio_date'), sg.Text('RA:'), sg.InputText(ra_obj, size = (10,1), key = 'helio_ra'), sg.Text('Dec.:'), sg.InputText(dec_obj, size = (10,1), key = 'helio_dec'), sg.Button('loc.list',button_color=('black','light blue'),tooltip='Click to see the pre-loaded location list for heliocentric correction')],
                        [sg.Push(), sg.Button('Confirm',button_color= ('white','black'), size = (18,1))]
                        ]

                    print ('*** Heliocor parameters window open. The main panel will be inactive until you close the window ***')
                    heliocor_window = sg.Window('Heliocor parameters', heliocor_layout)

                    while True:
                        heliocor_event, heliocor_values = heliocor_window.read()

                        if heliocor_event == sg.WIN_CLOSED:
                            break

                        helio_have_file = heliocor_values['file_for_helio']
                        helio_file = heliocor_values['helio_file']
                        helio_single_shot = heliocor_values['helio_single_value']
                        helio_single_shot_location = heliocor_values['helio_location']
                        helio_single_shot_date = heliocor_values['helio_date']
                        if helio_corr == True and helio_single_shot == True:
                            try:
                                ra_obj = float(heliocor_values['helio_ra'])
                                dec_obj = float(heliocor_values['helio_dec'])
                            except Exception:
                                sg.popup('Coordinates not valid!')
                                continue
                            try:
                                datetime.datetime.strptime(helio_single_shot_date, '%Y-%m-%d')
                            except Exception:
                                sg.popup ('Date format not valid. It must be: YYYY-MM-DD')
                                continue
                            try:
                                location = EarthLocation.of_site(helio_single_shot_location)
                            except Exception:
                                sg.popup ('Location not in the list')
                                continue
                #activating the button location list
                        if(heliocor_event == 'loc.list'):
                            try:
                                location_list = EarthLocation.get_site_names()
                                sg.popup_scrolled(location_list, size=(120, 30))
                            except Exception:
                                sg.popup('Location list not available. I need an internet connection')

                        if heliocor_event == 'Confirm':
                            print ('Heliocor parameters confirmed. This main panel is now active again')
                            print ('')
                            break

                    heliocor_window.close()


            #************ Initializing and checking the variables of the Spectra processing frame ***********

                #1) REBINNING PARAMETERS
                #a) linear rebinning
                if rebinning == True and rebinning_linear == True:
                    try:
                        rebin_step_pix = float(spec_values['rebin_step_pix'])
                        if rebin_step_pix <=0:
                            sg.popup('Invalid step. Must be > 0!')
                            continue
                    except ValueError:
                        sg.popup('Step is not a number!')
                        continue


                #b) log rebinning
                if rebinning == True and rebinning_log == True:
                    try:
                        rebin_step_sigma = float(spec_values['rebin_step_sigma'])
                        if rebin_step_sigma <1:
                            sg.popup('Invalid step. Must be >= 1!')
                            continue
                    except ValueError:
                        sg.popup('Step is not a number!')
                        continue


                #2) DEGRADE RESOLUTION PARAMETERS
                if spec_event  == ('Degrade parameters'):

                    sg.theme('LightBlue1')
                    degrade_res_layout = [
                        [sg.Radio('From R:', "RADIORESR", default = is_initial_res_r, key = 'is_initial_res_r', font = ('Helvetica', 12, 'bold') ), sg.InputText(initial_res_r, size = (6,1), key = 'degrade_from_r'), sg.Radio('to R:', "RADIORESRTOR", default = res_degrade_to_r, key = 'res_degrade_to_r' ), sg.InputText(final_res_r, size = (6,1), key = 'degrade_to_r'), sg.Radio('to FWHM (A):', "RADIORESRTOR", default = res_degrade_to_fwhm, key = 'res_degrade_to_fwhm'), sg.InputText(final_res_r_to_fwhm, size = (6,1), key = 'final_res_r_to_fwhm')],
                        [sg.HorizontalSeparator()],
                        [sg.Radio('From FWHM (A):', "RADIORESR", default = is_initial_res_fwhm, key = 'is_initial_res_fwhm', font = ('Helvetica', 12, 'bold')), sg.InputText(initial_res_fwhm, size = (4,1), key = 'degrade_from_l'), sg.Text('to FWHM (A):'), sg.InputText(final_res_fwhm, size = (4,1), key = 'degrade_to_l')],

                        [sg.Push(), sg.Button('Confirm',button_color= ('white','black'), size = (18,1))]
                        ]

                    print ('*** Degrade resolution parameters window open. The main panel will be inactive until you close the window ***')
                    degrade_res_window = sg.Window('Degrade resolution parameters', degrade_res_layout)

                    while True:
                        degrade_res_event, degrade_res_values = degrade_res_window.read()

                        if degrade_res_event == sg.WIN_CLOSED:
                            break

                        try:
                            is_initial_res_r = degrade_res_values['is_initial_res_r']
                            initial_res_r = int(degrade_res_values['degrade_from_r'])
                            res_degrade_to_r = degrade_res_values['res_degrade_to_r']
                            final_res_r = int(degrade_res_values['degrade_to_r'])
                            res_degrade_to_fwhm = degrade_res_values['res_degrade_to_fwhm']
                            final_res_r_to_fwhm = float(degrade_res_values['final_res_r_to_fwhm'])

                            is_initial_res_fwhm = degrade_res_values['is_initial_res_fwhm']
                            initial_res_fwhm = float(degrade_res_values['degrade_from_l'])
                            final_res_fwhm = float(degrade_res_values['degrade_to_l'])
                        except Exception:
                            sg.Popup('Degrade resolution parameters not valid')
                            continue

                        if initial_res_r <=0 or final_res_r <=0 or final_res_r_to_fwhm <=0 or initial_res_fwhm <=0 or final_res_fwhm <=0:
                            sg.Popup ('Resolution values cannot be negative or zero!')
                            continue

                        if final_res_fwhm < initial_res_fwhm or initial_res_r<final_res_r:
                            sg.popup('You want to improve the resolution? That''s impossible!')
                            continue

                        if degrade_res_event == 'Confirm':
                            print ('Degrade resolution parameters confirmed. This main panel is now active again')
                            print ('')
                            break

                    degrade_res_window.close()


                #3) NORMALISATION PARAMETERS
                if normalize_wave == True:
                    try:
                        norm_wave = float(spec_values['norm_wave'])
                    except ValueError:
                        sg.popup('Normalisation wave not valid!')
                        continue


                #4) SIGMA BROADENING PARAMETERS
                if sigma_broad == True:
                    try:
                        sigma_to_add = float(spec_values['sigma_to_add'])
                        if sigma_to_add < 0:
                            sg.popup('Invalid sigma broadening. Must be >= 0!')
                            continue
                    except ValueError:
                        sg.popup('Sigma broadening not valid!')
                        continue

                #5) ADD NOISE PARAMETERS
                if add_noise == True:
                    try:
                        noise_to_add = float(spec_values['noise_to_add'])
                        if noise_to_add <=0:
                            sg.popup('Invalid SNR. Must be > 0!')
                            continue
                    except ValueError:
                        sg.popup('Noise value not valid!')
                        continue


                #6) CONTINUUM MODELLING PARAMETERS
                if spec_event == 'Continuum parameters':
                    sg.theme('LightBlue1')
                    continuum_layout = [
                    [sg.Radio('Continuum model: automatic filtering of the spectrum (works good for smooth spectrum and no emission)', "CONTMODE", default = cont_model_filtering, key = 'cont_model_filtering', font = ('Helvetica', 11, 'bold'))],
                    [sg.HorizontalSeparator()],
                    [sg.Radio('Continuum model: fine-tuning polynomial fitting', "CONTMODE", default = cont_model_poly, key = 'cont_model_poly',font = ('Helvetica', 11, 'bold')), sg.Checkbox('Regions to mask:', default = cont_want_to_maks, key = 'cont_want_to_maks'), sg.InputText(cont_mask_ranges_str, size = (14,1), key = 'cont_mask_ranges'), sg.Text('Polynomial degree:'), sg.InputText(cont_poly_degree, size = (6,1), key = 'cont_poly_degree')],
                    [sg.HorizontalSeparator()],
                    [sg.Text('Operation on the spectrum:'), sg.InputCombo(markers_cont_operations, key='markers_cont_operations', default_value=cont_math_operation, readonly=True)],
                    [sg.Push(), sg.Button('Confirm',button_color= ('white','black'), size = (18,1))]
                    ]

                    print ('*** Continuum subtraction window open. The main panel will be inactive until you close the window ***')
                    continuum_window = sg.Window('Continuum parameters', continuum_layout)

                    while True:
                        continuum_event, continuum_values = continuum_window.read()

                        if continuum_event == sg.WIN_CLOSED:
                            break

                        cont_model_filtering = continuum_values['cont_model_filtering']
                        cont_model_poly = continuum_values['cont_model_poly']
                        cont_math_operation = continuum_values['markers_cont_operations']

                        if cont_model_poly == True:

                            cont_want_to_maks = continuum_values['cont_want_to_maks']
                            if cont_want_to_maks == True:
                                try:
                                    cont_mask_ranges_str = continuum_values['cont_mask_ranges']
                                    cont_mask_ranges = eval(cont_mask_ranges_str)
                                except:
                                    sg.Popup('Masking values not valid')
                                    continue
                            try:
                                cont_poly_degree = int(continuum_values['cont_poly_degree'])
                            except:
                                sg.Popup ('Polynomial degree not valid')
                                continue
                            if cont_poly_degree <0 or cont_poly_degree > 11:
                                sg.Popup('Polynomial degree must be between 0 and 11')
                                cont_poly_degree = 5
                                continue


                        if continuum_event == 'Confirm':
                            print ('Continuum parameters confirmed. This main panel is now active again')
                            print ('')
                            break

                    continuum_window.close()


                #9) add pedestal and check on the input values
                if add_pedestal == True:
                    try:
                        pedestal_to_add = float(spec_values['pedestal_to_add'])
                    except ValueError:
                        sg.popup('Pedestal value not valid!')
                        continue

                #10) multiply by a constant and check on the input values
                if multiply == True:
                    try:
                        multiply_factor = float(spec_values['multiply_factor'])
                        if multiply_factor <=0:
                            sg.popup('Invalid multiply constant. Must be > 0!')
                            continue
                    except ValueError:
                        sg.popup('Multiply value not valid!')
                        continue

                #Help file
                if spec_event == 'I need help':
                    f = open(os.path.join(BASE_DIR, "help_files", "need_help_spec_proc.txt"), 'r')
                    file_contents = f.read()
                    sg.popup_scrolled(file_contents, size=(120, 30))

                #Confirm the parameters
                if spec_event == 'Confirm':
                    print ('Spectra manipulation parameters confirmed. This main panel is now active again')
                    print ('')
                    break


            #closing the window
            spec_window.close()


        # detecting if at leas one task has been activated in the Spectra Manipulation panel and if True change the color of the button in the main GUI so that the user can remember that there are active tasks in there.
        any_active = any([
                    cropping_spectrum,
                    sigma_clipping,
                    wavelet_cleaning,
                    filter_denoise,
                    dop_cor,
                    helio_corr,
                    rebinning,
                    degrade,
                    normalize_wave,
                    sigma_broad,
                    add_noise,
                    continuum_sub,
                    average_all,
                    norm_and_average,
                    sum_all,
                    normalize_and_sum_all,
                    subtract_normalized_avg,
                    subtract_normalized_spec,
                    add_pedestal,
                    multiply,
                    derivatives,

                ])

        if any_active:
            window['Spectra manipulation'].update(button_color=('white', 'red'))
        else:
            window['Spectra manipulation'].update(button_color= ('black','light blue'))


    #*********************************************************************************************************************
    #*********************************************************************************************************************
    #*********************************************************************************************************************
    #****************** SUB WINDOWS DEFINITION AND PARAMETERS OF THE SPECTRAL ANALYSIS FRAME *****************************

        #1) BLACKBODY PARAMETERS
        bb_fit = values['bb_fitting']
        if (event == 'Blackbody parameters'):
            sg.theme('LightBlue1')
            bb_layout = [
            [sg.Text('Wave interval (nm):'), sg.InputText(wave1_bb, size = (6,1), key = 'left_wave_bb'), sg.Text('-'), sg.InputText(wave2_bb, size = (6,1), key = 'right_wave_bb'), sg.Text('Initial Temperature guess'), sg.InputText(t_guess, size = (8,1), key = 't_guess_bb')],
            [sg.Push(), sg.Button('Confirm',button_color= ('white','black'), size = (18,1))]
            ]

            print ('*** Blackbody fitting parameters window open. The main panel will be inactive until you close the window ***')
            bb_window = sg.Window('Blackbody fitting parameters', bb_layout)

            while True:
                bb_event, bb_values = bb_window.read()

                if bb_event == sg.WIN_CLOSED:
                    break

                try:
                    wave1_bb = float(bb_values['left_wave_bb'])
                    wave2_bb = float(bb_values['right_wave_bb'])
                    t_guess = float(bb_values['t_guess_bb'])

                except Exception:
                    sg.popup ('Invalid input parameters!')
                    continue
                if t_guess <=0:
                    sg.Popup ('No blackbody has a negative temperature!')
                    t_guess = 4000.
                    continue
                if t_guess > 1e7:
                    sg.Popup ('No stellar blackbody has a temperature greater than 10 million degrees!')
                    t_guess = 4000.
                    continue

                if wave1_bb >= wave2_bb:
                    sg.popup ('The first wavelength cannot be greater than the second!')
                    continue

                epsilon_wave_check = 5.
                if wave2_bb - wave1_bb <= epsilon_wave_check:
                    sg.popup ('The wavelength interval is too small to perform a good fit. Enlarge it!')
                    continue

                if bb_event == 'Confirm':
                    print ('Blackbody parameters confirmed. This main panel is now active again')
                    print ('')
                    break

            bb_window.close()



        #2) CROSS-CORRELATION PARAMETERS
        cross_corr = values['xcorr']
        if (event == 'Cross-corr parameters'):
            sg.theme('LightBlue1')
            xcorr_layout = [
            [sg.Text('Select a template:', font = ('', default_size, 'bold')), sg.InputText(template_crosscorr, size = (32,1), key = 'xcorr_template'), sg.FileBrowse(tooltip='Load a template')], [sg.Text('Template wavelegth is in:'),sg.Radio ('nm', "RADIOCORR", default = lambda_units_template_crosscorr_nm, key = 'xcorr_template_wave_nm'), sg.Radio('a', "RADIOCORR", default = lambda_units_template_crosscorr_a, key = 'xcorr_template_wave_a'), sg.Radio('mu', "RADIOCORR", key = 'xcorr_template_wave_mu', default = lambda_units_template_crosscorr_mu)],
            [sg.Checkbox('Add broadening to template (km/s):', key = 'xcorr_smooth_template',tooltip='Add a sigma broadeing to the template (km/s)', default = smooth_template_crosscorr), sg.InputText(smooth_value_crosscorr, size = (6,1), key = 'xcorr_smooth_template_value'), sg.Text(' '), sg.Button('View template',button_color=('black','light blue'))],
            [sg.HorizontalSeparator()],
            [sg.Text('Wavelength interval to cross-correlate (nm):',tooltip='Wavelength range of the spectrum to consider for cross-correlation, in nm', font = ('', default_size, 'bold')), sg.InputText(low_wave_corr, size = (6,1), key = 'xcorr_left_lambda'), sg.Text('-'), sg.InputText(high_wave_corr, size = (6,1), key = 'xcorr_right_lambda')],
            [sg.Radio('Considering the velocirty range (km/s):', "RADIOONLY2", default = is_vel_xcorr, key = 'is_vel_xcorr',tooltip='Use for peculiar Doppler motion or low (<0.01) redshift galaxies', font = ('', default_size, 'bold')), sg.InputText(low_vel_corr, size = (7,1), key = 'xcorr_low_vel'), sg.Text('-'), sg.InputText(high_vel_corr, size = (7,1), key = 'xcorr_high_vel')], [sg.Radio('Considering the redshift range (z):', "RADIOONLY2", default = is_z_xcorr, key = 'is_z_xcorr',tooltip='Use for cosmological redshift estimation, where the velocity has no physical meaning', font = ('', default_size, 'bold')), sg.InputText(low_z_corr, size = (7,1), key = 'low_z_corr'), sg.Text('-'), sg.InputText(high_z_corr, size = (7,1), key = 'high_z_corr')],
            [sg.Push(), sg.Button('Confirm',button_color= ('white','black'), size = (18,1))]
            ]

            print ('*** Cross-corr parameters window open. The main panel will be inactive until you close the window ***')
            xcorr_window = sg.Window('Cross-correlation parameters', xcorr_layout)

            while True:
                xcorr_event, xcorr_values = xcorr_window.read()

                if xcorr_event == sg.WIN_CLOSED:
                    break

                is_vel_xcorr = xcorr_values['is_vel_xcorr']
                is_z_xcorr = xcorr_values['is_z_xcorr']
                lambda_units_template_crosscorr_nm = xcorr_values['xcorr_template_wave_nm']
                lambda_units_template_crosscorr_a = xcorr_values['xcorr_template_wave_a']
                lambda_units_template_crosscorr_mu = xcorr_values['xcorr_template_wave_mu']
                template_crosscorr = xcorr_values['xcorr_template']
                if (lambda_units_template_crosscorr_nm == True):
                    lambda_units_template_crosscorr = 'nm'
                if (lambda_units_template_crosscorr_a== True):
                    lambda_units_template_crosscorr = 'a'
                if (lambda_units_template_crosscorr_mu == True):
                    lambda_units_template_crosscorr = 'mu'
                smooth_template_crosscorr = xcorr_values['xcorr_smooth_template']
                if smooth_template_crosscorr == True:
                    try:
                        smooth_value_crosscorr = float(xcorr_values['xcorr_smooth_template_value'])
                        if smooth_value_crosscorr <0:
                            sg.popup('Invalid smooth value for template. Must be >= 0!')
                            continue
                    except ValueError:
                        sg.popup('Smooth template value not valid!')
                        continue
                else:
                    smooth_value_crosscorr = 0

                #cheching the input wavelength range
                try:
                    low_wave_corr = float(xcorr_values['xcorr_left_lambda'])
                    high_wave_corr = float(xcorr_values['xcorr_right_lambda'])
                    wave_interval_corr = np.array([low_wave_corr,high_wave_corr])
                except Exception:
                    sg.popup('Limit wave values not valid!')
                    continue

                real_low_wave_corr = np.min(wave_interval_corr)
                real_high_wave_corr = np.max(wave_interval_corr)


                #existence of correct values of velocity range
                if is_vel_xcorr == True:
                    try:
                        low_vel_corr = float(xcorr_values['xcorr_low_vel'])
                        high_vel_corr = float(xcorr_values['xcorr_high_vel'])
                        vel_interval_corr = np.array([low_vel_corr,high_vel_corr])
                        low_vel_corr = np.min(vel_interval_corr)
                        high_vel_corr = np.max(vel_interval_corr)
                    except Exception:
                        sg.popup('Limit velocity values not valid!')
                        low_vel_corr = -1000
                        high_vel_corr = 1000
                        vel_interval_corr = np.array([low_vel_corr,high_vel_corr])
                        continue
                    epsilon_vel = 4
                    if abs(low_vel_corr - high_vel_corr)<epsilon_vel:
                        sg.Popup('Velocity interval too small')
                        low_vel_corr = -1000
                        high_vel_corr = 1000
                        vel_interval_corr = np.array([low_vel_corr,high_vel_corr])
                        continue

                if is_z_xcorr == True:
                    try:
                        low_z_corr = float(xcorr_values['low_z_corr'])
                        high_z_corr = float(xcorr_values['high_z_corr'])
                        #in case I invert the values
                        z_interval_corr = np.array([low_z_corr,high_z_corr])
                        low_z_corr = np.min(z_interval_corr)
                        high_z_corr = np.max(z_interval_corr)
                        if z_interval_corr[0] < 0 or z_interval_corr[1] < 0:
                            sg.popup('Redshift values must be greater than zero!')
                            z_interval_corr = np.array([0, 0.1])
                            low_z_corr = 0
                            high_z_corr = 0.1
                            continue
                        if np.max(z_interval_corr) > 10:
                            sg.Popup('Sorry, the maximum z available (and meaningful) is 10')
                            z_interval_corr = np.array([0, 0.1])
                            low_z_corr = 0
                            high_z_corr = 0.1
                            continue

                    except Exception:
                        sg.popup('Redshift values not valid!')
                        low_z_corr = 0
                        high_z_corr = 0.1
                        z_interval_corr = np.array([low_z_corr,high_z_corr])
                        continue

                    epsilon_z = 0.001
                    if abs(low_z_corr - high_z_corr)<epsilon_z:
                        sg.Popup('Redshift interval too small')
                        low_z_corr = 0
                        high_z_corr = 0.1
                        z_interval_corr = np.array([low_z_corr,high_z_corr])
                        continue



                if xcorr_event == 'View template':
                    cond01 = (os.path.isfile(template_crosscorr))
                    if cond01 == False:
                        sg.popup('The template does not exist. I have nothing to show!')
                        continue

                    wave_template1, flux_template1, step_temp1, name_temp1 = stm.read_spec(template_crosscorr, lambda_units_template_crosscorr)

                    #doing the broadening, if selected
                    if smooth_value_crosscorr > 0:
                        flux_template1 = spman.sigma_broad(wave_template1, flux_template1, smooth_value_crosscorr)
                    plt.title(template_crosscorr)
                    plt.plot(wave_template1, flux_template1)
                    plt.xlim(real_low_wave_corr,wave_interval_corr[len(wave_interval_corr)-1])
                    plt.xlabel('Wavelength (nm)')
                    plt.ylabel('Norm flux')
                    plt.show()
                    plt.close()

                #CLOSING THE WINDOW ONCE I CLICK "CONFIRM"
                if xcorr_event == 'Confirm':
                    print ('Cross-corr parameters confirmed. This main panel is now active again')
                    print ('')
                    break

            xcorr_window.close()



        # 3) VELOCITY DISPERSION PARAMETERS
        sigma_measurement = values['sigma_measurement']
        if (event == 'Sigma parameters'):
            sg.theme('LightBlue1')
            sigma_layout = [
                [sg.Text('Select a template:', font = ('', default_size, 'bold')), sg.InputText(template_sigma, size = (55,1), key = 'sigma_template'), sg.FileBrowse(tooltip='Load a template')],
                [sg.Text('Template wavelegth is in:'), sg.Radio ('nm', "RADIOSIGMA", default = lambda_units_template_sigma_nm, key = 'sigma_template_wave_nm'), sg.Radio('a', "RADIOSIGMA", default = lambda_units_template_sigma_a, key = 'sigma_template_wave_a'), sg.Radio('mu', "RADIOSIGMA", default = lambda_units_template_sigma_mu, key = 'sigma_template_wave_mu')],
                [sg.Text('Resolution (R) of the template (0 if (E)MILES)', tooltip='Set the resolving power (R) of the template in the selected wavelength band'), sg.InputText(resolution_template, size = (5,1), key = 'sigma_res_template'), sg.Push(), sg.Button('View template',button_color=('black','light blue'))],
                [sg.HorizontalSeparator()],
                [sg.Text('Pre-loaded bands to fit for sigma:', font = ('', default_size, 'bold'), tooltip='You can try some common wavelength bands for sigma measurements. I assume that the spectrum has been de-redshifted!'), sg.Radio('CaT', "RADIOBAND", default = band_cat, key = 'sigma_band_cat'), sg.Radio('Ha', "RADIOBAND", default = band_halpha, key = 'sigma_band_ha'), sg.Radio('Nad', "RADIOBAND", default = band_nad, key = 'sigma_band_nad'), sg.Radio('H band', "RADIOBAND", default = band_h, key = 'sigma_band_h'), sg.Radio('K band', "RADIOBAND", default = band_k, key = 'sigma_band_k')],
                [sg.Radio('Fitting a custom band', "RADIOBAND", default = band_custom, key = 'sigma_custom_band', tooltip='Set a wavelength band containing strong absorption features, usually 50-100 nm wide', font = ('', default_size, 'bold')), sg.Text('Wave interval (nm)'), sg.InputText(low_wave_sigma, size = (5,1), key = 'sigma_left_lambda'), sg.Text('-'), sg.InputText(high_wave_sigma, size = (5,1), key = 'sigma_right_lambda'), sg.Text('Cont. interval'), sg.InputText(low_wave_cont, size = (5,1), key = 'sigma_cont_left_lambda'), sg.Text('-'), sg.InputText(high_wave_cont, size = (5,1), key = 'sigma_cont_right_lambda')],
                [sg.HorizontalSeparator()],
                [sg.Text('Resolution of the spectrum (R)', tooltip='If your spectrum has a variable R, try to estimate a mean value at the center of the considered wavelength band'), sg.InputText(resolution_spec, size=(5,1), key = 'sigma_spec_res')],
                [sg.Push(), sg.Button('Confirm',button_color= ('white','black'), size = (18,1))]
                ]

            print ('*** Sigma parameters window open. The main panel will be inactive until you close the window ***')
            sigma_window = sg.Window('Sigma parameters', sigma_layout)

            while True:
                sigma_event, sigma_values = sigma_window.read()

                if sigma_event == sg.WIN_CLOSED:
                    break

                lambda_units_template_sigma_nm = sigma_values['sigma_template_wave_nm']
                lambda_units_template_sigma_a = sigma_values['sigma_template_wave_a']
                lambda_units_template_sigma_mu = sigma_values['sigma_template_wave_mu']

                template_sigma = sigma_values['sigma_template']

                #assigning lambda units of the template spectra
                if (lambda_units_template_sigma_nm == True):
                    lambda_units_template_sigma = 'nm'
                if (lambda_units_template_sigma_a == True):
                    lambda_units_template_sigma = 'a'
                if (lambda_units_template_sigma_mu == True):
                    lambda_units_template_sigma = 'mu'

                #preloaded bands
                band_cat = sigma_values['sigma_band_cat']
                band_halpha = sigma_values['sigma_band_ha']
                band_nad = sigma_values['sigma_band_nad']
                band_h = sigma_values['sigma_band_h']
                band_k = sigma_values['sigma_band_k']

        #************* Define the preloaded bands for the velocity dispersion measurement ********

                if band_cat == True:
                    band_sigma = np.array([844., 872.])
                    cont_sigma = np.array([856.,864.])

                if band_halpha == True:
                    band_sigma = np.array([642.,661])
                    cont_sigma = np.array([651., 654.])

                if band_nad == True:
                    band_sigma = np.array([560., 615.])
                    cont_sigma = np.array([591., 597.])

                if band_h == True:
                    band_sigma = np.array([1660., 1720.])
                    cont_sigma = np.array([1693., 1704.])

                if band_k == True:
                    band_sigma = np.array([2270., 2370.])
                    cont_sigma = np.array([2270., 2280.])


                if sigma_measurement == True:
                    try:
                        resolution_spec = float(sigma_values['sigma_spec_res'])
                        resolution_template = float(sigma_values['sigma_res_template'])
                        if resolution_spec <=0 or resolution_template < 0:
                            sg.popup('Invalid resolution values for the spectrum or the template')
                            continue
                    except ValueError:
                        sg.popup('Resolution values for sigma not valid!')
                        continue

                band_custom = sigma_values['sigma_custom_band']
                if sigma_measurement == True and band_custom == True:
                    try:
                        low_wave_sigma = float(sigma_values['sigma_left_lambda'])
                        high_wave_sigma = float(sigma_values['sigma_right_lambda'])
                        low_wave_cont = float(sigma_values['sigma_cont_left_lambda'])
                        high_wave_cont = float(sigma_values['sigma_cont_right_lambda'])

                        if band_custom == True:
                            band_sigma = np.array([low_wave_sigma, high_wave_sigma])
                            cont_sigma = np.array([low_wave_cont, high_wave_cont])
                    except ValueError:
                        sg.popup('Band values for sigma not valid!')
                        continue

                if sigma_event == 'View template':

                    #test if file file exist
                    cond02 = (os.path.isfile(template_sigma))
                    if cond02 == False:
                        sg.popup('The template does not exist. I have nothing to show!')
                        continue

                    wave_template2, flux_template2, step_temp2, name_temp2 = stm.read_spec(template_sigma, lambda_units_template_sigma)
                    plt.title(template_sigma)
                    plt.plot(wave_template2, flux_template2)
                    plt.xlim(band_sigma[0],band_sigma[1])
                    plt.xlabel('Wavelength (nm)')
                    plt.ylabel('Norm flux')
                    plt.show()
                    plt.close()

                #CLOSING THE WINDOW ONCE I CLICK "CONFIRM"
                if sigma_event == 'Confirm':
                    print ('Sigma parameters confirmed. This main panel is now active again')
                    print ('')
                    break

            sigma_window.close()



        #4) EQUIVALENT WIDTH PARAMETERS
        ew_measurement = values['ew_measurement']

        if (event == 'Line-strength parameters'):
            sg.theme('LightBlue1')
            ew_layout = [
                [sg.Radio('User indices on a list file:', "RADIOEW", default = have_index_file, key = 'ew_idx_file',  font = ('', default_size, 'bold'),tooltip='You need an ASCII file with the index definition. See the readme to how to build this file'), sg.InputText(index_file, size = (48,1), key = 'idx_file'), sg.FileBrowse(size = (10,1))],
                [sg.HorizontalSeparator()],
                [sg.Radio('Single index', "RADIOEW", default = single_index, key = 'ew_single_idx',font = ('', default_size, 'bold'),tooltip='Enter the index definition wavelengths in the windows on the right'), sg.Text('blue cont.:'), sg.InputText(idx_left_blue, size = (5,1), key = 'left_wave_blue_cont'), sg.Text('-'), sg.InputText(idx_right_blue, size = (5,1), key = 'right_wave_blue_cont'), sg.Text('red cont.:'), sg.InputText(idx_left_red, size = (5,1), key = 'left_wave_red_cont'), sg.Text('-'),  sg.InputText(idx_right_red, size = (5,1), key = 'right_wave_red_cont'), sg.Text('line:'), sg.InputText(idx_left_line, size = (5,1), key = 'left_line'), sg.Text('-'), sg.InputText(idx_right_line, size = (5,1), key = 'right_line')],
                [sg.HorizontalSeparator()],

                #Lick/IDS indices
                [sg.Radio('Lick/IDS indices:', "RADIOEW", default = lick_ew, key = 'ew_lick', font = ('', default_size, 'bold'),tooltip='Measure the classical Lick/IDS indices. You do not need to enter their definitions'), sg.Radio('Constant resolution FWHM:', "RADIOLICKRES", default = lick_constant_fwhm, key ='lick_constant_fwhm'), sg.InputText(spec_lick_res_fwhm, key = 'spec_lick_res_fwhm',size = (7,1)), sg.Radio('Constant resolution R:', "RADIOLICKRES", default = lick_constant_r, key ='lick_constant_r'), sg.InputText(spec_lick_res_r, key = 'spec_lick_res_r',size = (8,1))],
                [sg.Text(' '), sg.Checkbox('Emission line(s) correction:', default = lick_correct_emission, key = 'lick_correct_emission'), sg.Text('Redshift guess'), sg.InputText(z_guess_lick_emission, key = 'z_guess_lick_emission', size = (15,1)), sg.Text(' '), sg.Checkbox('Perform Doppler correction', default = dop_correction_lick, key = 'dop_correction_lick')],
                [sg.Text(' '), sg.Checkbox('Correct for sigma:', default = correct_ew_sigma, key = 'correct_ew_sigma'), sg.Radio('Auto', "RADIOLICKSIGMA", default = radio_lick_sigma_auto, key = 'radio_lick_sigma_auto'), sg.Radio('Single (km/s):', "RADIOLICKSIGMA", default = radio_lick_sigma_single, key = 'radio_lick_sigma_single'), sg.InputText(sigma_single_lick, size = (5,1), key = 'sigma_single_lick'), sg.Radio('List:', "RADIOLICKSIGMA", default = radio_lick_sigma_list, key = 'radio_lick_sigma_list'), sg.InputText(sigma_lick_file, key = 'sigma_lick_file', size = (17,1)), sg.FileBrowse(size = (10,1)) ],
                [sg.Text(' '), sg.Checkbox('Estimate stellar parameters with SSP models:', default = stellar_parameters_lick, key = 'stellar_parameters_lick',tooltip='Perform interpolation with SSP model grids to retrieve age, metellicity and alpha enhancement. The Thomas2010 models are the most reliable'), sg.InputCombo(lick_ssp_models, key='ssp_model',default_value=ssp_model, readonly=True, size = (14,1)), sg.Text('Interpolation mode:',tooltip='Interpolate linearly with griddata function or with machine learning Gaussian Process Regression (GPR)'), sg.InputCombo(interp_modes, key='interp_model',default_value=interp_model, readonly=True, size = (14,1))],
                [sg.Push(), sg.Button('Confirm',button_color= ('white','black'), size = (18,1))],
                [sg.HorizontalSeparator()],

                #7) Determination of the velocity disperion coefficients. Stand alone: need a separate sample of spectra
                [sg.Checkbox('Calculate velocity dispersion coefficients', font = ('', default_size, 'bold'), key = 'sigma_coeff',tooltip='Determination of the velocity dispersion coefficients to correct the EW of the indices of the spectrum', default = sigma_coeff), sg.Push(), sg.Button('Sigma coeff parameters',button_color= ('black','light blue'), size = (22,1)), sg.Button('Compute!',button_color=('black','light grey'), size = (12,1))],

                #8) Apply the velocity dispersion correction coefficientd to the loaded spectra
                [sg.Checkbox('Correct the line-strength for velocity dispersion', font = ('', default_size, 'bold'), key = 'sigma_corr',tooltip='Correct the raw measured EW of the spectra to a zero velocity dispersion frame, using the coefficients calculated in the Sigma coeff determination task', default = sigma_corr), sg.Push(), sg.Button('Sigma corr parameters',button_color= ('black','light blue'), size = (22,1)), sg.Button('Correct!',button_color=('black','light grey'), size = (12,1)) ]

                ]

            print ('*** Line-strength parameters window open. The main panel will be inactive until you close the window ***')
            ew_window = sg.Window('Line-strength parameters', ew_layout)

            while True:
                ew_event, ew_values = ew_window.read()

                if ew_event == sg.WIN_CLOSED:
                    break

                index_file = ew_values['idx_file']

                have_index_file = ew_values['ew_idx_file']
                single_index = ew_values['ew_single_idx']

                lick_ew = ew_values['ew_lick']
                lick_constant_fwhm = ew_values['lick_constant_fwhm']
                lick_constant_r = ew_values['lick_constant_r']

                lick_correct_emission = ew_values['lick_correct_emission']
                radio_lick_sigma_single = ew_values['radio_lick_sigma_single']
                radio_lick_sigma_list = ew_values['radio_lick_sigma_list']
                radio_lick_sigma_auto = ew_values['radio_lick_sigma_auto']
                sigma_lick_file = ew_values['sigma_lick_file']
                correct_ew_sigma = ew_values['correct_ew_sigma']
                stellar_parameters_lick = ew_values['stellar_parameters_lick']
                dop_correction_lick = ew_values['dop_correction_lick']
                ssp_model = ew_values['ssp_model']
                interp_model = ew_values['interp_model']

                sigma_coeff = ew_values['sigma_coeff']
                sigma_corr = ew_values['sigma_corr']


                try:
                    idx_left_blue = float(ew_values['left_wave_blue_cont'])
                    idx_right_blue = float(ew_values['right_wave_blue_cont'])
                    idx_left_red = float(ew_values['left_wave_red_cont'])
                    idx_right_red = float(ew_values['right_wave_red_cont'])
                    idx_left_line = float(ew_values['left_line'])
                    idx_right_line = float(ew_values['right_line'])
                    spec_lick_res_fwhm = float(ew_values['spec_lick_res_fwhm'])
                    spec_lick_res_r = float(ew_values['spec_lick_res_r'])
                    sigma_single_lick = float(ew_values['sigma_single_lick'])
                    z_guess_lick_emission = float(ew_values['z_guess_lick_emission'])

                    #building the index
                    index_usr = np.array([idx_left_blue, idx_right_blue, idx_left_red, idx_right_red, idx_left_line, idx_right_line]).T
                except ValueError:
                    sg.popup('Index values for EW measurement not valid!')
                    continue

                if lick_constant_fwhm == True and (spec_lick_res_fwhm < 0):
                    sg.popup ('FWHM resolution must be positive!')
                    continue

                if lick_constant_r == True and (spec_lick_res_r < 0):
                    sg.popup ('R resolution must be positive!')
                    continue

                if correct_ew_sigma == True and radio_lick_sigma_single == True and sigma_single_lick < 0:
                    sg.popup ('Sigma value must be positive!')
                    continue

                #Check if the sigma file exist
                if correct_ew_sigma == True and radio_lick_sigma_list == True:

                    #test if file file exist
                    cond0000 = (os.path.isfile(sigma_lick_file))
                    if cond0000 == False:
                        sg.popup('The sigma list file does not exist. Skipping...')
                        continue

                #CLOSING THE WINDOW ONCE I CLICK "CONFIRM"
                if ew_event == 'Confirm':
                    print ('Line-strength parameters confirmed. This main panel is now active again')
                    print ('')
                    break

            #A) SIGMA COEFF DETERMINATION
                if ew_event == 'Sigma coeff parameters':
                    sg.theme('LightBlue1')
                    sigmacorr_layout = [
                        [sg.Radio('Index list file:', "RADIOCOEFF1", default = have_index_file_corr, key = 'ew_corr_idx_file'), sg.InputText(index_file_corr, size = (15,1), key = 'idx_corr_file'), sg.Radio('Usr index', "RADIOCOEFF1", default = single_index_corr, key = 'ew_corr_single_idx'), sg.Text('blue continuum:'), sg.InputText(idx_left_blue_sigma, size = (5,1), key = 'left_wave_blue_cont'), sg.Text('-'), sg.InputText(idx_right_blue_sigma, size = (5,1), key = 'right_wave_blue_cont'), sg.Text('red continuum:'), sg.InputText(idx_left_red_sigma, size = (5,1), key = 'left_wave_red_cont'), sg.Text('-'),  sg.InputText(idx_right_red_sigma, size = (5,1), key = 'right_wave_red_cont'), sg.Text('line:'), sg.InputText(idx_left_line_sigma, size = (5,1), key = 'left_line'), sg.Text('-'), sg.InputText(idx_right_line_sigma, size = (5,1), key = 'right_line')],
                        [sg.Text('Sample spectra list:'), sg.InputText(stellar_spectra_coeff_file, size = (17,1), key = 'sigma_coeff_sample_list'), sg.FileBrowse(tooltip='Load a list file containing the names of the sample spectra'), sg.Radio('nm', "RADIOCOEFF", key = 'sigma_coeff_sample_list_wave_nm', default = lambda_units_coeff_nm), sg.Radio('A', "RADIOCOEFF", key = 'sigma_coeff_sample_list_wave_a', default = lambda_units_coeff_a), sg.Radio('mu', "RADIOCOEFF", default = lambda_units_coeff_mu, key = 'sigma_coeff_sample_list_wave_mu'), sg.Checkbox('Add a sigma (km/s): ', key = 'sigma_coeff_sample_smooth', default = smooth_stellar_sample ), sg.InputText(smooth_value_sample, size = (5,1), key = 'sigma_coeff_sample_smooth_sigma')],

                        [sg.Push(), sg.Button('Confirm',button_color= ('white','black'), size = (18,1))]
                        ]

                    sigmacorr_window = sg.Window('Sigma coeff parameters', sigmacorr_layout)


                    print (single_index_corr)
                    while True:

                        sigmacorr_event, sigmacorr_values = sigmacorr_window.read()

                        if sigmacorr_event == sg.WIN_CLOSED:
                            break

                        index_file_corr = sigmacorr_values['idx_corr_file']
                        have_index_file_corr = sigmacorr_values['ew_corr_idx_file']
                        single_index_corr = sigmacorr_values['ew_corr_single_idx']

                        try:
                            idx_left_blue_sigma = float(sigmacorr_values['left_wave_blue_cont'])
                            idx_right_blue_sigma = float(sigmacorr_values['right_wave_blue_cont'])
                            idx_left_red_sigma = float(sigmacorr_values['left_wave_red_cont'])
                            idx_right_red_sigma = float(sigmacorr_values['right_wave_red_cont'])
                            idx_left_line_sigma = float(sigmacorr_values['left_line'])
                            idx_right_line_sigma = float(sigmacorr_values['right_line'])
                            #building the index
                            index_usr_corr = np.array([idx_left_blue_sigma, idx_right_blue_sigma, idx_left_red_sigma, idx_right_red_sigma, idx_left_line_sigma, idx_right_line_sigma]).T
                        except ValueError:
                            sg.popup('Index values not valid!')
                            continue

                        stellar_spectra_coeff_file = sigmacorr_values['sigma_coeff_sample_list']
                        lambda_units_coeff_nm = sigmacorr_values['sigma_coeff_sample_list_wave_nm']
                        lambda_units_coeff_a = sigmacorr_values['sigma_coeff_sample_list_wave_a']
                        lambda_units_coeff_mu = sigmacorr_values['sigma_coeff_sample_list_wave_mu']
                        #assigning lambda units of the spectra
                        if (lambda_units_coeff_nm == True):
                            lambda_units_coeff = 'nm'
                        if (lambda_units_coeff_a == True):
                            lambda_units_coeff = 'a'
                        if (lambda_units_coeff_mu == True):
                            lambda_units_coeff = 'mu'

                        smooth_stellar_sample = sigmacorr_values['sigma_coeff_sample_smooth']
                        if smooth_stellar_sample == True:
                            smooth_value_sample = float(sigmacorr_values['sigma_coeff_sample_smooth_sigma'])
                        else:
                            smooth_value_sample = 0.

                        if sigmacorr_event == 'Confirm':
                            print ('sigma coeff parameters confirmed. This main panel is now active again')
                            print ('')
                            break

                    sigmacorr_window.close()


                #B) CORRECT EWS FOR SIGMA
                if ew_event == 'Sigma corr parameters':
                    sg.theme('LightBlue1')
                    correw_layout = [
                        [sg.Text('Sigma list file'), sg.InputText(sigma_vel_file, size = (14,1), key = 'sigma_file'), sg.FileBrowse(tooltip='Load the ASCII file of the results of the velocity dispersion task, that contains: Spec. name, sigma, err_sigma'), sg.Text('EW file to correct:'), sg.InputText(ew_list_file, size = (14,1), key = 'ew_file_to_correct'), sg.FileBrowse(tooltip='Load the ASCII file of the results of the equivalent width task, that contains: Spec. name, EW, err_ew'), sg.Text('Correction coeff. file'), sg.InputText(sigma_coeff_file, size = (14,1), key = 'coeff_sigma_file'), sg.FileBrowse(tooltip='Load the ASCII file of the results of the Sigma coeff determination task, that contains: coeff. indices, coeff. errors')] ,
                        [sg.Push(), sg.Button('Confirm',button_color= ('white','black'), size = (18,1))]
                        ]

                    print ('*** Sigma corr parameters window open. The main panel will be inactive until you close the window ***')
                    correw_window = sg.Window('Sigma correction parameters', correw_layout)

                    while True:

                        correw_event, correw_values = correw_window.read()

                        if correw_event == sg.WIN_CLOSED:
                            break

                        sigma_vel_file = correw_values['sigma_file']
                        ew_list_file = correw_values['ew_file_to_correct']
                        sigma_coeff_file = correw_values['coeff_sigma_file']

                        if correw_event == 'Confirm':
                            print ('sigma corr parameters confirmed. This main panel is now active again')
                            print ('')
                            break

                    correw_window.close()

                # Check conditions
                if (sigma_coeff == False and ew_event == 'Compute!'):
                    sg.popup ('Cannot compute until you activate the Sigma coeff determination task!')

                if (sigma_corr == False and ew_event == 'Correct!'):
                    sg.popup ('Cannot correct until you activate the Correct EWs for sigma task!')


                # 8) SIGMA COEFF DETERMINATION
                if (ew_event == 'Compute!' and sigma_coeff == True):
                    #preparing the files to be saved
                    if (sigma_coeff == True and single_index_corr == True):

                        #verify the index definition is in the correct sequence
                        if (index_usr_corr[0] > index_usr_corr[1] or index_usr_corr[2] >index_usr_corr[3] or index_usr_corr[4] > index_usr_corr[5]):
                            sg.popup('It seems we have a problem. Did you invert the wavelengths of the indices?')
                            continue

                        coeff_file = result_sigma_coeff_dir+'/'+spectra_list_name+'_sigma_coeff_' +timestamp + '.dat'
                        coeff_id = ['sigma_spline', 'err_spline']
                        coeff_number = 4
                        coeff_values = np.zeros(coeff_number)
                        err_coeff_values = np.zeros(coeff_number)
                        coeff_data_array = np.column_stack((coeff_values, err_coeff_values))

                        #generating the dataframe and adding the data
                        df_coeff = pd.DataFrame(coeff_data_array, columns = coeff_id)

                        #writing to a file
                        df_coeff.to_csv(coeff_file, index= True, sep=' ')

                    elif (sigma_coeff == True and single_index_corr == False):
                        cond33 = (os.path.isfile(index_file_corr))
                        if cond33 == False:
                            sg.popup('The index file does not exist. Skipping...')
                            continue

                        #exploring the index file for errors
                        try:
                            idx_names, indices = ls.read_idx(index_file_corr)
                        except ValueError:
                            sg.popup('At least one index in the file is not valid')
                            continue

                        if len(indices[:,0]) < 6:
                            sg.popup ('The length of at least one index is not correct')
                            continue

                        coeff_file = result_sigma_coeff_dir+'/'+spectra_list_name+'_sigma_coeff_' +timestamp + '.dat'
                        coeff_number = 4

                        id_array, index = ls.read_idx(index_file_corr)
                        num_indices = len(id_array)

                        shape = (coeff_number, num_indices)
                        coeff_all = np.zeros(shape)
                        coeff_err_all = np.zeros(shape)

                        err_col_type = np.chararray(num_indices)
                        err_col_type = 'e'
                        err_col_names = np.char.add(id_array, err_col_type)

                        #merge the column array names
                        col_names = np.concatenate((id_array, err_col_names))
                        coeff_id = col_names
                        coeff_data = np.column_stack((coeff_all, coeff_err_all))

                        df_coeff = pd.DataFrame(coeff_data, columns = coeff_id)
                        df_coeff.to_csv(coeff_file, index= True, sep=' ')


                    #1) If I want to measure just one index
                    if (sigma_coeff == True and single_index_corr == True):

                        cond666 = (os.path.isfile(stellar_spectra_coeff_file))
                        if cond666 == False:
                            sg.popup('Stellar spectra file does not exist. Skipping...')
                            continue


                        #check to add the absolute path in case the spectra list is given in relative path
                        with open(stellar_spectra_coeff_file, 'r') as f:
                            spec_names_sample = []
                            for line in f:
                                line = line.strip()
                                if not line or line.startswith("#"):
                                    continue

                                # If I gave the relative path, try to solve the absolute path
                                if os.path.isabs(line) == False:
                                    spec_names_sample.append(os.path.join(BASE_DIR, line))

                                #If I have the absolute path
                                else:
                                    # Loading the spectra list
                                    spec_names_sample = np.loadtxt(stellar_spectra_coeff_file, dtype = 'str', delimiter = ' ', usecols=[0])
                                    break

                        #Check if the sample spectra really exist
                        check_condition = 0
                        sample_spec_not_exist = []
                        for x in range (len(spec_names_sample)):
                            cond_spec_existence = (os.path.isfile(spec_names_sample[x]))
                            if cond_spec_existence == False:
                                sample_spec_not_exist.append(spec_names_sample[x])
                                check_condition = 1
                        if check_condition == 1:
                            sg.popup ('Warning: the following spectra do not exist! delete from the list or I will crash!', sample_spec_not_exist)
                            continue

                        print ('Running Sigma coefficient determination task...')

                        idx_array, ew_coeff_array, err_coeff_array, ew_mean, ew_std, stop_cond = ls.sigma_coeff (stellar_spectra_coeff_file, index_usr_corr, lambda_units_coeff, True, False, smooth_value_sample, True, result_plot_dir)

                        df_coeff.iloc[:, 0]= ew_coeff_array
                        df_coeff.iloc[:, 1]= err_coeff_array
                        df_coeff.columns = ['sigma_spline', 'err_spline']
                        df_coeff.to_csv(coeff_file, index= False, sep=' ')

                        print ('Sigma correction coefficients for usr index')
                        print (ew_coeff_array)
                        print ('')
                        print ('Error correction coefficients for usr index')
                        print (err_coeff_array)
                        print('')
                        print('I saved the plots for you in the ', result_plot_dir, ' folder' )
                        print('')
                        print ('File saved: ', coeff_file)


                    if (sigma_coeff == True and single_index_corr == False):

                        #reading the index file
                        try:
                            id_array, index = ls.read_idx(index_file_corr)
                            num_indices = len(id_array)
                        except Exception:
                            sg.popup ('The index file does not exist!')
                            continue

                        cond666 = (os.path.isfile(stellar_spectra_coeff_file))
                        if cond666 == False:
                            sg.popup('Stellar spectra file does not exist. Skipping...')
                            continue


                        #check to add the absolute path in case the spectra list is given in relative path
                        with open(stellar_spectra_coeff_file, 'r') as f:
                            spec_names_sample = []
                            for line in f:
                                line = line.strip()
                                if not line or line.startswith("#"):
                                    continue

                                # If I gave the relative path, try to solve the absolute path
                                if os.path.isabs(line) == False:
                                    spec_names_sample.append(os.path.join(BASE_DIR, line))

                                #If I have the absolute path
                                else:
                                    # Loading the spectra list
                                    spec_names_sample = np.loadtxt(stellar_spectra_coeff_file, dtype = 'str', delimiter = ' ', usecols=[0])
                                    break

                        #check if the spectra actually exist
                        #cheching if the spectra in the sample file exist
                        # spec_names_sample = np.loadtxt(stellar_spectra_coeff_file, dtype = 'str', delimiter = ' ', usecols=[0])

                        check_condition = 0
                        sample_spec_not_exist = []
                        for x in range (len(spec_names_sample)):
                            cond_spec_existence = (os.path.isfile(spec_names_sample[x]))
                            if cond_spec_existence == False:
                                sample_spec_not_exist.append(spec_names_sample[x])
                                check_condition = 1
                        if check_condition == 1:
                            sg.popup ('Warning: the following spectra do not exist! delete from the list or I will crash!', sample_spec_not_exist)
                            continue

                        print ('Running Sigma coefficient determination task...')

                        idx_array, ew_coeff_array, err_coeff_array, ew_mean, ew_std, stop_cond = ls.sigma_coeff (stellar_spectra_coeff_file, index_file_corr, lambda_units_coeff, False, False, smooth_value_sample, True, result_plot_dir)

                        for k in range(num_indices):
                            ew_coeff_array_new = ew_coeff_array[:,k]
                            err_coeff_array_new = err_coeff_array[:,k]

                            #Updating the dataframe
                            df_coeff[coeff_id[k]]= ew_coeff_array_new
                            df_coeff[coeff_id[k+num_indices]] = err_coeff_array_new
                            df_coeff.to_csv(coeff_file, index= False, sep=' ')


                        print ('Indices')
                        print (idx_array)
                        print ('')
                        print ('Sigma correction coefficients for usr index')
                        print (ew_coeff_array)
                        print ('')
                        print ('Error correction coefficients for usr index')
                        print (err_coeff_array)
                        print('')
                        print('I saved the plots for you in the ', result_plot_dir, ' folder' )
                        print('')
                        print ('File saved: ', coeff_file)


                #9) CORRECT EWS FOR SIGMA
                if (ew_event == 'Correct!'):
                    if sigma_corr == True:
                        task_done2 = 1

                        cond77 = (os.path.isfile(sigma_coeff_file))
                        if cond77 == False:
                            sg.popup('Sigma coefficient file does not exist. Skipping...')
                            continue

                        cond66 = (os.path.isfile(ew_list_file))
                        if cond66 == False:
                            sg.popup('EW file does not exist. Skipping...')
                            continue

                        cond88 = (os.path.isfile(sigma_vel_file))
                        if cond88 == False:
                            sg.popup('Sigma velocities file does not exist. Skipping...')
                            continue

                        print ('Running correct EWs task...')

                        try:
                            all_idx_np, new_ew_data = ls.corr_ew(ew_list_file, sigma_coeff_file, sigma_vel_file)
                        except ValueError:
                            sg.popup ('Cannot compare apples with oranges! The EW file and the correction coefficients file do not have the same indices. ')
                            continue

                        #creating and saving here the file since is one shot only
                        results_ew = result_ew_data_dir+'/'+spectra_list_name+'_sigma_corr_ew_data_' + timestamp + '.dat'
                        df = pd.DataFrame(new_ew_data, columns = all_idx_np)
                        df.to_csv(results_ew, index= False, sep=' ')
                        print('EWs corrected saved to ', results_ew)
                        sg.popup ('Succeed!')

            ew_window.close()


        #5) LINE(S) FITTING PARAMETERS
        line_fitting = values['line_fitting']

        if (event == 'Line fitting parameters'):
            sg.theme('LightBlue1')
            linefit_layout = [
                [sg.Radio('Automatic fit of the CaT lines', "RADIOFILEFIT", key = 'cat_fit', default = cat_band_fit,tooltip='Automatic CaT band fitting with three gaussian functions and a line')],
                [sg.Radio('Manual fit of the following line:', "RADIOFILEFIT", default = usr_fit_line, key = 'line_fit_single',tooltip='Fitting of user defined line with the parameters on the right'),sg.Checkbox('Emission', default = emission_line, key = 'emission_line'), sg.Text('Wave:'), sg.InputText(low_wave_fit, size = (4,1), key = 'left_wave_fitting'), sg.Text('-'), sg.InputText(high_wave_fit, size = (4,1), key = 'right_wave_fitting'), sg.Text('Guess:',tooltip='Initial guess only for usr line, fitted with a gaussian and a line'), sg.Text('Y-off'), sg.InputText (y0, key = 'y0', size = (3,1)), sg.Text('Line'), sg.InputText(x0, key = 'x0', size = (4,1)), sg.Text('Height'), sg.InputText(a, key = 'a', size = (3,1)), sg.Text('Sigma'), sg.InputText(sigma, key = 'sigma', size = (3,1)), sg.Text('Slope'), sg.InputText(m, key = 'm', size = (2,1)), sg.Text('Intercept'), sg.InputText(c, key = 'c', size = (2,1))],
                [sg.Push(), sg.Button('Confirm',button_color= ('white','black'), size = (18,1))]
                ]

            print ('*** Line fitting parameters window open. The main panel will be inactive until you close the window ***')
            linefit_window = sg.Window('Line(s) fitting parameters', linefit_layout)

            while True:
                linefit_event, linefit_values = linefit_window.read()

                if linefit_event == sg.WIN_CLOSED:
                    break

                cat_band_fit = linefit_values['cat_fit']
                usr_fit_line = linefit_values['line_fit_single']
                emission_line = linefit_values['emission_line']

                try:
                    low_wave_fit = float(linefit_values['left_wave_fitting'])
                    high_wave_fit = float(linefit_values['right_wave_fitting'])
                    y0 = float(linefit_values['y0'])
                    x0 = float(linefit_values['x0'])
                    a = float(linefit_values['a'])
                    sigma = float(linefit_values['sigma'])
                    m = float(linefit_values['m'])
                    c = float(linefit_values['c'])
                    wave_interval_fit = np.array([low_wave_fit,high_wave_fit])
                    guess_param = [y0,x0,a,sigma,m,c]
                except ValueError:
                    sg.popup ('At least one of the parameters of the Line(s) fitting task is not valid!')
                    continue

                if linefit_event == 'Confirm':
                    print ('Line fitting parameters confirmed. This main panel is now active again')
                    print ('')
                    break

            linefit_window.close()



        #6) KINEMATICS WITH PPXF
        perform_kinematics = values['ppxf_kin']
        if (event == 'Kinematics parameters'):
            sg.theme('LightBlue1')
            ppxf_kin_layout = [
                [sg.Text('Wavelength interval (nm):', font = ('', default_size, 'bold')), sg.InputText(wave1_kin, size = (5,1), key = 'left_wave_ppxf_kin'), sg.Text('-'), sg.InputText(wave2_kin, size = (5,1), key = 'right_wave_ppxf_kin'), sg.Text('Sigma (km/s):',font = ('', default_size, 'bold')), sg.InputText(sigma_guess_kin, size = (5,1), key = 'sigma_guess_kin'), sg.Text('Redshift (z):',font = ('', default_size, 'bold')),sg.InputText(redshift_guess_kin, size = (7,1), key = 'redshift_guess_kin')],
                [sg.HorizontalSeparator()],
                [sg.Radio('Spec. constant FWHM resolution (A):', "RADIORES1", default = constant_resolution_lambda, key = 'constant_resolution_lambda',tooltip='Instrumental resolution (FWHM) in A of the spectral region',font = ('', default_size, 'bold')), sg.InputText(resolution_kin , size = (4,1), key = 'ppxf_resolution'), sg.Radio('Spec. constant R resolution:', "RADIORES1", key = 'constant_resolution_r', default = constant_resolution_r,font = ('', default_size, 'bold')), sg.InputText(resolution_kin_r, size = (6,1), key = 'ppxf_resolution_r')],
                [sg.HorizontalSeparator()],

                [sg.Radio('Preset SPS libraries included with SPAN:', 'RADIOLIBKIN', default = ppxf_kin_preloaded_lib, key = 'ppxf_kin_preloaded_lib', font = ('', default_size, 'bold')), sg.InputCombo(markers_ppxf_kin, key='markers_ppxf_kin',default_value=stellar_library_kin, readonly=True, size = (14,1))],                                                                                                                                                                                                            [sg.Radio('Custom (E)MILES:', 'RADIOLIBKIN', default = ppxf_kin_custom_lib, key = 'ppxf_kin_custom_lib', font = ('', default_size, 'bold'),tooltip='Select a folder containing your set of (E)MILES templates'), sg.InputText(ppxf_kin_lib_folder, size = (27,1), key = 'ppxf_kin_lib_folder'), sg.FolderBrowse(), sg.Text('Prefix:', font = ('', default_size, 'bold'), tooltip='Emiles templates have a suffix, please provide it'), sg.InputText(ppxf_kin_custom_temp_suffix, size = (12,1), key = 'ppxf_kin_custom_temp_suffix') ],
                [sg.HorizontalSeparator()],

                [sg.Radio('Fitting only stellar kinematics',"RADIOKIN", key = 'no_gas_kin', default = no_gas_kin, font = ('', default_size, 'bold'),tooltip='Considering only the kinematics of stars'), sg.Checkbox('Masking the gas emission lines', default = ppxf_kin_mask_emission, key = 'ppxf_kin_mask_emission', tooltip = ('Activate the masking if gas emission is present!'))],
                [sg.Text(''), sg.Checkbox('Fit two stellar components with the following parameters:', default = ppxf_kin_two_stellar_components, key = 'ppxf_kin_two_stellar_components', tooltip='Enable to fit TWO stellar SSPs with different V and sigma', font = ('', default_size, 'bold'))],
                [sg.Text(''), sg.Text('Select SSP model 1:'), sg.Text('Age(Gyr):'), sg.InputText(ppxf_kin_age_model1, size = (4,1), key = 'ppxf_kin_age_model1'), sg.Text('[M/H]:'), sg.InputText(ppxf_kin_met_model1, size = (4,1), key = 'ppxf_kin_met_model1'), sg.Text('Vel.(km/s):'),sg.InputText(ppxf_kin_vel_model1, size = (4,1), key = 'ppxf_kin_vel_model1'), sg.Text('Sigma(km/s):'), sg.InputText(ppxf_kin_sigma_model1, size = (4,1), key = 'ppxf_kin_sigma_model1')],

                [sg.Text(''), sg.Text('Select SSP model 2:'), sg.Text('Age(Gyr):'), sg.InputText(ppxf_kin_age_model2, size = (4,1), key = 'ppxf_kin_age_model2'), sg.Text('[M/H]:'), sg.InputText(ppxf_kin_met_model2, size = (4,1), key = 'ppxf_kin_met_model2'), sg.Text('Vel.(km/s):'),sg.InputText(ppxf_kin_vel_model2, size = (4,1), key = 'ppxf_kin_vel_model2'), sg.Text('Sigma(km/s):'), sg.InputText(ppxf_kin_sigma_model2, size = (4,1), key = 'ppxf_kin_sigma_model2')],

                [sg.Text('', font = ('', 1))],
                [sg.Radio('Fitting gas and stellar kinematics together', "RADIOKIN", key = 'gas_kin', default = gas_kin, font = ('', default_size, 'bold'),tooltip='Fitting the kinematics of ONE stellar component and the gas emission')],
                [sg.Checkbox('Correct for dust the stars', key = 'ppxf_kin_dust_stars', default = ppxf_kin_dust_stars, tooltip='Applying the default 2-params attenuation curve for stars of Cappellari 2023'), sg.Checkbox('Correct for dust the gas', key = 'ppxf_kin_dust_gas', default = ppxf_kin_dust_gas, tooltip='Applying the Calzetti extinction curve for gas'), sg.Checkbox('Tie Balmer lines', key = 'ppxf_kin_tie_balmer', default = ppxf_kin_tie_balmer)],
                [sg.HorizontalSeparator()],







                [sg.Text('Moments to fit:', font = ('', default_size, 'bold'), tooltip='Moments of the LOSVD. Minimum 2 (V and sigma), maximum 6. Proposed value = 4'), sg.InputText(kin_moments, size = (3,1), key = 'kin_moments'), sg.Text('Additive degree:', font = ('', default_size, 'bold'), tooltip='Additive degree to the fit'), sg.InputText(additive_degree_kin, size = (3,1), key = 'additive_degree_kin'), sg.Text('Noise:', font = ('', default_size, 'bold'), tooltip='Mean noise per pixel of the spectrum'), sg.InputText(ppxf_kin_noise, size = (8,1), key = 'ppxf_kin_noise'), sg.Checkbox('Auto noise estimation', default = kin_best_noise, key = ('kin_best_noise'), tooltip='Auto estimate the noise level of the spectrum for the best formal error estimation')],
                [sg.HorizontalSeparator()],

                [sg.Checkbox('Estimate the uncertainties with MonteCarlo simulations', font = ('', default_size, 'bold'), key = 'with_errors_kin', default = with_errors_kin, tooltip='Calculate the uncertainties in the LOSVD with MonteCarlo simulations'), sg.Text('N. sim.:'), sg.InputText(ppxf_kin_mc_sim, size = (7,1), key = 'ppxf_kin_mc_sim')],
                [sg.Button("Help", size=(12, 1),button_color=('black','orange')), sg.Push(), sg.Button('Confirm',button_color= ('white','black'), size = (18,1))]
                ]

            print ('*** Kinematics parameters window open. The main panel will be inactive until you close the window ***')
            ppxf_kin_window = sg.Window('pPXF Kinematics parameters', ppxf_kin_layout)


            while True:

                ppxf_kin_event, ppxf_kin_values = ppxf_kin_window.read()

                if ppxf_kin_event == sg.WIN_CLOSED:
                    break

                constant_resolution_lambda = ppxf_kin_values['constant_resolution_lambda']
                constant_resolution_r = ppxf_kin_values['constant_resolution_r']
                stellar_library_kin = ppxf_kin_values['markers_ppxf_kin']

                gas_kin = ppxf_kin_values['gas_kin']
                no_gas_kin = ppxf_kin_values['no_gas_kin']
                kin_best_noise = ppxf_kin_values['kin_best_noise']
                with_errors_kin = ppxf_kin_values['with_errors_kin']

                #parameters for custom EMILES templates
                ppxf_kin_preloaded_lib = ppxf_kin_values['ppxf_kin_preloaded_lib']
                ppxf_kin_custom_lib = ppxf_kin_values['ppxf_kin_custom_lib']
                ppxf_kin_lib_folder = ppxf_kin_values['ppxf_kin_lib_folder']
                ppxf_kin_custom_temp_suffix = ppxf_kin_values['ppxf_kin_custom_temp_suffix']

                #parameters for dust
                ppxf_kin_tie_balmer = ppxf_kin_values['ppxf_kin_tie_balmer']
                ppxf_kin_dust_stars = ppxf_kin_values['ppxf_kin_dust_stars']
                ppxf_kin_dust_gas = ppxf_kin_values['ppxf_kin_dust_gas']

                #checking the existence of the custom templates in the specified folder
                if ppxf_kin_custom_lib == True:
                    matching_temp_kin = glob.glob(os.path.join(ppxf_kin_lib_folder, ppxf_kin_custom_temp_suffix))
                    if not matching_temp_kin:
                        sg.Popup('Custom (E)miles templates not found. Check the suffix or the folder')
                        continue

                ppxf_kin_mask_emission = ppxf_kin_values['ppxf_kin_mask_emission']
                ppxf_kin_two_stellar_components = ppxf_kin_values['ppxf_kin_two_stellar_components']

                #check on the wavelength band
                try:
                    wave1_kin = float(ppxf_kin_values['left_wave_ppxf_kin'])
                    wave2_kin = float(ppxf_kin_values['right_wave_ppxf_kin'])
                    resolution_kin = float(ppxf_kin_values['ppxf_resolution'])
                    resolution_kin_r = float(ppxf_kin_values['ppxf_resolution_r'])
                    sigma_guess_kin = float(ppxf_kin_values['sigma_guess_kin'])
                    redshift_guess_kin = float(ppxf_kin_values['redshift_guess_kin'])
                    additive_degree_kin = int(ppxf_kin_values['additive_degree_kin'])

                    kin_moments = int(ppxf_kin_values['kin_moments'])
                    ppxf_kin_noise = float(ppxf_kin_values['ppxf_kin_noise'])
                    ppxf_kin_mc_sim = int(ppxf_kin_values['ppxf_kin_mc_sim'])

                    #parameters for two components fitting, checking only if activated
                    if ppxf_kin_two_stellar_components == True:
                        ppxf_kin_age_model1 = float(ppxf_kin_values['ppxf_kin_age_model1'])
                        ppxf_kin_met_model1 = float(ppxf_kin_values['ppxf_kin_met_model1'])
                        ppxf_kin_age_model2 = float(ppxf_kin_values['ppxf_kin_age_model2'])
                        ppxf_kin_met_model2 = float(ppxf_kin_values['ppxf_kin_met_model2'])
                        ppxf_kin_vel_model1 = float(ppxf_kin_values['ppxf_kin_vel_model1'])
                        ppxf_kin_sigma_model1 = float(ppxf_kin_values['ppxf_kin_sigma_model1'])
                        ppxf_kin_vel_model2 = float(ppxf_kin_values['ppxf_kin_vel_model2'])
                        ppxf_kin_sigma_model2 = float(ppxf_kin_values['ppxf_kin_sigma_model2'])

                except ValueError:
                    sg.popup ('Input parameters are not valid numbers!')
                    continue

                if kin_moments < 2 or kin_moments > 6:
                    sg.popup('Valid kinematics moments are between 2 and 6. Please, input a valid value')
                    kin_moments = 4
                    continue

                if ppxf_kin_event == 'Confirm':
                    print ('Kinematics parameters confirmed. This main panel is now active again')
                    print ('')
                    break

                if ppxf_kin_event == 'Help':
                    f = open(os.path.join(BASE_DIR, "help_files", "help_kinematics.txt"), 'r')
                    file_contents = f.read()
                    if layout == layout_android:
                        sg.popup_scrolled(file_contents, size=(120, 30))
                    else:
                        sg.popup_scrolled(file_contents, size=(100, 40))

            ppxf_kin_window.close()


        #7) STELLAR POPULATIONS WITH PPXF
        stellar_pop = values['ppxf_pop']

        if (event == 'Population parameters'):
            sg.theme('LightBlue1')

            ppxf_pop_layout = [
                [sg.Text('Wavelength interval (nm):', font = ('', default_size, 'bold')), sg.InputText(wave1_pop, size = (5,1), key = 'left_wave_ppxf_pop'), sg.Text('-'), sg.InputText(wave2_pop, size = (5,1), key = 'right_wave_ppxf_pop'), sg.Text('Spec. resolution FWHM (A):', font = ('', default_size, 'bold'),tooltip='Instrumental resolution (FWHM) in A of the spectral region'), sg.InputText(res_pop , size = (4,1), key = 'resolution_ppxf_pop')],
                [sg.Text('Velocity dispersion guess (km/s):', font = ('', default_size, 'bold')), sg.InputText(sigma_guess_pop, size = (9,1), key = 'sigma_guess_pop'), sg.Text('Redshift guess (z):', font = ('', default_size, 'bold')), sg.InputText(z_pop, size = (8,1), key = 'ppxf_z_pop')],
                [sg.HorizontalSeparator()],

                [sg.Radio('Fitting stars and gas together', "RADIOPOP", key = 'gas_pop', default = pop_with_gas, font = ('', default_size, 'bold')), sg.Radio('Fitting only stars',"RADIOPOP", key = 'no_gas_pop', default = pop_without_gas, font = ('', default_size, 'bold'))],
                [sg.Checkbox('Correct for dust the stars', key = 'ppxf_pop_dust_stars', default = ppxf_pop_dust_stars, tooltip='Applying the default 2-params attenuation curve for stars of Cappellari 2023'), sg.Checkbox('Correct for dust the gas', key = 'ppxf_pop_dust_gas', default = ppxf_pop_dust_gas, tooltip='Applying the Calzetti extinction curve for gas'), sg.Checkbox('Tie Balmer lines', key = 'ppxf_pop_tie_balmer', default = ppxf_pop_tie_balmer)],
                [sg.HorizontalSeparator()],

                [sg.Text('Noise:', font = ('', default_size, 'bold'), tooltip='Mean noise per pixel of the spectrum'), sg.InputText(ppxf_pop_noise, size = (8,1), key = 'ppxf_pop_noise'), sg.Text('Regul. error:', font = ('', default_size, 'bold'), tooltip='Regularization parameter. Higher values = sharper solution. Lower values = smoother fit. Set zero to deactivate.'), sg.InputText(regul_err, size = (5,1), key = 'regul_err'), sg.Text('Add. degree:', font = ('', default_size, 'bold'), tooltip='Additive degree to the fit. Not recommended to use for stellar populations!'), sg.InputText(additive_degree, size = (3,1), key = 'additive_degree'), sg.Text('Mult. degree:', font = ('', default_size, 'bold'), tooltip='Multiplicative degree to the fit. Usually 1 degree every 100 Angstron of spectrum to be fitted'), sg.InputText(multiplicative_degree, size = (3,1), key = 'multiplicative_degree')],
                [sg.Checkbox('Auto noise', default = ppxf_best_noise_estimate, key = 'ppxf_best_noise_estimate', tooltip='Let pPXF to estimate the best noise so that chi2 = 1 for non regularized fit'), sg.Checkbox('Auto noise and Regul. error', default = ppxf_best_param, key = ('ppxf_best_param'), tooltip='DO NOT use with > 200 templates or > 100 nn w. range. The Regul. error is a guess'), sg.Text('Fraction of Dchi2:', tooltip='Fraction of the desired Delta chi2 you want to reach. Max 20-30% if S/N < 40'), sg.Slider(range=(0.1, 1), orientation='h', default_value= ppxf_frac_chi, key='ppxf_frac_chi', resolution = 0.1, size = (13,20))],
                [sg.HorizontalSeparator()],

                [sg.Radio('Preset SPS libraries included with SPAN:', 'RADIOLIBPPXF', default = ppxf_pop_preloaded_lib, key = 'ppxf_pop_preloaded_lib', font = ('', default_size, 'bold'), tooltip='Use the sMILES library to measure also the Alpha/Fe'), sg.InputCombo(markers_ppxf, key='markers_ppxf',default_value=stellar_library, readonly=True, size = (14,1))],                                                                                                                                                                                                            [sg.Radio('Custom (E)MILES:', 'RADIOLIBPPXF', default = ppxf_pop_custom_lib, key = 'ppxf_pop_custom_lib', font = ('', default_size, 'bold'),tooltip='Select a folder containing your set of (E)MILES templates'), sg.InputText(ppxf_pop_lib_folder, size = (21,1), key = 'ppxf_pop_lib_folder'), sg.FolderBrowse(), sg.Text('Prefix:', font = ('', default_size, 'bold'), tooltip='Emiles templates have a suffix, please provide it'), sg.InputText(ppxf_custom_temp_suffix, size = (10,1), key = 'ppxf_custom_temp_suffix') ],
                [sg.Radio('Custom .npz template set:', 'RADIOLIBPPXF', default = ppxf_pop_custom_npz, key = 'ppxf_pop_custom_npz', font = ('', default_size, 'bold'), tooltip='Use your custom .npz template set'), sg.InputText(ppxf_pop_npz_file, size = (21,1), key = 'ppxf_pop_npz_file'), sg.FileBrowse()],
                [sg.Checkbox('Mask the emission lines', default = ppxf_pop_mask, key = 'ppxf_pop_mask', tooltip='If activated, you should perform a fit without gas emission'), sg.Checkbox('Regions to mask (nm):', default = ppxf_pop_want_to_mask, key = 'ppxf_pop_want_to_mask'), sg.InputText(ppxf_pop_mask_ranges_str, size = (14,1), key = 'ppxf_pop_mask_ranges')],
                [sg.Checkbox('Convolve templates to galaxy resolution', default = ppxf_pop_convolve, key = 'ppxf_pop_convolve', tooltip='If activated, the templates are convolved to the resolution of the galaxy spectrum'), sg.Checkbox('Consider ages in log10 for mean values', default = ppxf_pop_lg_age, key = 'ppxf_pop_lg_age', tooltip='If de-activated, the mean ages are calculated in the linear grid (in Gyr) instead the default log10 grid of pPXF')],
                [sg.HorizontalSeparator()],

                [sg.Text('Age range for SPS models (Gyr):', font = ('', default_size, 'bold'))],
                [sg.Text('Min. age:'), sg.Slider(range=(0, 16), orientation='h', default_value= ppxf_min_age, key='ppxf_min_age', resolution = 0.1, size = (20,20)), sg.Text('Max. age:'), sg.Slider(range=(0, 16), orientation='h', default_value= ppxf_max_age, key='ppxf_max_age', resolution = 0.1, size = (20,20))],
                [sg.Text('Metallicity range for SPS models (dex):', font = ('', default_size, 'bold'))],
                [sg.Text('Min. met:'), sg.Slider(range=(-2.5, 0.8), orientation='h', default_value= ppxf_min_met, key='ppxf_min_met', resolution = 0.1, size = (20,20)), sg.Text('Max. met:'), sg.Slider(range=(-2, 0.8), orientation='h', default_value= ppxf_max_met, key='ppxf_max_met', resolution = 0.1, size = (20,20))],
                [sg.Checkbox('Estimate uncertainties for age and met (long process)', font = ('', default_size, 'bold'), key = 'ppxf_err_pop', default = with_errors,tooltip='Calculate the errors for age and metallicity with bootstrap simulations'), sg.Text('N. bootstrap:'), sg.InputText(ppxf_pop_error_nsim, size = (5,1), key = 'ppxf_pop_error_nsim')],
                [sg.HorizontalSeparator()],

                [sg.Checkbox('Lick/IDS analysis with SSP models:', default = stellar_parameters_lick_ppxf, key = 'stellar_parameters_lick_ppxf',tooltip='Use the pPXF results to estimate the stellar parameters also with the Lick/IDS indices', font = ('', default_size, 'bold')), sg.InputCombo(lick_ssp_models_ppxf, key='ssp_model_ppxf',default_value=ssp_model_ppxf, readonly=True, size = (11,1)), sg.Text('Interpolation:',tooltip='Interpolate linearly with griddata function or with machine learning Gaussian Process Regression (GPR)'), sg.InputCombo(interp_modes_ppxf, key='interp_model_ppxf',default_value=interp_model_ppxf, readonly=True, size = (7,1))],

                [sg.Button("Help", size=(12, 1),button_color=('black','orange')), sg.Push(), sg.Button('Confirm',button_color= ('white','black'), size = (18,1))]
                ]

            print ('*** Population parameters window open. The main panel will be inactive until you close the window ***')
            ppxf_pop_window = sg.Window('pPXF Population parameters', ppxf_pop_layout)

            while True:

                ppxf_pop_event, ppxf_pop_values = ppxf_pop_window.read()

                if ppxf_pop_event == sg.WIN_CLOSED:
                    break

                ppxf_pop_want_to_mask = ppxf_pop_values['ppxf_pop_want_to_mask']
                ppxf_pop_dust_stars = ppxf_pop_values['ppxf_pop_dust_stars']
                ppxf_pop_dust_gas = ppxf_pop_values['ppxf_pop_dust_gas']
                ppxf_best_noise_estimate = ppxf_pop_values['ppxf_best_noise_estimate']
                ppxf_pop_lg_age = ppxf_pop_values['ppxf_pop_lg_age']
                stellar_parameters_lick_ppxf = ppxf_pop_values['stellar_parameters_lick_ppxf']
                ssp_model_ppxf = ppxf_pop_values['ssp_model_ppxf']
                interp_model_ppxf = ppxf_pop_values['interp_model_ppxf']

                if ppxf_pop_want_to_mask == True:
                    try:
                        ppxf_pop_mask_ranges_str = ppxf_pop_values['ppxf_pop_mask_ranges']
                        ppxf_pop_mask_ranges = eval(ppxf_pop_mask_ranges_str)
                    except:
                        sg.Popup('Masking values not valid')
                        ppxf_pop_mask_ranges_str = ppxf_pop_mask_ranges_str_default
                        ppxf_pop_mask_ranges = ppxf_pop_mask_ranges_default
                        continue


                stellar_library = ppxf_pop_values['markers_ppxf']
                pop_with_gas = ppxf_pop_values['gas_pop']
                if pop_with_gas == True:
                    fit_components = ('with_gas')
                    ppxf_pop_tie_balmer = ppxf_pop_values['ppxf_pop_tie_balmer']
                pop_without_gas = ppxf_pop_values['no_gas_pop']
                if pop_without_gas == True:
                    fit_components = ('without_gas')

                ppxf_pop_preloaded_lib = ppxf_pop_values['ppxf_pop_preloaded_lib']
                ppxf_pop_custom_lib = ppxf_pop_values['ppxf_pop_custom_lib']
                ppxf_pop_lib_folder = ppxf_pop_values['ppxf_pop_lib_folder']

                ppxf_pop_custom_npz = ppxf_pop_values['ppxf_pop_custom_npz']
                ppxf_pop_npz_file = ppxf_pop_values['ppxf_pop_npz_file']

                ppxf_pop_mask = ppxf_pop_values['ppxf_pop_mask']
                ppxf_best_param = ppxf_pop_values['ppxf_best_param']
                ppxf_custom_temp_suffix = ppxf_pop_values['ppxf_custom_temp_suffix']
                ppxf_frac_chi = float(ppxf_pop_values['ppxf_frac_chi'])
                ppxf_pop_convolve = ppxf_pop_values['ppxf_pop_convolve']
                with_errors = ppxf_pop_values['ppxf_err_pop']

                #checking the existence of the custom templates in the specified folder
                if ppxf_pop_custom_lib == True and ppxf_pop_custom_npz == False:
                    matching_temp = glob.glob(os.path.join(ppxf_pop_lib_folder, ppxf_custom_temp_suffix))
                    if not matching_temp:
                        sg.Popup('Custom (E)miles templates not found. Check the suffix or the folder')
                        continue

                try:
                    wave1_pop = float(ppxf_pop_values['left_wave_ppxf_pop'])
                    wave2_pop = float(ppxf_pop_values['right_wave_ppxf_pop'])
                    res_pop = float(ppxf_pop_values['resolution_ppxf_pop'])
                    sigma_guess_pop = float(ppxf_pop_values['sigma_guess_pop'])
                    regul_err = float(ppxf_pop_values['regul_err'])
                    ppxf_pop_noise = float(ppxf_pop_values['ppxf_pop_noise'])
                    additive_degree = int(ppxf_pop_values['additive_degree'])
                    multiplicative_degree = int(ppxf_pop_values['multiplicative_degree'])
                    z_pop = float(ppxf_pop_values['ppxf_z_pop'])
                    ppxf_min_age = float(ppxf_pop_values['ppxf_min_age'])
                    ppxf_max_age = float(ppxf_pop_values['ppxf_max_age'])
                    ppxf_min_met = float(ppxf_pop_values['ppxf_min_met'])
                    ppxf_max_met = float(ppxf_pop_values['ppxf_max_met'])
                    age_range_array = np.array([ppxf_min_age, ppxf_max_age])
                    met_range_array = np.array([ppxf_min_met, ppxf_max_met])
                    ppxf_pop_error_nsim = int(ppxf_pop_values['ppxf_pop_error_nsim'])

                except ValueError:
                    sg.popup ('Invalid input parameters!')
                    continue

                # consistency check on the input parameters
                if regul_err < 0:
                    sg.popup ('Regularization error must be greater than zero. Set zero for non-regularized fit')
                    regul_err = 0.02 #If I close the window restore the default value
                    continue
                if ppxf_pop_noise <=0:
                    sg.popup ('Noise must be positive')
                    ppxf_pop_noise = 0.0163
                    continue

                if with_errors == True and ppxf_pop_error_nsim < 3:
                    sg.popup('Well, the number of bootstrap simulations cannot be zero, negative or too close to zero! Select at least 3 simulations to perform')
                    ppxf_pop_error_nsim = 50
                    continue

                if with_errors == True and ppxf_pop_error_nsim > 100:
                    sg.popup('The numnber of bootstrap simulations you entered is quite large. This will require a lot of time (hours). Are you sure?')

                if ppxf_pop_event == 'Confirm':
                    print ('Population parameters confirmed. This main panel is now active again')
                    print ('')
                    break

                if ppxf_pop_event == 'Help':
                    f = open(os.path.join(BASE_DIR, "help_files", "help_stellar_pop.txt"), 'r')
                    file_contents = f.read()
                    if layout == layout_android:
                        sg.popup_scrolled(file_contents, size=(120, 30))
                    else:
                        sg.popup_scrolled(file_contents, size=(100, 40))

            ppxf_pop_window.close()


        #********************************** last options **********************************
        save_intermediate_files = values['save_intermediate_files']
        save_plot = values['save_plots']






        #*****************************************************************************************
        #*****************************************************************************************
        #*****************************************************************************************
        #********************************** STAND ALONE SUB-APPLICATIONS *************************


        #********************* LONG-SLIT SPECTRA EXTRACTION ***********************

        if event == 'Long-slit extraction':
            sg.theme('DarkBlue3')
            x_axis = np.array([])
            # Define FreeSimpleGUI layout
            spec_extr_layout = [
                [sg.Text("Select FITS File:", font=("Helvetica", 15, 'bold'), text_color = 'light blue'), sg.InputText(default_text = file_path_spec_extr, key="file_path", size = (38,1)), sg.FileBrowse()],
                [sg.Text("Select Y Range for Trace Fitting:"), sg.InputText(default_text= trace_y_range_str, key="trace_y_range",size=(12, 1)), sg.Text("Degree to fit:"), sg.InputText(default_text= poly_degree_str, key="poly_degree",size=(5, 1))],
                [sg.Button("1) Open 2D Spectrum", button_color=('black','light blue'), size=(18, 1), tooltip='First we have to load and visualise the spectrum'), sg.Button("2) Fit Trace",button_color=('black','light green'), size=(19, 1), tooltip='Now we find the trace of the spectrum along the dispersion axis'), sg.Button("3) Correct Spectrum",button_color=('black','orange'), size=(18, 1), tooltip='Finally we correct the distortion of the spectrum before the extraction')],
                [sg.HorizontalSeparator()],
                [sg.Button("Extract 1D Spectrum",size=(20, 1), tooltip='Extract 1D spectrum within the selected Y range. Useful for point sources'), sg.Text("Y Range for Extract 1D Spectrum:"), sg.InputText(default_text=extract_y_range_str, key="extract_y_range",size=(12, 1))],
                [sg.Button("Extract SNR bin Spectra",size=(20, 1), tooltip='Extract n bins with the selected SNR Threshold. Useful for extended sources'), sg.Text('SNR Threshold:'), sg.InputText(key='snr',size=(4, 1), default_text=snr_threshold_str), sg.Text('Pix scale ("/pix):'), sg.InputText(key='pix_scale',size=(5, 1), default_text=pixel_scale_str)],
                [sg.Canvas(key="-CANVAS-")],
                [sg.Button("Help", size=(12, 1),button_color=('black','orange')), sg.Push(), sg.Button("Exit", size=(12, 1))]
            ]

            print ('*** 2D spectra extraction open. The main panel will be inactive until you close the window ***')

            spec_extr_window = sg.Window("2D spectra extraction", spec_extr_layout, finalize=True)
            canvas_elem = spec_extr_window["-CANVAS-"]
            canvas = canvas_elem.Widget

            trace_model = None
            check_cond = 0

            # Event loop
            while True:
                spec_extr_event, spec_extr_values = spec_extr_window.read()

                if spec_extr_event == (sg.WIN_CLOSED):
                    print('2D spec window closed. This main panel is now active again')
                    print('')
                    break

                file_path_spec_extr= spec_extr_values['file_path']
                trace_y_range_str= spec_extr_values['trace_y_range']
                poly_degree_str= spec_extr_values['poly_degree']
                extract_y_range_str= spec_extr_values['extract_y_range']
                snr_threshold_str= spec_extr_values['snr']
                pixel_scale_str= spec_extr_values['pix_scale']


                if spec_extr_event == ('Exit'):
                    print('2D spec window closed. This main panel is now active again')
                    print('')
                    break

                if spec_extr_event == "1) Open 2D Spectrum":

                    try:
                        trace_model = None
                        check_cond = 1
                        spectrum, header = stm.open_fits(file_path_spec_extr)
                        x_axis = np.arange(len(spectrum[0]))
                        plt.imshow(spectrum, cmap="viridis", norm=LogNorm())
                        plt.title("2D Spectrum")
                        plt.show()
                        plt.close()
                    except Exception:
                        sg.popup ('Spectrum not valid. Must be a 2D fits image!')

                if spec_extr_event == "2) Fit Trace":

                    try:
                        trace_y_range = eval(trace_y_range_str)
                        poly_degree = int(poly_degree_str)

                        if poly_degree < 1 or poly_degree > 5:
                            sg.popup ('The polynomial degree should be between 1 and 5')
                            continue

                        trace_model = stm.find_and_fit_spectroscopic_trace(spectrum, trace_y_range, poly_degree, True, True)

                    except Exception as e:
                        sg.popup_error(f"Error: {str(e)}")

                if spec_extr_event == "3) Correct Spectrum":
                    trace_y_range = eval(trace_y_range_str)

                    if trace_model is not None:
                        corrected_spectrum = stm.correct_distortion_slope(spectrum, trace_model, trace_y_range)
                    else:
                        sg.popup_error("Please find and fit the spectroscopic trace first.")

                if spec_extr_event == "Extract 1D Spectrum":
                    if trace_model is not None:

                        extract_y_range = eval(extract_y_range_str)
                        extracted_filename = os.path.splitext(os.path.basename(file_path_spec_extr))[0]
                        #creating the directory
                        result_longslit_extraction = result_data+'/longslit_extracted/'+extracted_filename+'/'
                        os.makedirs(result_longslit_extraction, exist_ok=True)
                        stm.extract_1d_spectrum(corrected_spectrum, extract_y_range, header, x_axis, output_fits_path= (result_longslit_extraction + f"{extracted_filename}_extracted_.fits"))
                        sg.popup ('1D spectrum saved in the working directory')
                    else:
                        sg.popup_error("Please find and fit the spectroscopic trace first.")

                if spec_extr_event == "Extract SNR bin Spectra":
                    if trace_model is not None and 'corrected_spectrum' in locals():

                        try:
                            snr_threshold = float(snr_threshold_str)
                            pixel_scale = float(pixel_scale_str)
                        except Exception:
                            sg.popup ('SNR or pixel scale values not valid!')
                            continue

                        if snr_threshold < 0 or pixel_scale < 0:
                            sg.popup ('SNR and pixel scale values canoot be negative')
                            continue

                        y_correction_trace_position = trace_y_range[0]
                        stm.extract_and_save_snr_spectra(corrected_spectrum, trace_model, header, x_axis, snr_threshold, pixel_scale, file_path_spec_extr, y_correction_trace_position, result_long_slit_extract)


                        #create spectra list of the bins to use with SPAN
                        extracted_filename = os.path.splitext(os.path.basename(file_path_spec_extr))[0]
                        result_longslit_extraction_bins = result_data+'/longslit_extracted/'+extracted_filename+'/bins/'
                        os.makedirs(result_longslit_extraction_bins, exist_ok=True)
                        file_list = stm.get_files_in_folder(result_longslit_extraction_bins)
                        output_file = extracted_filename + '_bins_list.txt'
                        stm.save_to_text_file(file_list, output_file)
                        sg.Popup('Spectra file list of the bins saved in the working directory', output_file, 'You can now browse and load this list file')

                    else:
                        sg.popup_error("Please correct the spectrum and find the spectroscopic trace first.")

                if spec_extr_event == 'Help':
                    f = open(os.path.join(BASE_DIR, "help_files", "help_2d_spec.txt"), 'r')
                    file_contents = f.read()
                    if layout == layout_android:
                        sg.popup_scrolled(file_contents, size=(120, 30))
                    else:
                        sg.popup_scrolled(file_contents, size=(100, 40))

            spec_extr_window.close()



        #********************* CUBE EXTRACTION ***********************

        # Cube extraction
        if event == 'DataCube extraction':

            sg.theme('LightBlue1')

            gist_ifs_layout = [
                [sg.Text('Select a fits cube:', font = ('', default_size, 'bold'), tooltip='Select a datacube WITHIN the inputData folder'), sg.InputText(ifs_input, size=(30, 1), key = 'ifs_input'), sg.FileBrowse(file_types=(('fits file', '*.fits'),)), sg.Button('View datacube', button_color=('black','light blue'), size = (18,1), tooltip='Take a look at the datacube, it may be useful')],
                [sg.Text('Name of the run:', tooltip='Just give a name for this session'), sg.InputText(ifs_run_id, size = (15,1), key = 'ifs_run_id'), sg.Text('z:', tooltip='Redshift estimation. Put zero to not correct for redshift'), sg.InputText(ifs_redshift, size = (8,1), key = 'ifs_redshift'), sg.Text('Wave to extract (nm):', tooltip='Wavelength range you want to extract. Look at the datacube if you do not know'), sg.InputText(ifs_lmin_tot, size = (6,1), key = 'ifs_lmin_tot'), sg.Text('-'), sg.InputText(ifs_lmax_tot, size = (6,1), key = 'ifs_lmax_tot')],

                [sg.HorizontalSeparator()],

                [sg.Radio('Using a pre-loaded routine for extraction:', "RADIOCUBEROUTINE", default = ifs_preloaded_routine, key = 'ifs_preloaded_routine', font = ('', default_size, 'bold'), tooltip='These are pre-loaded routines for reading the most commin datacubes'), sg.InputCombo(ifs_routine_read,key='ifs_routine_read',default_value=ifs_routine_read_default, readonly=True, size = (18,1))],
                [sg.Radio('Using a user defined routine for extraction:', "RADIOCUBEROUTINE", default = ifs_user_routine, key = 'ifs_user_routine', font = ('', default_size, 'bold'), tooltip='Create your .py routine, put in the span_functions/cube_extract_functions folder and type the name here without .py'), sg.InputText(ifs_user_routine_file, size=(15, 1), key = 'ifs_user_routine_file')],
                [sg.Text('Origin (in pixel) of the coordinate systems:', tooltip='Pixel coordinates of the centre or the object you want to study. Look at the datacube to know it'), sg.InputText(ifs_origin, size = (9,1), key = 'ifs_origin')],

                [sg.HorizontalSeparator()],

                [sg.Text('Select a fits mask:', font = ('', default_size, 'bold'), tooltip='If you do not have a mask file, you can create with the button on the right'), sg.InputText(ifs_mask, size=(30, 1), key = 'ifs_mask'), sg.FileBrowse(file_types=(('fits file', '*.fits'),)), sg.Button('Generate mask',button_color=('black','light blue'), size = (18,1), tooltip='Generate a mask, even without really masking any spaxel')],
                [sg.Text('Min S/N to mask:', tooltip='Masking all the spaxels with low S/N'), sg.InputText(ifs_min_snr_mask, size = (6,1), key = 'ifs_min_snr_mask'), sg.Radio('Voronoi bin', "RADIOVOR", default=ifs_voronoi, key='ifs_voronoi', tooltip='Automatic voronoi rebinning'), sg.Text('Target S/N:', tooltip='Select the S/N treshold of the binned spaxels. A good starting value is 30-50'), sg.InputText(ifs_target_snr, size = (5,1), key = 'ifs_target_snr'), sg.Radio('Manual bin', "RADIOVOR", default=ifs_manual_bin, key='ifs_manual_bin', tooltip='Select region(s) to bin. Masking is not applied here'), sg.Button('Manual binning')],

                [sg.HorizontalSeparator()],

                [sg.Button('Preview bins',button_color=('black','light green'), size = (18,1)), sg.Button('Extract!',button_color= ('white','black'), size = (18,1)), sg.Push(), sg.Button('I need help',button_color=('black','orange'), size = (12,1)), sg.Exit(size=(18, 1))],
            ]


            print ('*** Cube extraction routine open. The main panel will be inactive until you close the window ***')
            gist_ifs_window = sg.Window('Cube extraction using GIST standard', gist_ifs_layout)

            while True:

                gist_ifs_event, gist_ifs_values = gist_ifs_window.read()

                if gist_ifs_event == (sg.WIN_CLOSED):
                    print ('Cube extraction routine closed. This main panel is now active again')
                    print ('')
                    break

                #assigning user values
                ifs_run_id = gist_ifs_values['ifs_run_id']
                ifs_input = gist_ifs_values['ifs_input']
                ifs_routine_read_default = gist_ifs_values['ifs_routine_read']
                ifs_origin = gist_ifs_values['ifs_origin']
                ifs_mask = gist_ifs_values['ifs_mask']
                ifs_output_dir = ifs_output + ifs_run_id


                ifs_preloaded_routine = gist_ifs_values['ifs_preloaded_routine']
                ifs_user_routine = gist_ifs_values['ifs_user_routine']
                ifs_user_routine_file = gist_ifs_values['ifs_user_routine_file']

                ifs_manual_bin = gist_ifs_values['ifs_manual_bin']
                ifs_voronoi = gist_ifs_values['ifs_voronoi']

                try:
                    ifs_redshift = float(gist_ifs_values['ifs_redshift'])
                    ifs_lmin_tot = float(gist_ifs_values['ifs_lmin_tot'])
                    ifs_lmax_tot = float(gist_ifs_values['ifs_lmax_tot'])
                    ifs_min_snr_mask = float(gist_ifs_values['ifs_min_snr_mask'])
                    ifs_target_snr = float(gist_ifs_values['ifs_target_snr'])

                    #converting to A
                    ifs_lmin_tot = ifs_lmin_tot*10
                    ifs_lmax_tot = ifs_lmax_tot*10
                    ifs_lmin_snr = ifs_lmin_snr_default*10
                    ifs_lmax_snr = ifs_lmax_snr_default*10

                except Exception:
                    sg.popup ('Invalid input parameters!')
                    continue


                if ifs_user_routine == True:
                    ifs_routine_read_default = ifs_user_routine_file



                if gist_ifs_event == ('Exit'):
                    print ('Cube extraction routine closed. This main panel is now active again')
                    print ('')
                    #reverting to nm:
                    ifs_lmin_tot = ifs_lmin_tot/10
                    ifs_lmax_tot = ifs_lmax_tot/10
                    ifs_lmin_snr = ifs_lmin_snr_default/10
                    ifs_lmax_snr = ifs_lmax_snr_default/10
                    break

                #routine to view the datacube
                if gist_ifs_event == 'View datacube':

                    try:
                        # Load the datacube
                        data, wave = stm.read_datacube(ifs_input)

                        # Create the figure and axes with adjusted layout
                        fig, ax_img = plt.subplots(figsize=(10, 7))
                        plt.subplots_adjust(bottom=0.15,top=0.95)  # Less space for the slider

                        # Display the initial image of the datacube
                        img = ax_img.imshow(data[0], cmap="gray", origin='lower')
                        ax_img.set_title(f"Wavelength Index: {0}", pad=15)

                        # Position the slider just below the main plot
                        ax_slider = plt.axes([0.15, 0.05, 0.7, 0.03], facecolor='lightgoldenrodyellow')
                        slider = Slider(ax_slider, 'Wavelength', wave[0], wave[-1], valinit=wave[0], valfmt='%0.0f')

                        # Update function for the slider
                        def update(val):
                            wave_cube = slider.val
                            closest_index = (np.abs(wave - wave_cube)).argmin()
                            img.set_data(data[closest_index])
                            ax_img.set_title(f'Wavelength: {wave_cube:.2f} Å')
                            fig.canvas.draw_idle()

                        slider.on_changed(update)

                        plt.show()
                        plt.close()

                    except Exception as e:
                        sg.popup('Datacube not found or not valid')
                        continue



                #routine for generating a mask
                if gist_ifs_event == 'Generate mask':

                    # Considering non mobile devices with a keyboard to perform the masking. Using ctrl+click to mask
                    if layout != layout_android:

                        try:
                            ifs_input_mask = ifs_input
                            data, wave = stm.read_datacube(ifs_input_mask)

                            # Preparing the mask and show the first slice of the cube
                            mask = np.zeros(data.shape[1:], dtype=int)
                            fig, (ax_img, ax_slider) = plt.subplots(
                                2, 1, gridspec_kw={'height_ratios': [9, 1]}, figsize=(12, 8)
                            )
                            plt.subplots_adjust(hspace=0.3)  # Slider-image spacing

                            # # Showing the image of the first wavelength value
                            img = ax_img.imshow(data[0], cmap="gray", origin='lower')
                            mask_overlay = ax_img.imshow(
                                np.ma.masked_where(mask == 0, mask),
                                cmap='Reds', alpha=0.5, origin='lower'
                            )
                            ax_img.set_title(f"Wavelength Index: {0}")

                            # Slider for wavelength selection
                            slider = plt.Slider(ax_slider, 'Wavelength Index', 0, data.shape[0] - 1, valinit=0, valfmt='%0.0f')

                            # Instructions on the plot
                            instructions = (
                                "Ctrl + left click: mask a pixel\n"
                                "Ctrl + right click: unmask a pixel\n"
                                "Ctrl + left click and drag: mask an area\n"
                                "Ctrl + right click and drag: unmask an area\n"
                                "Close this window to save the mask"
                            )
                            ax_img.text(1.05, 0.5, instructions, transform=ax_img.transAxes,
                                        fontsize=10, va='center', ha='left', color='blue')

                            # Variables for tracing the selection
                            # global start_point, dragging, deselecting
                            start_point = None
                            dragging = False
                            deselecting = False

                            # Updating the slider
                            def update(val):
                                wavelength_index = int(slider.val)
                                img.set_data(data[wavelength_index])
                                ax_img.set_title(f"Wavelength Index: {wavelength_index}")
                                fig.canvas.draw_idle()

                            slider.on_changed(update)

                            # Functions for selecting and de-selecting the spaxels to mask
                            def on_click(event):
                                global start_point, dragging, deselecting
                                # Ignoring the mask if using the slider
                                if event.inaxes != ax_img:
                                    return

                                # Check if Crtl or Control is pressed
                                if event.key is None or (('control' not in event.key.lower()) and ('ctrl' not in event.key.lower())):
                                    return

                                if event.button == MouseButton.LEFT:  # Ctrl + left click to mask
                                    start_point = (int(event.xdata), int(event.ydata))
                                    dragging = True
                                    deselecting = False
                                elif event.button == MouseButton.RIGHT:  # Ctrl + right click to unmask
                                    start_point = (int(event.xdata), int(event.ydata))
                                    dragging = False
                                    deselecting = True

                            # Dragging functions
                            def on_release(event):
                                global start_point, dragging, deselecting
                                if event.inaxes == ax_img and start_point:
                                    end_point = (int(event.xdata), int(event.ydata))
                                    x0, y0 = start_point
                                    x1, y1 = end_point

                                    if dragging:  # Masking
                                        mask[min(y0, y1):max(y0, y1)+1, min(x0, x1):max(x0, x1)+1] = 1
                                    elif deselecting:  # Unmasking
                                        mask[min(y0, y1):max(y0, y1)+1, min(x0, x1):max(x0, x1)+1] = 0

                                    # Update the figure
                                    mask_overlay.set_data(np.ma.masked_where(mask == 0, mask))
                                    fig.canvas.draw()
                                    start_point = None
                                    dragging = False
                                    deselecting = False

                            fig.canvas.mpl_connect("button_press_event", on_click)
                            fig.canvas.mpl_connect("button_release_event", on_release)
                            plt.show()
                            plt.close()

                            mask_name = "mask_" + ifs_run_id + "_.fits"
                            stm.save_mask_as_fits(mask, result_data + "/" + mask_name)
                            mask_path = result_data + '/' + mask_name
                            sg.popup("Mask saved as ", mask_name, "in ", result_data, " folder and loaded.")

                            #Updating the mask path in the GUI
                            gist_ifs_window['ifs_mask'].update(mask_path)

                        except Exception as e:
                            sg.popup('Fits datacube not valid.')
                            continue



                    # Considering mobile devices without a keyboard to perform the masking. Using simple tap and drag to mask
                    if layout == layout_android:
                        try:
                            ifs_input_mask = ifs_input
                            data, wave = stm.read_datacube(ifs_input_mask)

                            # Preparing the mask and show the first slice of the cube
                            mask = np.zeros(data.shape[1:], dtype=int)
                            fig, (ax_img, ax_slider) = plt.subplots(2, 1, gridspec_kw={'height_ratios': [9, 1]}, figsize=(12, 8))
                            plt.subplots_adjust(hspace=0.3)  # Slider-image spacing

                            # Showing the image of the first wavelength value
                            img = ax_img.imshow(data[0], cmap="gray", origin='lower')
                            mask_overlay = ax_img.imshow(np.ma.masked_where(mask == 0, mask), cmap='Reds', alpha=0.5, origin='lower')
                            ax_img.set_title(f"Wavelength Index: {0}")

                            # Slider for wavelength selection
                            slider = plt.Slider(ax_slider, 'Wavelength Index', 0, data.shape[0] - 1, valinit=0, valfmt='%0.0f')

                            # Instructions on the plot
                            instructions = (
                                "Left click: mask a pixel\n"
                                "Right click: unmask pixel\n"
                                "Left click and drag: mask an area\n"
                                "Right click and drag: unmask an area\n"
                                "Close this window to save the mask"
                            )
                            ax_img.text(1.05, 0.5, instructions, transform=ax_img.transAxes, fontsize=10, va='center', ha='left', color='blue')

                            # Variables for tracing the selection
                            start_point = None
                            dragging = False
                            deselecting = False

                            # Updating the slider
                            def update(val):
                                wavelength_index = int(slider.val)
                                img.set_data(data[wavelength_index])
                                ax_img.set_title(f"Wavelength Index: {wavelength_index}")
                                fig.canvas.draw_idle()

                            slider.on_changed(update)

                            # Functions for selecting and de-selecting the spaxels to mask
                            def on_click(event):
                                global start_point, dragging, deselecting
                                # Ignoring the mask if using the slider
                                if event.inaxes == ax_img:
                                    if event.button == MouseButton.LEFT:  # Left click for masking
                                        start_point = (int(event.xdata), int(event.ydata))
                                        dragging = True
                                        deselecting = False
                                    elif event.button == MouseButton.RIGHT:  # RIght click for unmasking
                                        start_point = (int(event.xdata), int(event.ydata))
                                        dragging = False
                                        deselecting = True

                            # Dragging functions
                            def on_release(event):
                                global start_point, dragging, deselecting
                                if event.inaxes == ax_img and start_point:
                                    end_point = (int(event.xdata), int(event.ydata))
                                    x0, y0 = start_point
                                    x1, y1 = end_point

                                    if dragging:  # dragging with the left mouse click
                                        mask[min(y0, y1):max(y0, y1)+1, min(x0, x1):max(x0, x1)+1] = 1
                                    elif deselecting:  # Dragging with the right mouse click
                                        mask[min(y0, y1):max(y0, y1)+1, min(x0, x1):max(x0, x1)+1] = 0

                                    # Update mask and plot
                                    mask_overlay.set_data(np.ma.masked_where(mask == 0, mask))
                                    fig.canvas.draw()
                                    start_point = None
                                    dragging = False
                                    deselecting = False

                            fig.canvas.mpl_connect("button_press_event", on_click)
                            fig.canvas.mpl_connect("button_release_event", on_release)
                            plt.show()
                            plt.close()

                            mask_name = "mask_"+ifs_run_id+"_.fits"
                            stm.save_mask_as_fits(mask, result_data+"/"+mask_name)
                            mask_path = result_data + '/'+ mask_name
                            sg.popup("Mask saved as ", mask_name, "in ", result_data, " folder and loaded.")

                            #Updating the mask path in the GUI
                            gist_ifs_window['ifs_mask'].update(mask_path)
                        except Exception as e:
                            sg.popup ('Fits datacube not valid.')
                            continue




                # preview mode for voronoi binning
                if gist_ifs_event == 'Preview bins' and ifs_manual_bin == False:

                    # Creating the disctionary to be passed to the cube_extract module
                    config = cubextr.buildConfigFromGUI(
                        ifs_run_id, ifs_input, ifs_output_dir, ifs_redshift, ifs_parallel,
                        ifs_ncpu, ifs_lfs_data_default, ifs_template, ifs_ow_config,
                        ifs_ow_output, ifs_routine_read_default, ifs_debug, ifs_origin,
                        ifs_lmin_tot, ifs_lmax_tot, ifs_lmin_snr, ifs_lmax_snr, ifs_mask_method,
                        ifs_min_snr_mask, ifs_mask, ifs_bin_method, ifs_target_snr,
                        ifs_covariance, ifs_prepare_method)
                    try:
                        cubextr.extract(config, True, True)
                    except Exception as e:
                        sg.popup("Error showing the bins:", str(e))
                        continue



                # Performing manual binning by the user, by selecting one or multiple regions in a matplotlib iterative window
                # Using a modified version of the mask routine above to select the manual binning regions. Then inverting the mask to consider ONLY the selected spaxels.
                if gist_ifs_event == 'Manual binning':

                    #activating the Manual bin option, if not activated
                    gist_ifs_window['ifs_manual_bin'].update(True)

                    try:


                    # Considering non mobile devices with a keyboard to perform the masking. Using ctrl+click to mask
                        if layout != layout_android:

                            ifs_input_mask = ifs_input
                            data, wave = stm.read_datacube(ifs_input_mask)

                            # Preparing the mask and show the first slice of the cube
                            bin_mask = np.zeros(data.shape[1:], dtype=int)
                            fig, (ax_img, ax_slider) = plt.subplots(2, 1, gridspec_kw={'height_ratios': [9, 1]}, figsize=(12, 8))
                            plt.subplots_adjust(hspace=0.3)  # Slider-image spacing

                            # Showing the image of the first wavelength value
                            img = ax_img.imshow(data[0], cmap="gray", origin='lower')
                            bin_mask_overlay = ax_img.imshow(np.ma.masked_where(bin_mask == 0, bin_mask), cmap='Reds', alpha=0.5, origin='lower')
                            ax_img.set_title(f"Wavelength Index: {0}")

                            # Slider for wavelength selection
                            slider = plt.Slider(ax_slider, 'Wavelength Index', 0, data.shape[0] - 1, valinit=0, valfmt='%0.0f')

                            # Instructions on the plot
                            instructions = (
                                "Ctrl + Left click: Select a spaxel\n"
                                "Ctrl + Right click: Deselect a spaxel\n"
                                "Ctrl + Left click and drag: Select an area\n"
                                "Ctrl + Right click and drag: Deselect an area\n"
                                "Ctrl + Close this window to save the work"
                            )
                            ax_img.text(1.05, 0.5, instructions, transform=ax_img.transAxes,
                                        fontsize=10, va='center', ha='left', color='blue')


                            # Variables for tracing the selection
                            start_point = None
                            dragging = False
                            deselecting = False

                            # Updating the slider
                            def update(val):
                                wavelength_index = int(slider.val)
                                img.set_data(data[wavelength_index])
                                ax_img.set_title(f"Wavelength Index: {wavelength_index}")
                                fig.canvas.draw_idle()

                            slider.on_changed(update)

                            # Functions for selecting and de-selecting the spaxels to mask
                            def on_click(event):
                                global start_point, dragging, deselecting
                                # Ignoring the mask if using the slider
                                if event.inaxes != ax_img:
                                    return

                                # Check if Crtl or Control is pressed
                                if event.key is None or (('control' not in event.key.lower()) and ('ctrl' not in event.key.lower())):
                                    return

                                if event.button == MouseButton.LEFT:  # Ctrl + left click to mask
                                    start_point = (int(event.xdata), int(event.ydata))
                                    dragging = True
                                    deselecting = False
                                elif event.button == MouseButton.RIGHT:  # Ctrl + right click to unmask
                                    start_point = (int(event.xdata), int(event.ydata))
                                    dragging = False
                                    deselecting = True

                            # Dragging functions
                            def on_release(event):
                                global start_point, dragging, deselecting
                                if event.inaxes == ax_img and start_point:
                                    end_point = (int(event.xdata), int(event.ydata))
                                    x0, y0 = start_point
                                    x1, y1 = end_point

                                    if dragging:  # Masking
                                        bin_mask[min(y0, y1):max(y0, y1)+1, min(x0, x1):max(x0, x1)+1] = 1
                                    elif deselecting:  # Unmasking
                                        bin_mask[min(y0, y1):max(y0, y1)+1, min(x0, x1):max(x0, x1)+1] = 0

                                    # Update mask and plot
                                    bin_mask_overlay.set_data(np.ma.masked_where(bin_mask == 0, bin_mask))
                                    fig.canvas.draw()
                                    start_point = None
                                    dragging = False
                                    deselecting = False

                            fig.canvas.mpl_connect("button_press_event", on_click)
                            fig.canvas.mpl_connect("button_release_event", on_release)
                            plt.show()
                            plt.close()



                        if layout == layout_android:
                            ifs_input_mask = ifs_input
                            data, wave = stm.read_datacube(ifs_input_mask)

                            # Preparing the mask and show the first slice of the cube
                            bin_mask = np.zeros(data.shape[1:], dtype=int)
                            fig, (ax_img, ax_slider) = plt.subplots(2, 1, gridspec_kw={'height_ratios': [9, 1]}, figsize=(12, 8))
                            plt.subplots_adjust(hspace=0.3)  # Slider-image spacing

                            # Showing the image of the first wavelength value
                            img = ax_img.imshow(data[0], cmap="gray", origin='lower')
                            bin_mask_overlay = ax_img.imshow(np.ma.masked_where(bin_mask == 0, bin_mask), cmap='Reds', alpha=0.5, origin='lower')
                            ax_img.set_title(f"Wavelength Index: {0}")

                            # Slider for wavelength selection
                            slider = plt.Slider(ax_slider, 'Wavelength Index', 0, data.shape[0] - 1, valinit=0, valfmt='%0.0f')

                            # Instructions on the plot
                            instructions = (
                                "Left click: Select a spaxel\n"
                                "Right click: Deselect a spaxel\n"
                                "Left click and drag: Select an area\n"
                                "Right click and drag: Deselect an area\n"
                                "Close this window to save the work"
                            )
                            ax_img.text(1.05, 0.5, instructions, transform=ax_img.transAxes, fontsize=10, va='center', ha='left', color='blue')

                            # Variables for tracing the selection
                            start_point = None
                            dragging = False
                            deselecting = False

                            # Updating the slider
                            def update(val):
                                wavelength_index = int(slider.val)
                                img.set_data(data[wavelength_index])
                                ax_img.set_title(f"Wavelength Index: {wavelength_index}")
                                fig.canvas.draw_idle()

                            slider.on_changed(update)

                            # Functions for selecting and de-selecting the spaxels to mask
                            def on_click(event):
                                global start_point, dragging, deselecting
                                # Ignoring the mask if using the slider
                                if event.inaxes == ax_img:
                                    if event.button == MouseButton.LEFT:  # Left click for masking
                                        start_point = (int(event.xdata), int(event.ydata))
                                        dragging = True
                                        deselecting = False
                                    elif event.button == MouseButton.RIGHT:  # RIght click for unmasking
                                        start_point = (int(event.xdata), int(event.ydata))
                                        dragging = False
                                        deselecting = True

                            def on_release(event):
                                global start_point, dragging, deselecting
                                if event.inaxes == ax_img and start_point:
                                    end_point = (int(event.xdata), int(event.ydata))
                                    x0, y0 = start_point
                                    x1, y1 = end_point

                                    if dragging:  # dragging with the left mouse click
                                        bin_mask[min(y0, y1):max(y0, y1)+1, min(x0, x1):max(x0, x1)+1] = 1
                                    elif deselecting:  # Dragging with the right mouse click
                                        bin_mask[min(y0, y1):max(y0, y1)+1, min(x0, x1):max(x0, x1)+1] = 0

                                    # Update mask and plot
                                    bin_mask_overlay.set_data(np.ma.masked_where(bin_mask == 0, bin_mask))
                                    fig.canvas.draw()
                                    start_point = None
                                    dragging = False
                                    deselecting = False

                            fig.canvas.mpl_connect("button_press_event", on_click)
                            fig.canvas.mpl_connect("button_release_event", on_release)
                            plt.show()
                            plt.close()


                        #DOING THE MAGIC: Finding all the contigous selected spaxels, assign an integer flag for each region selected by the user.
                        labeled_mask = label(bin_mask, connectivity=1)

                        #inverting the mask: the selected regions will be the active regions to bin
                        bin_mask = 1 - bin_mask

                        #saving the masked regions
                        bin_mask_name = "bin_mask2D_"+ifs_run_id+"_.fits"
                        stm.save_mask_as_fits(bin_mask, result_data+"/"+bin_mask_name)
                        bin_mask_path = result_data + '/'+ bin_mask_name

                        #This function is used to check if the manual binning goes smooth. Use as test if you want
                        # def save_labeled_mask_as_fits(labeled_mask, output_filename):
                        #     primary_hdu = fits.PrimaryHDU(np.zeros((1, 1), dtype=np.int32))
                        #     labeled_hdu = fits.ImageHDU(labeled_mask.astype(np.int32))
                        #     labeled_hdu.header['EXTNAME'] = 'LABELED_MASK'
                        #     hdul = fits.HDUList([primary_hdu, labeled_hdu])
                        #     hdul.writeto(output_filename, overwrite=True)
                        #     print(f"Labeled mask saved as {output_filename}")


                        # saving the spaxels and manual bin info in a txt file and store in the array.
                        def save_mask_regions_txt(labeled_mask, output_filename):
                            """
                            - If labeled_mask[y,x] == 0 → label = -1 (not selected)
                            - Otherwise label = labeled_mask[y,x]
                            """
                            rows, cols = labeled_mask.shape

                            # Prepare a list to store the values (y, x, label)
                            mask_labels_list = []

                            with open(output_filename, "w") as f:
                                f.write("# y\tx\tregion_label\n")
                                for y in range(rows):
                                    for x in range(cols):
                                        lbl = labeled_mask[y, x]
                                        region_label = lbl if lbl != 0 else -1
                                        # Saving the text file
                                        f.write(f"{y}\t{x}\t{region_label}\n")
                                        # Fill the list
                                        mask_labels_list.append([y, x, region_label])

                            # Converting the list to numpy and return it
                            mask_labels = np.array(mask_labels_list, dtype=int)
                            return mask_labels

                        #activate this function to save a fit with the manual binned regions highlighted
                        #save_labeled_mask_as_fits(labeled_mask, result_data + "/" + labeled_mask_name)

                        # Generating the text file with all spaxel info:
                        txt_filename = f"mask_regions_{ifs_run_id}.txt"
                        mask_labels = save_mask_regions_txt(labeled_mask, result_data + "/" + txt_filename)

                        sg.Popup("Manual binned regions computed. Now click 'Extract!' to extract the binned spectra")

                    except Exception as e:
                        sg.Popup('Sorry, manual binning has failed and I do not know why. Maybe the datacube does not exist?')
                        continue


                # preview mode for the manual binning: reading the datacube and showing the S/N of the spaxels contained in the selected regions
                if gist_ifs_event == 'Preview bins' and ifs_manual_bin == True:
                    ifs_min_snr_mask_bin = 0 #No S/N cut
                    ifs_bin_method_manual = 'False' #No voronoi binning
                    voronoi_bin = False #No voronoi binning
                    ifs_target_snr_manual = 0
                    ifs_covariance_manual = 0

                    # 2) extracting the label column of all the spaxels with the bin_info of the selected manual regions
                    try:

                        # Creating the dictionary to be passed to the cube_extract module
                        config_manual = cubextr.buildConfigFromGUI(
                            ifs_run_id, ifs_input, ifs_output_dir, ifs_redshift, ifs_parallel,
                            ifs_ncpu, ifs_lfs_data_default, ifs_template, ifs_ow_config,
                            ifs_ow_output, ifs_routine_read_default, ifs_debug, ifs_origin,
                            ifs_lmin_tot, ifs_lmax_tot, ifs_lmin_snr, ifs_lmax_snr, ifs_mask_method,
                            ifs_min_snr_mask_bin, bin_mask_path, ifs_bin_method_manual, ifs_target_snr_manual,
                            ifs_covariance_manual, ifs_prepare_method)
                        try:
                            cubextr.extract(config_manual, True, voronoi_bin)
                        except Exception as e:
                            sg.popup("Sorry, Error.", str(e))
                            continue

                    except Exception as e:
                        sg.Popup('You first need to define the regions to be binned!\nOtherwise Select the Voronoi rebinning to automatically rebin the data')
                        continue


                # NOW WE HAVE THE MAP WITH THE LABELED SPAXELS. Negative labels means spaxels not selected, therefore not considered. Positive labels identify the spaxels to consider for binning. Contiguous regions are marked with the same identifier (e.g. 1). This map has been stretched to 1D following the same order that the cubextr stores the spaxel infos in the _table.fit file. Now we need to generate the _table.fit file without any rebinning in order to have the BIN_ID of each spaxel, then we replace the BIN_ID array of the file with the bin info stored in the third component of the mask_labels array.

                # now we apply yhe manual bin by running the cube_extract_module in two steps
                if gist_ifs_event == 'Extract!': #and ifs_manual_bin == True:

                    if ifs_manual_bin == True:
                    # 1) RUNNING cubextract in preview mode without any rebinning to to extract the info of the spaxels stored in the _table.fits file.
                        ifs_min_snr_mask_bin = 0 #No S/N cut
                        ifs_bin_method_manual = 'False'
                        voronoi_bin = False #No voronoi binning
                        ifs_target_snr_manual = 0
                        ifs_covariance_manual = 0

                    # 2) extracting the label column of all the spaxels with the bin_info of the selected manual regions
                        try:
                            region_labels = mask_labels[:, 2].copy() #creating a copy, otherwise if exectuted more than one time is erodes the bin number
                            #Starting from BIN_ID zero and not one!
                            region_labels[region_labels > 0] -= 1
                        except Exception as e:
                            sg.Popup('You first need to define the regions to be binned!\nOtherwise Select the Voronoi rebinning to automatically rebin the data')
                            continue

                        # Creating the dictionary to be passed to the cube_extract module
                        config_manual = cubextr.buildConfigFromGUI(
                            ifs_run_id, ifs_input, ifs_output_dir, ifs_redshift, ifs_parallel,
                            ifs_ncpu, ifs_lfs_data_default, ifs_template, ifs_ow_config,
                            ifs_ow_output, ifs_routine_read_default, ifs_debug, ifs_origin,
                            ifs_lmin_tot, ifs_lmax_tot, ifs_lmin_snr, ifs_lmax_snr, ifs_mask_method,
                            ifs_min_snr_mask_bin, bin_mask_path, ifs_bin_method_manual, ifs_target_snr_manual,
                            ifs_covariance_manual, ifs_prepare_method)
                        try:
                            #running the cubextract module to produce the spaxel and BIN_ID map
                            cubextr.extract(config_manual, True, voronoi_bin)
                        except Exception as e:
                            sg.popup("Error! Cannot show the bins", str(e))
                            continue


                        #3) REPLACE THE BIN_INFO IN THE _TABLE.FITS WITH THE LABELLED VALUES STORED IN region_labels
                        #Loading the _table.fits file with the BIN_ID info
                        fits_table_path = root_spectra_file = result_data+'/'+ifs_run_id+'/'+ifs_run_id+'_table.fits'

                        with fits.open(fits_table_path, mode="update") as hdul:
                            data_table = hdul[1].data

                            # For some reson if the length of the labelled length array does not match the number of spaxels in the _table.fits:
                            if len(data_table) != len(region_labels):
                                raise ValueError("Mismatch size between the labelled spaxels list and the actual spaxel list in the _table.fits file")

                            # Replace the BIN_ID column of the _table.fits file
                            data_table['BIN_ID'] = region_labels

                            # Save the fits
                            hdul.flush()


                        # 4) Now calculate the mean position and SNR of the spaxels to be binned
                        with fits.open(fits_table_path, mode='update') as hdul:
                            data_hdu = hdul[1]
                            #Converting in astropy table for better handling
                            tbl = Table(data_hdu.data)

                            # Only spaxels used to binning
                            valid_mask = (tbl['BIN_ID'] >= 0)
                            unique_bins = np.unique(tbl['BIN_ID'][valid_mask])

                            # Scanning the bins and calculating the new values
                            for b in unique_bins:
                                region_mask = (tbl['BIN_ID'] == b)

                                #Mean (NOT weighted) position of the bins
                                mean_x = np.mean(tbl['X'][region_mask])
                                mean_y = np.mean(tbl['Y'][region_mask])

                                # Spaxel number to be binned
                                n_spax = np.count_nonzero(region_mask)

                                #Calculate the S/N of the bins
                                flux_i = tbl['FLUX'][region_mask]
                                sn_i   = tbl['SNR'][region_mask]
                                S_total = np.sum(flux_i)
                                noise_i = flux_i / sn_i
                                noise_quad_sum = np.sum(noise_i**2)
                                SNR_bin = S_total / np.sqrt(noise_quad_sum)

                                # Updating the value of the columns
                                tbl['XBIN'][region_mask]    = mean_x
                                tbl['YBIN'][region_mask]    = mean_y
                                tbl['NSPAX'][region_mask]   = n_spax
                                tbl['SNRBIN'][region_mask]  = SNR_bin

                            #Updating the _table.fits file
                            hdul[1].data = tbl.as_array()
                            hdul.flush()


                        # 5) perform cubextr again, starting from the updated _table.fits file to perform the binning. Now cubextr will read the BIN_ID column in the fits file and bin all the spectra with the same BIN_ID. Storing the spectra also in 1D single spectra SPAN ready.
                        try:
                            cubextr.extract(config_manual, False, True)
                        except Exception as e:
                            sg.Popup ('ERROR performing the extraction')
                            continue


                    # With voronoi rebinning things are earier:
                    if ifs_manual_bin == False:

                    # Creating the dictionary to be passed to the cube_extract module
                        config = cubextr.buildConfigFromGUI(
                            ifs_run_id, ifs_input, ifs_output_dir, ifs_redshift, ifs_parallel,
                            ifs_ncpu, ifs_lfs_data_default, ifs_template, ifs_ow_config,
                            ifs_ow_output, ifs_routine_read_default, ifs_debug, ifs_origin,
                            ifs_lmin_tot, ifs_lmax_tot, ifs_lmin_snr, ifs_lmax_snr, ifs_mask_method,
                            ifs_min_snr_mask, ifs_mask, ifs_bin_method, ifs_target_snr,
                            ifs_covariance, ifs_prepare_method
            )


                        print ('This might take a while. Please, relax...')

                        try:
                            #calling the cube_extraction routine
                            cubextr.extract(config, False, True)
                        except Exception as e:
                            sg.Popup ('ERROR performing the extraction')
                            continue


                    #extracting the bin positions infos and saving in a txt file and in lists
                    root_spectra_file_bin_info = result_data+'/'+ifs_run_id+'/'+ifs_run_id+'_table.fits'
                    output_file_bin_data = result_data+'/'+ifs_run_id+'/'+ifs_run_id+'_bin_info.txt'

                    try:
                        with fits.open(root_spectra_file_bin_info) as hdul:
                            tbl = Table(hdul[1].data)
                    except Exception as e:
                        sg.Popup('Cannot read the datacube')
                        continue

                    # Select only binned spaxels
                    valid_mask = (tbl['BIN_ID'] >= 0)
                    unique_bins = np.unique(tbl['BIN_ID'][valid_mask])

                    bin_id_array = []
                    bin_x_array = []
                    bin_y_array = []

                    with open(output_file_bin_data, "w") as f:
                        # Header
                        f.write("#BIN_ID BIN_NUMBER XBIN YBIN SNRBIN NSPAX\n")

                        # For all the bins
                        for b in unique_bins:
                            region_mask = (tbl['BIN_ID'] == b)

                            # Taking the first index of the binned regions
                            idx_first = np.where(region_mask)[0][0]

                            bin_number = b + 1

                            # Extracting the values
                            bin_id   = b
                            bin_x    = tbl['XBIN'][idx_first]
                            bin_y    = tbl['YBIN'][idx_first]
                            bin_snr  = tbl['SNRBIN'][idx_first]
                            bin_nspx = tbl['NSPAX'][idx_first]

                            #Storing the interesting values in a list to be used later
                            bin_id_array.append(bin_id)
                            bin_x_array.append(bin_x)
                            bin_y_array.append(bin_y)

                            # writing to a file
                            f.write(f"{bin_id} {bin_number} {bin_x} {bin_y} {bin_snr} {bin_nspx}\n")

                    print("Text file written with BIN info:", output_file_bin_data)


                    #saving the extracted spectra also in single fits files SPAN-ready
                    root_spectra_file = result_data+'/'+ifs_run_id+'/'+ifs_run_id+'_BinSpectra_linear.fits'
                    hdul = fits.open(root_spectra_file)
                    data_flux = hdul[1].data['SPEC']
                    data_variance = hdul[1].data['ESPEC']
                    wavelengths = hdul[2].data['WAVE']

                    #creating the subdirectoy to store the single bins spectra
                    single_bins_dir = result_data+'/'+ifs_run_id+'/bins'
                    os.makedirs(single_bins_dir, exist_ok=True)

                    #saving the spectra
                    # writing the single spectra with 'BIN_ID' in the filename
                    try:
                        for i in range(data_flux.shape[0]):
                            flux = data_flux[i]
                            variance = data_variance[i]
                            t = Table([wavelengths, flux, variance], names=('wavelength', 'flux', 'variance'))

                            # Primary HDU and keywords
                            primary_hdu = fits.PrimaryHDU()
                            primary_hdu.header['BIN_ID'] = bin_id_array[i]
                            primary_hdu.header['X'] = bin_x_array[i]
                            primary_hdu.header['Y'] = bin_y_array[i]

                            # Creating bintable to store the data
                            table_hdu = fits.BinTableHDU(t)

                            # Craring the HDU
                            hdulist = fits.HDUList([primary_hdu, table_hdu])
                            filename = f"{single_bins_dir}/{ifs_run_id}_bin_id_{i:03}.fits"
                            hdulist.writeto(filename, overwrite=True)
                    except Exception as e:
                        sg.Popup('Results already presenti in the folder. Please, change the run_id name and try again')
                        continue

                    print('Single binned spectra saved in:', single_bins_dir, 'Wavelength units: A')

                    #closing the fits file _BinSpectra_linear.
                    hdul.close()

                    #create spectra list of the bins to use with SPAN
                    folder_path = single_bins_dir
                    if folder_path:
                        file_list = stm.get_files_in_folder(folder_path)
                        output_file = ifs_run_id + '_bins_list.txt'
                        stm.save_to_text_file(file_list, output_file)
                        sg.Popup('Spectra file list of the bins saved in the working directory', output_file, 'You can now browse and load this list file\n\nWARNING: change the name of the run to process again')


                #showing the help file
                if gist_ifs_event == 'I need help':
                    f = open(os.path.join(BASE_DIR, "help_files", "help_3d_spec.txt"), 'r')
                    file_contents = f.read()
                    if layout == layout_android:
                        sg.popup_scrolled(file_contents, size=(120, 30))
                    else:
                        sg.popup_scrolled(file_contents, size=(100, 40))


                #reverting to nm:
                ifs_lmin_tot = ifs_lmin_tot/10
                ifs_lmax_tot = ifs_lmax_tot/10
                ifs_lmin_snr = ifs_lmin_snr_default/10
                ifs_lmax_snr = ifs_lmax_snr_default/10

            gist_ifs_window.close()



        #******************simple text editor**********************
        if event == 'Text editor':
            print('***** Text editor open. The main panel will be inactive until you close the editor *****')

            sg.theme('DarkBlue3')

            if layout == layout_android:
                editor_layout = [
                    [sg.Multiline(size=(120, 20), key='-TEXT-', font=('Helvetica', 12))],
                    [sg.Button('Open', key='-OPEN-', size = (15,1), font=('Helvetica', 12), button_color=('black','light green')), sg.Button('Save', key='-SAVE-', size = (15,1), font=('Helvetica', 12)),  sg.Button('Find', size = (15,1), font=('Helvetica', 12)), sg.Button('Undo', size = (15,1), font=('Helvetica', 12)) ],
                    [sg.Button('Find/Replace', size = (15,1), font=('Helvetica', 12)), sg.Button('Match rows', size = (15,1), font=('Helvetica', 12)), sg.Button('Create New Column', size = (15,1), font=('Helvetica', 12)), sg.Button('Delete Columns', size = (15,1), font=('Helvetica', 12)), sg.Push(), sg.Button('Close', button_color=('white','orange'), size = (15,1), font=('Helvetica', 12, 'bold'))]
                ]
            else:
                editor_layout = [
                    [sg.Multiline(size=(90, 30), key='-TEXT-', font=('Helvetica', 12))],
                    [sg.Button('Open', key='-OPEN-', size = (15,1), font=('Helvetica', 12), button_color=('black','light green')), sg.Button('Save', key='-SAVE-', size = (15,1), font=('Helvetica', 12)),  sg.Button('Find', size = (15,1), font=('Helvetica', 12)), sg.Button('Undo', size = (15,1), font=('Helvetica', 12)) ],
                    [sg.Button('Find/Replace', size = (15,1), font=('Helvetica', 12)), sg.Button('Match rows', size = (15,1), font=('Helvetica', 12)), sg.Button('Create New Column', size = (15,1), font=('Helvetica', 12)), sg.Button('Delete Columns', size = (15,1), font=('Helvetica', 12)), sg.Push(), sg.Button('Close', button_color=('white','orange'), size = (15,1), font=('Helvetica', 12, 'bold'))]
                ]

            window_editor = sg.Window('Text editor', editor_layout)
            file_modified = False
            text_backup = ""

            while True:
                editor_event, editor_values = window_editor.read()

                if editor_event == sg.WIN_CLOSED or editor_event == 'Close':
                    if file_modified:
                        confirm_close = sg.popup_yes_no(
                            'Changes have not been saved. Are you sure you want to close?', 'Close')
                        if confirm_close == 'Yes':
                            print('Text editor closed. This main panel is now active again')
                            print('')
                            break
                    else:
                        print('Text editor closed. This main panel is now active again')
                        print('')
                        break
                elif editor_event == '-SAVE-':
                    text = editor_values['-TEXT-']
                    filename = sg.popup_get_file('Save the file', save_as=True, default_extension=".txt")
                    if filename:
                        stm.save_file(filename, text)
                        sg.popup(f'The file {filename} has been saved.')
                        file_modified = False  # Reset the modification flag
                elif editor_event == '-OPEN-':
                    if file_modified:
                        confirm_open = sg.popup_yes_no(
                            'Changes have not been saved. Are you sure you want to open a new file?', 'Open')
                        if confirm_open == 'No':
                            continue
                    filename = sg.popup_get_file('Open file', default_extension=".txt")
                    if filename:
                        with open(filename, 'r') as file:
                            try:
                                text = file.read()
                                text_backup = text  # Backup the original text
                            except UnicodeDecodeError:
                                sg.popup('Invalid file. I just read simple txt files!')
                                continue
                        window_editor['-TEXT-'].update(text)
                        file_modified = False  # Reset the modification flag
                elif editor_event == 'Find':
                    find_text = sg.popup_get_text('Enter text to find:')
                    if find_text:
                        text_to_search = editor_values['-TEXT-']
                        if find_text in text_to_search:
                            sg.popup(f'Text found at position: {text_to_search.find(find_text)}')
                        else:
                            sg.popup('Text not found.')
                elif editor_event == 'Find/Replace':
                    find_text = sg.popup_get_text('Enter text to find:')
                    if find_text:
                        replace_text = sg.popup_get_text('Enter text to replace with:')
                        if replace_text is not None:
                            replace_all = sg.popup_yes_no('Replace all occurrences?', 'Replace All')
                            if replace_all == 'Yes':
                                text_to_search = editor_values['-TEXT-']
                                updated_text = stm.find_replace(text_to_search, find_text, replace_text, replace_all)
                                window_editor['-TEXT-'].update(updated_text)
                                file_modified = True  # Set the modification flag
                elif editor_event == 'Match rows':
                    sg.theme('DarkBlue3')

                    match_layout = [
                        [sg.Text('Select the first file:'), sg.InputText(key='-FILE1-', readonly=True),
                            sg.FileBrowse(file_types=(("Text Files", "*.*"),))],
                        [sg.Text('Select the second file:'), sg.InputText(key='-FILE2-', readonly=True),
                            sg.FileBrowse(file_types=(("Text Files", "*.*"),))],
                        [sg.Text('Select the common column:'), sg.InputText(key='-COMMON_COLUMN-')],
                        [sg.Button('Merge'), sg.Button('Exit')]
                    ]

                    match_window = sg.Window('Match and merge rows', match_layout)

                    while True:
                        match_event, match_values = match_window.read()

                        if match_event == sg.WIN_CLOSED or match_event == 'Exit':
                            break
                        elif match_event == 'Merge':
                            file1_path = match_values['-FILE1-']
                            file2_path = match_values['-FILE2-']
                            common_column = match_values['-COMMON_COLUMN-']

                            if file1_path and file2_path and common_column:
                                stm.merge_files(file1_path, file2_path, common_column)
                            else:
                                sg.popup_error('Please select both files and enter a common column.')

                    match_window.close()
                elif editor_event == 'Create New Column':
                    new_column_name = sg.popup_get_text('Enter the name for the new column:')
                    if new_column_name:
                        col1_name = sg.popup_get_text('Enter the name of the first column:')
                        col2_name = sg.popup_get_text('Enter the name of the second column:')
                        expression = sg.popup_get_text('Enter the algebraic expression (e.g., col1 + col2):')
                        if col1_name and col2_name and expression:
                            try:
                                df = pd.read_csv(io.StringIO(editor_values['-TEXT-']), delimiter=r'\s+')

                                col1_name_clean = col1_name.replace(' ', '_')
                                col2_name_clean = col2_name.replace(' ', '_')

                                df = stm.create_new_column(df, new_column_name, col1_name_clean, col2_name_clean, expression)

                                if df is not None:
                                    window_editor['-TEXT-'].update(df.to_csv(index=False, sep=' ', na_rep=''))
                                    file_modified = True  # Set the modification flag
                            except Exception as e:
                                sg.popup_error(f'Error creating the new column: {str(e)}')
                        else:
                            sg.popup_error('Please enter names for both columns and the algebraic expression.')

                elif editor_event == 'Delete Columns':
                    columns_to_delete = sg.popup_get_text(
                        'Enter column names to delete (comma-separated):')
                    if columns_to_delete:
                        try:
                            df = pd.read_csv(io.StringIO(editor_values['-TEXT-']), delimiter=r'\s+')
                            columns_to_delete_list = [col.strip() for col in columns_to_delete.split(',')]
                            df = df.drop(columns=columns_to_delete_list, errors='ignore')
                            window_editor['-TEXT-'].update(df.to_csv(index=False, sep=' ', na_rep=''))
                            file_modified = True  # Set the modification flag
                        except Exception as e:
                            sg.popup_error(f'Error deleting columns: {str(e)}')


                elif editor_event == 'Undo':
                    # Ripristina il testo alla sua versione precedente
                    window_editor['-TEXT-'].update(text_backup)
                    file_modified = True  # Imposta il flag di modifica
                elif editor_event == '-TEXT-':
                    # Aggiorna il backup del testo quando viene modificato
                    text_backup = editor_values['-TEXT-']
                    file_modified = True  # Imposta il flag di modifica


            window_editor.close()




        #*********************** FITS HEADER EDITOR *******************************************
        if event == 'FITS header editor':
            sg.theme('DarkBlue3')
            fitsheader_layout = [
                [sg.Text('Please, select what operation you want to perform on the header of the fits file(s)')],
                [sg.Button('Single fits header editor',button_color= ('black','orange'), size = (22,2), key ='hdr_single_file'), sg.Button('List of fits header editor',button_color= ('black','orange'), size = (22,2), key ='hdr_list_file'), sg.Button('Extract keyword from a list',button_color= ('black','orange'), size = (22,2), key ='extract_keyword')],
                [sg.Button('Close')]
                ]

            print ('*** Fits header editor open. The main panel will be inactive until you close the window ***')
            fitsheader_window = sg.Window('Fits header editor', fitsheader_layout)

            while True:

                fitsheader_event, fitsheader_values = fitsheader_window.read()

                if fitsheader_event == sg.WIN_CLOSED or fitsheader_event == 'Close':
                    print ('Fits editor closed. This main panel is now active again')
                    print ('')
                    break

                #modify/add/delete keyword for a single fits
                if fitsheader_event == 'hdr_single_file':
                    sg.theme('DarkBlue3')
                    subfitsheader_layout = [
                        [sg.Text("Select a FITS file")],
                        [sg.Input(key='-FILE-', enable_events=True), sg.FileBrowse()],
                        [sg.Multiline(key='-HEADER-', size=(60, 15), disabled=True)],
                        [sg.Text("Modify/Add Keyword"),
                        sg.Input(key='-KEY-', size=(20, 1)),
                        sg.Input(key='-VALUE-', size=(20, 1)),
                        sg.Checkbox("Numerical value", key='-NUMERIC-', enable_events=True),
                        sg.Button("Add/Modify"), sg.Button("Delete")],  # Added "Delete" button
                        [sg.Button("Save Header"), sg.Button("Exit")]
                    ]

                    subfitsheader_window = sg.Window("Single FITS header editor", subfitsheader_layout)

                    while True:
                        subfitsheader_event, subfitsheader_values = subfitsheader_window.read()

                        if subfitsheader_event == sg.WINDOW_CLOSED or subfitsheader_event == 'Exit':
                            break

                        if subfitsheader_event == '-FILE-':
                            file_path = subfitsheader_values['-FILE-']
                            header = stm.read_fits_header(file_path)
                            subfitsheader_window['-HEADER-'].update(repr(header))

                        if subfitsheader_event == 'Add/Modify':
                            key = subfitsheader_values['-KEY-']
                            value = subfitsheader_values['-VALUE-']
                            is_numeric = subfitsheader_values['-NUMERIC-']

                            if key:
                                if is_numeric:
                                    try:
                                        value = float(value)
                                    except ValueError:
                                        sg.popup_error("Vale must be a number")
                                        continue

                                header[key] = value
                                subfitsheader_window['-HEADER-'].update(repr(header))

                        if subfitsheader_event == 'Delete':
                            key_to_delete = subfitsheader_values['-KEY-']
                            if key_to_delete:
                                delete_result = stm.delete_keyword(header, key_to_delete)
                                if delete_result is True:
                                    subfitsheader_window['-HEADER-'].update(repr(header))
                                else:
                                    sg.popup_error(f"Error during deletion: {delete_result}")


                        if subfitsheader_event == 'Save Header':
                            if 'file_path' in locals():
                                save_result = stm.save_fits_header(file_path, header)
                                if save_result is True:
                                    sg.popup("Header saved with succes!")
                                else:
                                    sg.popup_error(f"Error during the saving of the header: {save_result}")
                            else:
                                sg.popup_error("First select a FITS file.")

                    subfitsheader_window.close()


                if fitsheader_event == 'hdr_list_file':
                    sg.theme('DarkBlue3')

                    hdr_list_layout = [
                        [sg.Text("Select a list containing only FITS files")],
                        [sg.Input(key='-FILELIST-', enable_events=True), sg.FileBrowse()],
                        [sg.Text("Select a list containing the keyword you want to change (format: key=value=type)"), sg.Input(key='-KEYFILE-', enable_events=True), sg.FileBrowse()],
                        [sg.Multiline(key='-HEADER-', size=(60, 15), disabled=True)],
                        [sg.Button("Add/Modify"), sg.Button("Delete"), sg.Button("Exit")]
                    ]

                    hdr_list_window = sg.Window("FITS header editor", hdr_list_layout)

                    while True:
                        hdr_list_event, hdr_list_values = hdr_list_window.read()

                        if hdr_list_event == sg.WINDOW_CLOSED or hdr_list_event == 'Exit':
                            break

                        if hdr_list_event == '-FILELIST-':
                            file_list_path = hdr_list_values['-FILELIST-']

                        if hdr_list_event == '-KEYFILE-':
                            key_file_path = hdr_list_values['-KEYFILE-']
                        try:
                            if hdr_list_event == 'Add/Modify':
                                if not file_list_path or not key_file_path:
                                    sg.popup_error("Something is wrong. Check the files")
                                    continue

                                file_paths = stm.read_file_list(file_list_path)
                                if not file_paths:
                                    sg.popup_error("Something is wrong. Check the files")
                                    continue

                                try:
                                    key_paths = stm.read_file_list(key_file_path)
                                    key_name, key_value = stm.read_keyword_values_from_file(key_file_path)
                                except ValueError:
                                    sg.popup_error('The keyword file is not correct. Chek it!')
                                    continue

                                if len(file_paths) != len(key_paths):
                                    sg.popup ('The length of the fits file is different from the length of the key file, or you just loaded wrong files. Try again')
                                    continue

                                cond = 0

                                try:
                                    for i in range (len(file_paths)):
                                        with fits.open(file_paths[i], mode='update') as hdul:
                                        # Aggiungi la keyword all'header del primo HDU (Header Data Unit)
                                            hdul[0].header[key_name[i]] = (key_value[i])

                                        # Salva le modifiche
                                            hdul.flush()

                                        cond = cond +1
                                        hdr = hdul[0].header

                                        hdr_list_window['-HEADER-'].update(repr(hdr))

                                except (AttributeError, ValueError):
                                    sg.popup_error('Something is wrong. Check and try again')

                                sg.popup('Successfully modified headers: ', cond, '/', len(file_paths))
                        except Exception:
                            sg.popup('File missing')
                            continue

                        try:
                            if hdr_list_event == 'Delete':
                                file_paths = stm.read_file_list(file_list_path)
                                key_to_delete = sg.popup_get_text("Enter the keyword to delete:")
                                if key_to_delete:
                                    cond = 0
                                    try:
                                        for i in range(len(file_paths)):
                                            try:
                                                with fits.open(file_paths[i], mode='update') as hdul:
                                                    # Aggiungi la keyword all'header del primo HDU (Header Data Unit)
                                                    header = hdul[0].header
                                                    header.remove(key_to_delete)
                                                    # Salva le modifiche
                                                    hdul.flush()

                                                cond = cond + 1
                                                hdr = hdul[0].header
                                            except KeyError:
                                                print ('Keyword not found')
                                                continue

                                            hdr_list_window['-HEADER-'].update(repr(hdr))
                                    except FileNotFoundError:
                                        sg.popup ('Incorrect file or missing')
                                        continue
                                    if cond > 0:
                                        sg.popup(f'Successfully deleted keyword "{key_to_delete}" from headers: {cond}/{len(file_paths)}')
                                    else:
                                        sg.popup ('Keyword not found')
                        except NameError:
                            sg.popup ('No file to process!')
                            continue
                    hdr_list_window.close()


                if fitsheader_event == 'extract_keyword':

                    sg.theme('DarkBlue3')

                    ext_key_layout = [
                        [sg.Text("Select a list of FITS files")],
                        [sg.Input(key='-FILELIST-', enable_events=True), sg.FileBrowse()],
                        [sg.Text("Insert the keyword to extract (case insensitive)"), sg.Input(key='-KEYWORD-')],
                        [sg.Multiline(key='-OUTPUT-', size=(60, 15), disabled=True)],
                        [sg.Button("Extract and Save"), sg.Button("Exit")]
                    ]

                    ext_key_window = sg.Window("Extract and Save Keyword", ext_key_layout)

                    while True:
                        ext_key_event, ext_key_values = ext_key_window.read()

                        if ext_key_event == sg.WINDOW_CLOSED or ext_key_event == 'Exit':
                            break

                        if ext_key_event == '-FILELIST-':
                            file_list_path = ext_key_values['-FILELIST-']

                        try:
                            if ext_key_event == 'Extract and Save':
                                if not file_list_path:
                                    sg.popup_error("Select a list of FITS files with relative path included.")
                                    continue

                                keyword = ext_key_values['-KEYWORD-'].strip()
                                if not keyword:
                                    sg.popup_error("Insert the keyword you want to extract")
                                    continue
                                try:
                                    file_paths = [line.strip() for line in open(file_list_path) if not line.startswith('#')]
                                    data = []
                                except Exception:
                                    sg.popup ('Problems with the fits list file. Chek it, please')
                                    continue

                                for file_path in file_paths:
                                    file_path = file_path.strip()
                                    value = stm.extract_keyword(file_path, keyword)
                                    data.append({'file': file_path, 'keyword': keyword, 'value': value})

                                ext_key_window['-OUTPUT-'].update('')
                                for entry in data:
                                    ext_key_window['-OUTPUT-'].print(f"{entry['file']} - {entry['keyword']}: {entry['value']}")

                                output_file = sg.popup_get_file('Save on file', save_as=True, file_types=(("Text Files", "*.txt"),))
                                if output_file:
                                    stm.save_to_text_file(data, output_file)
                                    sg.popup(f"Results saved on: '{output_file}'")
                        except NameError:
                            sg.popup ('File not found!')
                            continue


                    ext_key_window.close()

            fitsheader_window.close()





        #************************ DATA PLOTTING ***********************************************
        if event == 'Plot data':
            sg.theme('DarkBlue3')
            markers = ['red', 'green', 'yellow', 'blue', 'purple', 'black', 'orange']
            plot_layout = [
                [sg.Text('File to plot:', font=("Helvetica", 15, 'bold'), text_color = 'lightgreen'), sg.InputText(file_to_plot,key='-FILE-', readonly=True, size=(35, 1)), sg.FileBrowse(file_types=(('Text Files', '*.*'),),tooltip='Browse an ASCII file with space or tab soaced columns and first line containing the names of columns'), sg.Button('Load', button_color=('black','light green'), size=(7, 1), font=("Helvetica", 15), tooltip='After you browse for your data file, click here to load it')],
                [sg.Text(' x-axis data:', font=("Helvetica", 15, 'bold')), sg.Listbox(values=[], select_mode=sg.LISTBOX_SELECT_MODE_EXTENDED, key='-X_COLUMN-', enable_events=True, size=(20, 5)), sg.Text('y-axis data:', font=("Helvetica", 15, 'bold')), sg.Listbox(values=[], select_mode=sg.LISTBOX_SELECT_MODE_EXTENDED, key='-Y_COLUMNS-', size=(20, 5))],
                [sg.Checkbox('x errbars:',default = False, key = '-XERRBARS-', font=("Helvetica", 15)), sg.Listbox(values=[], select_mode=sg.LISTBOX_SELECT_MODE_EXTENDED, key='-X_ERR-', enable_events=True, size=(20, 5)), sg.Checkbox('y errbars:',default = False, key = '-YERRBARS-', font=("Helvetica", 15)), sg.Listbox(values=[], select_mode=sg.LISTBOX_SELECT_MODE_EXTENDED, key='-Y_ERR-', size=(20, 5))],
                [sg.Checkbox('Linear Fit of the data', default=False, key='-LINEAR_FIT-'), sg.Push(), sg.Checkbox('X log scale', default=False, key='-X_LOG-', font=("Helvetica", 10)),sg.Checkbox('Y log scale', default=False, key='-Y_LOG-', font=("Helvetica", 10))],
                [sg.HorizontalSeparator()],
                [sg.Text('X-axis Range:'), sg.InputText(key='-X_RANGE_MIN-', size=(8, 1)), sg.Text(' to '), sg.InputText(key='-X_RANGE_MAX-', size=(8, 1)),
                sg.Text('Y-axis Range:'), sg.InputText(key='-Y_RANGE_MIN-', size=(8, 1)), sg.Text(' to '), sg.InputText(key='-Y_RANGE_MAX-', size=(8, 1))],
                [sg.Text('X-axis label:'), sg.InputText(key='-X_LABEL-', size=(20, 1)),sg.Text('Y-axis label:'), sg.InputText(key='-Y_LABEL-', size=(20, 1))],
                [sg.Text('X-axis label size:'), sg.InputText(default_text='14', key='-X_LABEL_SIZE-', size=(5, 1)), sg.Text('Y-axis label size:'), sg.InputText(default_text='14', key='-Y_LABEL_SIZE-', size=(5, 1))],
                [sg.Text('X-ticks size:'), sg.InputText(default_text='14', key='-X_TICKS_SIZE-', size=(5, 1)), sg.Text('Y-ticks size:'), sg.InputText(default_text='14', key='-Y_TICKS_SIZE-', size=(5, 1))],
                [sg.Text('Marker color:'), sg.InputCombo(markers, key='-MARKER_COLOR-',default_value=markers[0],readonly=True), sg.Text('Marker size:'), sg.Slider(range=(1, 100), orientation='h', default_value=40, key='-MARKER_SIZE-')],
                [sg.Text('Plot size (inches):'), sg.InputText('8, 6', key='-PLOT_SIZE-', size=(5, 1)), sg.Checkbox ('Show legend', default = True, key = '-LEGEND-')],
                [sg.Button('Plot!', button_color=('white','orange'), size=(15, 1), font=("Helvetica", 15)), sg.Button('Save img', button_color=('black','light gray'), size=(15, 1), font=("Helvetica", 15)), sg.Button("Help", size=(12, 1),button_color=('black','orange')), sg.Push(), sg.Button('Exit', size=(15, 1))]
            ]

            print ('*** Plotting window open. The main panel will be inactive until you close the window ***')

            plot_window = sg.Window('Data Plotter', plot_layout)

            while True:
                plot_event, plot_values = plot_window.read()

                if plot_event == sg.WIN_CLOSED or plot_event == 'Exit':
                    print('Plot window closed. This main panel is now active again')
                    print('')
                    break

                try:
                    file_to_plot = plot_values['-FILE-']
                except Exception:
                    sg.popup ('Cannot read the file to plot')
                    continue


                if plot_event == 'Load':
                    file_path = plot_values['-FILE-']
                    if file_path:
                        column_names = stm.get_column_names(file_path)
                        plot_window['-X_COLUMN-'].update(values=column_names)
                        plot_window['-Y_COLUMNS-'].update(values=column_names)
                        plot_window['-X_ERR-'].update(values=column_names)
                        plot_window['-Y_ERR-'].update(values=column_names)

                elif plot_event == 'Plot!' or plot_event == 'Save img':
                    file_path = plot_values['-FILE-']
                    x_column = plot_values['-X_COLUMN-']
                    y_columns = plot_values['-Y_COLUMNS-']
                    x_err = plot_values['-X_ERR-']
                    y_err = plot_values['-Y_ERR-']
                    x_label = plot_values['-X_LABEL-']
                    y_label = plot_values['-Y_LABEL-']
                    legend = plot_values['-LEGEND-']
                    marker_color = plot_values['-MARKER_COLOR-']
                    add_error_bars_x = plot_values['-XERRBARS-']
                    add_error_bars_y = plot_values['-YERRBARS-']
                    marker_size = int(plot_values['-MARKER_SIZE-'])
                    plot_size = tuple(map(float, plot_values['-PLOT_SIZE-'].split(',')))
                    x_label_size = int(plot_values['-X_LABEL_SIZE-'])
                    y_label_size = int(plot_values['-Y_LABEL_SIZE-'])
                    x_tick_size = int(plot_values['-X_TICKS_SIZE-'])
                    y_tick_size = int(plot_values['-Y_TICKS_SIZE-'])
                    enable_linear_fit = plot_values['-LINEAR_FIT-']
                    x_log_scale = plot_values['-X_LOG-']
                    y_log_scale = plot_values['-Y_LOG-']

                    try:
                        x_range_min = float(plot_values['-X_RANGE_MIN-']) if plot_values['-X_RANGE_MIN-'] else None
                        x_range_max = float(plot_values['-X_RANGE_MAX-']) if plot_values['-X_RANGE_MAX-'] else None
                        y_range_min = float(plot_values['-Y_RANGE_MIN-']) if plot_values['-Y_RANGE_MIN-'] else None
                        y_range_max = float(plot_values['-Y_RANGE_MAX-']) if plot_values['-Y_RANGE_MAX-'] else None
                    except ValueError:
                        sg.popup ('Range values not valid!')
                        continue

                    if plot_event == 'Plot!':
                        stm.plot_data(file_path, x_column, y_columns, x_label, y_label, marker_color, marker_size, plot_size, x_label_size, y_label_size, x_tick_size, y_tick_size, legend, add_error_bars_x, add_error_bars_y, x_err, y_err, False, enable_linear_fit, x_log_scale, y_log_scale, x_range_min, x_range_max, y_range_min, y_range_max)



                    if plot_event == 'Save img':
                        stm.plot_data(file_path, x_column, y_columns, x_label, y_label, marker_color, marker_size, plot_size, x_label_size, y_label_size, x_tick_size, y_tick_size, legend, add_error_bars_x, add_error_bars_y, x_err, y_err, True, enable_linear_fit, x_log_scale, y_log_scale, x_range_min, x_range_max, y_range_min, y_range_max)

                if plot_event == 'Help':
                    f = open(os.path.join(BASE_DIR, "help_files", "help_me_plot.txt"), 'r')
                    file_contents = f.read()
                    if layout == layout_android:
                        sg.popup_scrolled(file_contents, size=(120, 30))
                    else:
                        sg.popup_scrolled(file_contents, size=(100, 40))

            plot_window.close()


    # ************************* parameter definitions done ****************************
    #################################################################################################

        #reading the spectra list to have the spectra number, only if the file exists!
        if values['one_spec'] == False: #I have a list, reading the list.

            #if I press the Load spectra button, then I print some infos and update the list of spectra.
            if event == 'Load!':
                fatal_condition = 0
                #test if file file exist
                cond00 = (os.path.isfile(spectra_list))
                if cond00 == True:
                    try:
                        df_list_spec = pd.read_csv(spectra_list, delimiter = ' ')
                        spectra_number = len(df_list_spec.index)
                    except Exception:
                        sg.popup('Cannot read the spectra list. You sure it is ok?')
                        continue

                if cond00 == False:
                    sg.popup('We don''t start well: the spectra file list does not exist. Try again...')
                    continue

                print('You want to load ', spectra_number, 'spectra')
                print('Now I check if they really exist and are valid spectra...')
                print ('')


                #check to add the absolute path in case the spectra list is given in relative path
                with open(spectra_list, 'r') as f:
                    spec_names = []
                    for line in f:
                        line = line.strip()
                        if not line or line.startswith("#"):
                            continue

                        # If I gave the relative path, try to solve the absolute path
                        if os.path.isabs(line) == False:
                            spec_names.append(os.path.join(BASE_DIR, line))

                        #If I have the absolute path
                        else:
                            # Loading the spectra list
                            spec_names = np.loadtxt(spectra_list, dtype='str', delimiter=' ', usecols=[0])

                            # Normalisation: spec_names must always be a list, even with only one element (one spectrum)
                            if np.ndim(spec_names) == 0:
                                spec_names = [spec_names]  # trasnforming to a list if I have one spectrum and loadtxt sees it as a scalar
                            else:
                                spec_names = spec_names.tolist()  #Converting the 1D array in a list
                            break #assuming I have all absolute or relative paths, breaking the cycle


                # Cleaning spurious characters
                spec_names = [str(spectrum).strip() for spectrum in spec_names]
                spec_names_nopath = [os.path.basename(spectrum) for spectrum in spec_names]
                # Updating the listbox
                window['-LIST-'].Update(spec_names_nopath)

                # Checking if the file has been correctly formatted
                len_condition = 0
                if len(spec_names) != spectra_number:
                    len_condition = 1
                    sg.popup('Warning: The format of the spectra list files is not correct. '
                            'Maybe you forgot to add #Spectrum as the first line? I will crash if you press Process all')

                # Checking if the spectra exist
                stop_condition = 0
                spec_not_exist = []
                spec_exist = []

                #Checking the existence of the spectra
                for spectrum in spec_names:
                    if not os.path.isfile(spectrum):
                        spec_not_exist.append(spectrum)
                        stop_condition = 1

                # If none of the spectra exist
                if stop_condition == 1:
                    if len(spec_not_exist) == len(spec_names):
                        sg.popup('None of the spectra exists. Please, check the file list and load it again!')
                        print('Congratulations, you loaded ZERO valid spectra')
                        spectra_number = 0
                        fatal_condition = 1
                        continue

                    else:
                        sg.popup ('At least one spectrum does not exist I will update the listbox considering only existing spectra')
                        print('The following spectra do not exist! I will update the listbox considering only existing spectra', spec_not_exist)
                        spec_names = np.setdiff1d(spec_names, spec_not_exist)
                        spec_names_nopath = [os.path.basename(spectrum) for spectrum in spec_names]
                        listbox1 = spec_names_nopath
                        window['-LIST-'].Update(listbox1)

                        spectra_number = len(spec_names)
                        # spec_names_nopath = [os.path.splitext(os.path.basename(f))[0] for f in spec_names]

                if stop_condition == 0:
                    spec_names_nopath = [os.path.basename(spectrum) for spectrum in spec_names]
                    # spec_names_nopath = [os.path.splitext(os.path.basename(f))[0] for f in spec_names]


                # 3) Check if the files loaded are really valid spectra
                spec_not_readable = []
                stop_condition2 = 0

                #Checnking the fits spectra, if they are valid or not
                spec_not_valid = []
                stop_condition3 = 0

                for i, spectrum in enumerate(spec_names):
                    # Progress meter if more than 5 spectra
                    if len(spec_names) > 5:
                        if not sg.OneLineProgressMeter(
                            'Reading spectra', i + 1, len(spec_names), 'Processing spectra:',
                            orientation='h', button_color=('white', 'red')
                        ):
                            print('***CANCELLED***\n')
                            break

                    if spectrum.lower().endswith('.fits'):
                        # Just for fits files
                        valid, message = stm.is_valid_spectrum(spectrum)
                        # print(f"{spectrum}: {message}")  # Log for debugging
                        if not valid:
                            spec_not_valid.append(spectrum)
                            stop_condition3 = 1

                    else:
                        # Try reading the spectrum
                        try:
                            wavelength, flux, step, name = stm.read_spec(spectrum, lambda_units)
                        except Exception as e:
                            print(f"Error reading spectrum: {spectrum} | {e}")  # Debugging log
                            stop_condition2 = 1
                            spec_not_readable.append(spectrum)
                            continue

                # Handle invalid spectra
                if stop_condition2 == 1:
                    if len(spec_not_readable) == len(spec_names):
                        sg.popup('None of the spectra is valid. Please, check the file list and load it again!')
                        print('Congratulations, you loaded ZERO valid spectra')
                        spectra_number = 0
                        fatal_condition = 1
                    else:
                        sg.popup('Cannot read all the spectra. I will exclude the invalid ones from the list')
                        print('Cannot read the following spectra. I will exclude them from the list:', spec_not_readable)
                        readable_spec = np.setdiff1d(spec_names, spec_not_readable)
                        spec_names = readable_spec.tolist()  # Convert back to a Python list if needed
                        spec_names_nopath = [os.path.basename(spectrum) for spectrum in spec_names]
                        listbox1 = spec_names_nopath
                        window['-LIST-'].Update(listbox1)

                        # Update spectra count and names
                        spectra_number = len(spec_names)
                        # spec_names_nopath = [os.path.splitext(os.path.basename(f))[0] for f in spec_names]

                        # print(f"Valid spectra loaded: {spec_names}")

                #In case of fits files
                if stop_condition3 == 1:
                    if len(spec_not_valid) == len([s for s in spec_names if s.lower().endswith('.fits')]):
                        sg.popup("None of the FITS spectra are valid. Please, check the file list and load it again!")
                        print("Congratulations, you loaded ZERO valid FITS spectra")
                        spectra_number = 0
                        fatal_condition = 1
                    else:
                        sg.popup("At least one FITS file is not a valid spectrum. I will exclude from the list")
                        print("The following FITS files are not valid spectra. I will exclude them from the list:", spec_not_valid)
                        readable_spec = np.setdiff1d(spec_names, spec_not_valid)
                        spec_names = readable_spec.tolist()
                        spec_names_nopath = [os.path.basename(spectrum) for spectrum in spec_names]
                        listbox1 = spec_names_nopath
                        window['-LIST-'].Update(listbox1)
                        spectra_number = len(spec_names)
                        # spec_names_nopath = [os.path.splitext(os.path.basename(f))[0] for f in spec_names]


                print ('')
                print('You loaded ', spectra_number, 'valid spectra')
                print ('')
                print ('')
                print ('*** Please, check the correct spectra wavelength range with plot button before doing anything ***')
                print ('')


            if len(spec_names) != spectra_number and spectra_number > 0:
                sg.popup ('I was joking. I will not crash, but the format of the spectra list files is not correct yet. Try to adjust the spectra file list')
                continue


            if fatal_condition == 1:
                sg.popup ('You did not load any valid spectra. I can do nothing but show you this message until you will load a valid spectra list')
                continue


            if (spec_names[0] == 0 and (event == 'Preview spec.' or event == 'Process selected' or event == 'Show info' or event == 'Preview result' or event == 'Process all' or event == 'Plot' or event =='Original spec.' or event == 'One' or event == 'All' or event == 'Compare' or event == 'convert_one' or event == 'convert_all' or event == 'Show snr' or event == 'See plot' or event == 'Save one' or event == 'Save all')):
                sg.popup('Please, load some spectra!')
                continue

            #Definying the names to show in the GUI, without the path. Only for visualisation purposes!
            prev_spec = ''
            prev_spec = prev_spec.join(values['-LIST-'])
            prev_spec = next((s for s in spec_names if isinstance(s, str) and os.path.basename(s) == str(prev_spec)), "")
            prev_spec_nopath = os.path.splitext(os.path.basename(prev_spec))[0] #no path for showing and saving things

        #I have just on spectrum:
        if values['one_spec'] == True:
            cond00 = (os.path.isfile(spectra_list))
            spectra_number = 1
            if event == 'Load!':
                    #test if file file exist
                print ('Guessing the type of the spectrum. It is correct?')
                if cond00 == False:
                    sg.popup('We don''t start well: the spectrum does not exist. Try again...')
                    continue

                prev_spec = ''
                prev_spec = spectra_list

            #control whether the spectrum is really a spectrum or something else, maybe a list
                try:
                    #Checnking the fits spectra, if they are valid or not
                    if prev_spec.lower().endswith('.fits'):
                        # Just for fits files
                        valid, message = stm.is_valid_spectrum(prev_spec)
                        print(f"{prev_spec}: {message}")  # Log for debugging
                        if not valid:
                            spec_not_valid = prev_spec
                            sg.popup('Your FITS file does not seem a spectrum. Please, load a valid spectrum')
                            prev_spec = ''
                            continue

                    wavelength, flux, step, name = stm.read_spec(prev_spec, lambda_units)
                    wave_limits = np.array([np.min(wavelength), np.max(wavelength)])
                    prev_spec_nopath = os.path.splitext(os.path.basename(prev_spec))[0]
                    spec_name = [prev_spec_nopath, ' ' ]
                    listbox2 = spec_name
                    window['-LIST-'].Update(listbox2) #update the listbox
                except Exception:
                    sg.popup('Ops! Cannot read the spectrum. You sure is a spectrum?')
                    prev_spec = ''
                    print ('Please, reload a valid spectrum or a list')
                    continue

                print ('*** Please, check the correct spectrum wavelength range with plot button before doing anything ***')

        #check if I select one spec but do not load
        if values['one_spec'] == True:
            try:
                prev_spec ==''
            except NameError:
                sg.popup('Did you forget to load the spectrum??')
                continue

        #Warning in case I load the spectra but I don't select one!
        if ( (event == 'Preview spec.' or event == 'Process selected' or event == 'Show info' or event == 'Preview result' or event == 'Plot' or event == 'See plot' or event == 'Save one' or event == 'Original spec.'or event == 'One' or event == 'All' or event == 'Compare' or event == 'convert_one' or event == 'convert_all' or event == 'Show snr') and prev_spec == ''):
            sg.popup('No spectrum selected. Please, select one spectrum in the list. Doing nothing')
            continue


        #every time I select a loaded spectrum and press plot, I read the spectrum and plot it!
        if event == 'Plot':
            wavelength, flux, step, name = stm.read_spec(prev_spec, lambda_units)
            wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])
            plt.plot(wavelength, flux)
            plt.xlabel('Wavelength nm', fontsize = 9)
            plt.title(prev_spec_nopath)
            plt.ylabel('Flux')
            plt.show()
            plt.close()

        if event == 'Original spec.':
            wavelength, flux, step, name = stm.read_spec(prev_spec, lambda_units)
            wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])
            plt.plot(wavelength, flux)
            plt.xlabel('Wavelength nm', fontsize = 9)
            plt.title(prev_spec_nopath)
            plt.ylabel('Flux')
            plt.show()
            plt.close()

        if event == 'Read me':
            f = open(os.path.join(BASE_DIR, "help_files", "readme_span.txt"), 'r')
            file_contents = f.read()
            if layout == layout_android:
                sg.popup_scrolled(file_contents, size=(120, 30))
            else:
                sg.popup_scrolled(file_contents, size=(100, 40))

        if event == 'I need help':
            f = open(os.path.join(BASE_DIR, "help_files", "need_help_spec_proc.txt"), 'r')
            file_contents = f.read()
            if layout == layout_android:
                sg.popup_scrolled(file_contents, size=(120, 30))
            else:
                sg.popup_scrolled(file_contents, size=(100, 40))

        if event == 'Help me':
            f = open(os.path.join(BASE_DIR, "help_files", "help_me_spec_analysis.txt"), 'r')
            file_contents = f.read()
            if layout == layout_android:
                sg.popup_scrolled(file_contents, size=(120, 30))
            else:
                sg.popup_scrolled(file_contents, size=(100, 40))

        if event == 'Quick start':
            f = open(os.path.join(BASE_DIR, "help_files", "quick_start.txt"), 'r')
            file_contents = f.read()
            if layout == layout_android:
                sg.popup_scrolled(file_contents, size=(120, 30))
            else:
                sg.popup_scrolled(file_contents, size=(100, 40))

        if event == 'Tips and tricks':
            f = open(os.path.join(BASE_DIR, "help_files", "tips_and_tricks.txt"), 'r')
            file_contents = f.read()
            if layout == layout_android:
                sg.popup_scrolled(file_contents, size=(120, 30))
            else:
                sg.popup_scrolled(file_contents, size=(100, 40))

        # the following lines are just to ensure that if do not load any spectra but opens the sub-programs, SPAN will not crash
        try:
            original_flux = flux
            original_wavelength = wavelength
        except Exception:
            print ('')



    #*********************** Utilities event **************
        if (event == 'Show info'):
            #reading the spectrum selected
            wavelength, flux, step, name = stm.read_spec(prev_spec, lambda_units)
            # original_wavelength = wavelength
            #original_flux = flux
            wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

            #******************* Spectra utilities

            #show header
            if show_hdr == True:
                util_task = 1
                print ('*** Showing header *** ')
                header = uti.show_hdr(prev_spec)

                #creating the header window
                if layout == layout_android:
                    layout_hdr = [[sg.Multiline(header, size=(120, 30), disabled=True, autoscroll=True, key='-MULTILINE-')],
                        [sg.Button('Close')]]
                else:
                    layout_hdr = [[sg.Multiline(header, size=(100, 40), disabled=True, autoscroll=True, key='-MULTILINE-')],
                        [sg.Button('Close')]]

                window_hdr = sg.Window('FITS Header Viewer', layout_hdr, finalize=True)

                while True:
                    event_hdr, values_hdr = window_hdr.read()
                    if event_hdr == sg.WIN_CLOSED or event_hdr == 'Close':
                        break

                window_hdr.close()


            #show sampling
            if show_sample == True:
                util_task = 1
                print ('*** Showing sampling ***')
                step_spectrum, is_linear = uti.show_sampling(wavelength)
                sg.popup('Step: ', round(step_spectrum,4), 'nm')


            #show resolution
            if show_resolution == True:
                util_task = 1
                print ('*** Showing the resolution of the spectrum ***')
                #check values
                if res_wave1 < wave_limits[0] or res_wave1 > wave_limits[1]:
                    sg.popup('Wavelength window outside the limits of the spectrum!')
                    continue
                if res_wave2 < wave_limits[0] or res_wave2 > wave_limits[1]:
                    sg.popup('Wavelength window outside the limits of the spectrum!')
                    continue

                resolution_R, line_wave, line_flux_spec_norm, line_flux_spec_fit = uti.resolution (wavelength, flux, res_wave1, res_wave2)
                print ('Resolution R: ', resolution_R)

                plt.plot(line_wave, line_flux_spec_norm, label = 'Spectrum')
                plt.plot(line_wave, line_flux_spec_fit, label = 'Fit line spec')
                plt.xlabel('Wavelength nm', fontsize = 9)
                plt.ylabel('Flux')
                plt.title('Resolution: ' + str(round(resolution_R)))
                plt.legend(fontsize = 10)
                plt.show()
                plt.close()


            if util_task == 0:
                sg.popup('You need to select an option before click Show info')
                continue

        #convert spectra to ASCII or fits
        if (event == 'One'):
            #reading the spectrum selected
            wavelength, flux, step, name = stm.read_spec(prev_spec, lambda_units)
            # original_wavelength = wavelength
            #original_flux = flux
            wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])
            convert_task = 0
        #Convert spectrum
            if convert == True:
                convert_task = 1
                print ('*** Converting spectrum ***')
                if convert_ascii == True:
                    type_spec_to_convert = 'ASCII'
                    try:
                        uti.convert_spec(wavelength, flux, prev_spec, type_spec_to_convert, lambda_units)
                        print ('Spectrum', prev_spec_nopath, ' converted to ASCII and stored in the same directory of your spectra')
                    except OSError:
                        print('Spectrum already exist in the result/spec directory. Skipping...')

                else:
                    type_spec_to_convert = 'FITS'
                    try:
                        uti.convert_spec(wavelength, flux, prev_spec, type_spec_to_convert, lambda_units)
                        print ('Spectrum', prev_spec_nopath, ' converted to fits table and stored in the same directory of your spectra')
                    except OSError:
                        print('Spectrum already exist in the result/spec directory. Skipping...')


            if convert_task == 0:
                sg.popup('You need to activate the option if you expect something!')
                continue

        if (event == 'All'):
            if convert == True:
                convert_task = 1

                if convert_ascii == True:
                    type_spec_to_convert = 'ASCII'

                    for i in range(spectra_number):
                        wavelength, flux, original_step, obj_name = stm.read_spec(spec_names[i], lambda_units)
                        try:
                            uti.convert_spec(wavelength, flux, spec_names[i], type_spec_to_convert, lambda_units)
                        except OSError:
                            print('Spectrum already exist in the same directory. Skipping...')

                    print ('The spectra have been converted to ASCII and stored in the same directory of your spectra')

                if convert_ascii == False:
                    type_spec_to_convert = 'FITS'

                    for i in range(spectra_number):
                        wavelength, flux, original_step, obj_name = stm.read_spec(spec_names[i], lambda_units)
                        try:
                            uti.convert_spec(wavelength, flux, spec_names[i], type_spec_to_convert, lambda_units)
                        except OSError:
                            print('Spectrum already exist in the same directory. Skipping...')
                    print ('The spectra have been converted to fits table and stored in the same directory of your spectra')

            if event == 'All' and values['one_spec'] == True:
                sg.popup ('You have just one spectrum. The button all does not work!')
                continue

            if convert_task == 0:
                sg.popup('You need to activate the option if you expect something!')
                continue



        ##### Compare spectrum #####
        if (event == 'Compare'):
            compare_task = 0
            if compare_spec == True:
                compare_task = 1
                print ('*** Comparing spectra ***')

                #test if file file exist
                cond = (os.path.isfile(spec_compare_file))
                if cond == False:
                    sg.popup('The spectrum to compare does not exist.')
                    print ('The spectrum to compare does not exist.')
                    continue
                try:
                    #read the spec
                    wavelength, flux, step, name = stm.read_spec(prev_spec, lambda_units)

                    #read the comparison spec
                    wave_compare, flux_compare, compare_step, compare_name = stm.read_spec(spec_compare_file, lambda_units)

                    #normalizing
                    wave_norm = wavelength[100]
                    epsilon_avg = step*10
                    norm_flux = spman.norm_spec(wavelength, flux, wave_norm, epsilon_avg, flux)
                    norm_compare_flux = spman.norm_spec(wave_compare, flux_compare, wave_norm, epsilon_avg, flux_compare)

                    #plotting

                    fig, (ax1, ax2) = plt.subplots(1, 2, figsize = (10,5))
                    fig.suptitle('Compared spectra')
                    ax1.plot(wavelength, flux, label = 'Selected spectrum')
                    ax1.plot(wave_compare, flux_compare, label = 'Comparison spectrum')
                    ax1.set_xlabel('Wavelength nm')
                    ax1.set_ylabel('Flux')
                    ax1.legend(fontsize = 10)

                    ax2.plot(wavelength, norm_flux, label = 'Norm. selected spectrum')
                    ax2.plot(wave_compare, norm_compare_flux, label = 'Norm. comparison spectrum')
                    ax2.set_xlabel('Wavelength (nm)')
                    ax2.set_ylabel('Norm flux')
                    ax2.legend(fontsize = 10)
                    plt.show()
                    plt.close()
                except:
                    sg.popup ('Cannot compare spectra. Check the comparison spectrum: does it exit and have the same lambda units?')

            if compare_task == 0:
                sg.popup('You need to select the option if you expect something!')
                continue



        ################################################# Flux convert ##############################

        if event == 'See plot' or event == 'convert_one':
            flux_conv_task = 0

            if convert_flux == True:
                flux_conv_task = 1

                if convert_to_flambda == True:
                    type_to_convert = 'to_flambda'
                if convert_to_fnu == True:
                    type_to_convert = 'to_fnu'

                if event == 'See plot' or event == 'convert_one':

                    #read the spectrum
                    wavelength, flux, step, name = stm.read_spec(prev_spec, lambda_units)
                    wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])
                    #original_wavelength = wavelength
                    #original_flux = flux

                    converted_flux = uti.convert_flux(wavelength, flux, prev_spec, type_to_convert, lambda_units)


                    #plotting
                    if event == 'See plot':
                        fig, (ax1, ax2) = plt.subplots(1, 2, figsize = (10,5))
                        fig.suptitle('Original - Converted spectrum')
                        ax1.plot(wavelength, flux, label = 'Original spectrum')
                        ax1.set_xlabel('Wavelength nm')
                        ax1.set_ylabel('Flux density')
                        ax1.legend(fontsize = 10)

                        ax2.plot(wavelength, converted_flux, label = 'Converted flux')
                        ax2.set_xlabel('Wavelength (nm)')
                        ax2.set_ylabel('Flux density')
                        ax2.legend(fontsize = 10)
                        plt.show()
                        plt.close()

                    if event == 'convert_one':
                        file_converted = result_spec+'f_converted_' + prev_spec_nopath +'.fits'
                        uti.save_fits(wavelength, converted_flux, file_converted)
                        print ('Spectrum converted flux saved in ', result_data,'/spec folder')

            if flux_conv_task == 0:
                sg.popup('You need to activate the option if you expect something!')
                continue


        # Convert flux event
        if event == 'convert_all':
            flux_conv_task = 0
            if convert_flux == True and values['one_spec'] == False:
                flux_conv_task = 1

                for i in range(spectra_number):
                    #read the spectra
                    wavelength, flux, original_step, obj_name = stm.read_spec(spec_names[i], lambda_units)
                    wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

                    #convert the spectra
                    converted_flux = uti.convert_flux(wavelength, flux, spec_names[i], type_to_convert, lambda_units)
                    #save the spectra
                    #filename = 'flux_converted' + spec_names_nopath
                    file_converted = result_spec+'f_converted_' + spec_names_nopath[i] + '.fits'
                    uti.save_fits(wavelength, converted_flux, file_converted)

            if flux_conv_task == 0 and values['one_spec'] == False:
                sg.popup('You need to activate the option if you expect something!')
                continue

            if event == 'convert_all' and values['one_spec'] == True:
                sg.popup ('You should activate the option if you expect something, but "All" does not work anyway with just one spectrum!')
                continue

            #if event == ' All' and values['one_spec'] == True and flux_conv_task == 1:
                #sg.popup ('You have just one spectrum. Save all does not work!')
                #continue

    #show snr
        if event == 'Show snr':
            snr_task = 0
            #reading the spectrum selected
            wavelength, flux, step, name = stm.read_spec(prev_spec, lambda_units)
            #original_wavelength = wavelength
            #original_flux = flux
            wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

            if show_snr == True:
                snr_task = 1
                print ('*** Showing the SNR per pix *** ')
                #check values
                if snr_wave < wave_limits[0] or snr_wave > wave_limits[1]:
                    sg.popup('Wavelength window outside the limits of the spectrum!')
                    continue
                if epsilon_wave_snr < 0 or ((snr_wave+epsilon_wave_snr) > (wave_limits[1])) or (( snr_wave-epsilon_wave_snr) < wave_limits[0]):
                    sg.popup('Wavelength window exceed the wavelength range of the spectrum!')
                    continue

                snr_pix, snr_ang = uti.show_snr(wavelength, flux, snr_wave, epsilon_wave_snr)
                sg.popup('SNR per pix: ', int(round(snr_pix)), 'SNR per Ang: ', int(round(snr_ang)), 'at ', snr_wave, 'nm')

            if snr_task == 0:
                sg.popup('You need to activate the option if you expect something!')
                continue

        #############saving the SNR, per pix and per angstrom ##########################
        if show_snr == True and (event == 'Save one' or event == 'Save all'):
            snr_task = 1
            if event == 'Save one':

                #reading the spectrum selected
                wavelength, flux, step, name = stm.read_spec(prev_spec, lambda_units)
                #original_wavelength = wavelength
                #original_flux = flux
                wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

                print ('*** Showing the SNR per pix *** ')
                #check values
                if snr_wave < wave_limits[0] or snr_wave > wave_limits[1]:
                    sg.popup('Wavelength window outside the limits of the spectrum!')
                    continue
                if epsilon_wave_snr < 0 or ((snr_wave+epsilon_wave_snr) > (wave_limits[1])) or (( snr_wave-epsilon_wave_snr) < wave_limits[0]):
                    sg.popup('Wavelength window exceed the wavelength range of the spectrum!')
                    continue

                snr_pix, snr_ang = uti.show_snr(wavelength, flux, snr_wave, epsilon_wave_snr)
                print ('SNR per pix: ', int(round(snr_pix)), 'SNR per Ang: ', int(round(snr_ang)), ('at ', snr_wave, 'nm'))

            if event == 'Save all' and values['one_spec'] == False:
                snr_pix_array = np.zeros(spectra_number)
                snr_ang_array = np.zeros(spectra_number)
                ctr_cond = 0


                #cycle for all the spectra
                for i in range(spectra_number):

                    wavelength, flux, original_step, obj_name = stm.read_spec(spec_names[i], lambda_units)
                    wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])
                                #check values
                    if snr_wave < wave_limits[0] or snr_wave > wave_limits[1]:
                        print('*** WARNING*** Wavelength window outside the limits of the spectrum!')
                        ctr_cond = 1
                        continue
                    elif epsilon_wave_snr < 0 or ((snr_wave+epsilon_wave_snr) > (wave_limits[1])) or (( snr_wave-epsilon_wave_snr) < wave_limits[0]):
                        print('*** WARNING*** Wavelength window exceed the wavelength range of the spectrum!')
                        ctr_cond = 1
                        continue
                    else:
                        #snr spectra
                        snr_pix, snr_ang = uti.show_snr(wavelength, flux, snr_wave, epsilon_wave_snr)
                        snr_pix_array[i] = (int(snr_pix))
                        snr_ang_array[i] = (int(snr_ang))

                #save the data
                file_snr_pix = result_snr_dir+'/'+spectra_list_name+'_SNR_pix_@'+str(snr_wave)+'nm_'+timestamp +'.dat'
                file_snr_ang = result_snr_dir+'/'+spectra_list_name+'_SNR_ang_@'+str(snr_wave)+'nm_'+timestamp +'.dat'
                snr_pix_id = ['#Spectrum', 'SNR_per_pix@'+str(snr_wave)+'nm']
                snr_ang_id = ['#Spectrum', 'SNR_per_Ang@'+str(snr_wave)+'nm']

                snr_pix_data_array = np.column_stack((spec_names_nopath, snr_pix_array))
                snr_ang_data_array = np.column_stack((spec_names_nopath, snr_ang_array))

                #generating the dataframe and adding the data
                df_snr_pix = pd.DataFrame(snr_pix_data_array, columns = snr_pix_id)
                df_snr_ang = pd.DataFrame(snr_ang_data_array, columns = snr_ang_id)

                #writing to a file
                df_snr_pix.to_csv(file_snr_pix, index= False, sep=' ')
                df_snr_ang.to_csv(file_snr_ang, index= False, sep=' ')

                print('File ', file_snr_pix, ' and ', file_snr_ang, ' saved')

            if event == 'Save all' and values['one_spec'] == True:
                sg.popup ('You have just one spectrum. Save all does not work!')
                continue

            if snr_task == 0:
                sg.popup('You need to activate the option if you expect something!')
                continue

        if show_snr == False and (event == 'Save one' or event == 'Save all'):
            sg.popup('You need to activate the option if you expect something!')
            continue


    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################



    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################
    #################################################################################################



    #  ************************* MEGA EVENT 1: PRESS PREVIEW SPECTRUM OR PROCESS SELECTED! ****************************
    # VALIDD FOR SPECTRA PRE-PROCESSING, PROCESSING AND MATH FRAMES

        if (event == 'Preview spec.' or event == 'Preview result' or event == 'Process selected'):

            # If the user re-ordering is activated:
            if reorder_op == True:
                #reading the spectrum selected
                try:
                    wavelength, flux, step, name = stm.read_spec(prev_spec, lambda_units)
                    wave_limits = np.array([np.min(wavelength), np.max(wavelength)])
                    original_wavelength = wavelength
                    original_flux = flux
                except IndexError:
                    sg.popup('You still need to load a valid spectrum. I don''t change my mind')
                    continue

                #Cycling for all the active re-ordered tasks
                for op_name, op_var in reordered_operations:
                    if op_var == "cropping_spectrum":
                        # cropping_spectrum = True

                        #1) CROPPING
                        task_done = 1
                        task_spec = 1
                        print ('*** Cropping task ***')
                        cropping_range = np.array([cropping_low_wave,cropping_high_wave])
                        cropped_wavelength, cropped_flux = spman.crop_spec(wavelength, flux, cropping_range)
                        if len(cropped_wavelength)> 10:
                            wavelength =  cropped_wavelength
                            flux = cropped_flux
                        else:
                            print ('WARNING: The crop window is not in the spectral range. Skipping...')

                        try:
                            if event == 'Process selected' and save_intermediate_files == True :
                                file_cropped = result_spec+'crop_' + prev_spec_nopath + '.fits'
                                uti.save_fits(wavelength, flux, file_cropped)
                                print ('File saved: ', file_cropped)
                                print('')
                        except ValueError:
                            print ('Something went wrong, cannot complete the task. Check the spectrum. Tip: it is really a spectrum or a SED?')
                            continue

                        #limits wavelength range. Put here because the dopcor task can modify it and I don't need earlier
                        wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])


                    elif op_var == "sigma_clipping":

                        # sigma_clipping = True
                        # 2) DYNAMIC CLEANING
                        if sigma_clip_have_file == False:
                            task_done = 1
                            task_spec = 1
                            print ('*** Sigma clip task ***')

                            clip_wavelength, clip_flux = spman.sigma_clip(wavelength, flux, clip_factor, sigma_clip_resolution, sigma_clip_single_value)
                            wavelength = clip_wavelength
                            flux = clip_flux

                            try:
                                if event == 'Process selected' and save_intermediate_files == True :
                                    file_clipped = result_spec+'clip_' + prev_spec_nopath + '.fits'
                                    uti.save_fits(wavelength, flux, file_clipped)
                                    print ('File saved: ', file_clipped)
                                    print('')
                            except ValueError:
                                print ('Something went wrong, cannot complete the task. Check the spectrum. Tip: it is really a spectrum or a SED?')
                                continue

                        else:
                            sg.popup ('If you want to process just one file, please select a single sigma value')
                            continue



                    elif op_var == "wavelet_cleaning":

                    # 3) WAVELET CLEANING
                    # if wavelet_cleaning == True:
                        task_done = 1
                        task_spec = 1
                        print ('*** Wavelet denoise task ***')

                        denoised_flux = spman.wavelet_cleaning(wavelength, flux, sigma_wavelets, wavelets_layers)
                        #original_flux = flux
                        flux = denoised_flux
                        try:
                            if event == 'Process selected' and save_intermediate_files == True :
                                file_wavelet = result_spec+'wavelet_' + prev_spec_nopath + '.fits'
                                uti.save_fits(wavelength, flux, file_wavelet)
                                print ('File saved: ', file_wavelet)
                                print('')
                        except ValueError:
                            print ('Something went wrong, cannot complete the task. Check the spectrum. Tip: it is really a spectrum or a SED?')
                            #continue


                    elif op_var == "filter_denoise":

                        task_done = 1
                        task_spec = 1
                        print ('*** Denoising ***')

                        if moving_average == True and box_moving_avg == True:
                            denoised_flux = spman.mov_avg(flux, box_moving_avg_size)
                            flux = denoised_flux
                        if moving_average == True and gauss_moving_avg == True:
                            denoised_flux = spman.mov_avg_gauss(wavelength, flux, gauss_moving_avg_kernel)
                            flux = denoised_flux
                        if low_pass_filter == True:
                            denoised_flux = spman.lowpass(wavelength, flux, lowpass_cut_off, lowpass_order)
                            flux = denoised_flux
                        if bandpass_filter == True:
                            denoised_flux = spman.bandpass(wavelength, flux, bandpass_lower_cut_off, bandpass_upper_cut_off, bandpass_order)
                            flux = denoised_flux

                        if event == 'Process selected' and save_intermediate_files == True:
                            #denoised_suffix = str(int(round(box_moving_avg_size)))
                            file_mov_avg = result_spec+'denoised_' + prev_spec_nopath + '.fits'
                            uti.save_fits(wavelength, flux, file_mov_avg)
                            print ('File saved: ', file_mov_avg)
                            print('')


                    elif op_var == "dop_cor":

                        # 5) DOPPLER CORRECTION
                        if (dop_cor_single_shot == True):
                            task_done = 1
                            task_spec = 1
                            print ('*** Doppler correction ***')
                            dopcor_wave, dopcor_flux = spman.dopcor(wavelength, flux, dop_cor_single_shot_vel, dop_cor_have_vel)
                            wavelength = dopcor_wave
                            flux = dopcor_flux

                            #limits wavelength range. Put here because the dopcor task can modify it and I don't need earlier
                            wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

                            if event == 'Process selected' and save_intermediate_files == True:
                                file_dopcor = result_spec+'dopcor_' + prev_spec_nopath + '.fits'
                                uti.save_fits(wavelength, flux, file_dopcor)
                                print ('File saved: ', file_dopcor)
                                print('')
                        else:
                            sg.popup('If you want to process just one file, please select the one shot value!')
                            continue


                    elif op_var == "helio_corr":

                        #6) HELIOCENTRIC CORRECTION
                        if (helio_single_shot == True):
                            task_done = 1
                            task_spec = 1
                            print ('*** Heliocentric correction ***')
                            correction, new_wavelength, new_flux = spman.helio_corr(wavelength, flux, helio_single_shot_date, helio_single_shot_location, ra_obj, dec_obj)
                            print ('Heliocentric correction: ', correction, 'km/s')
                            wavelength = new_wavelength
                            flux = new_flux

                            #limits wavelength range. Put here because the dopcor task can modify it and I don't need earlier
                            wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

                            if event == 'Process selected' and save_intermediate_files == True:
                                file_helio = result_spec+'helio_' + prev_spec_nopath + '.fits'
                                uti.save_fits(wavelength, flux, file_helio)
                                print ('File saved: ', file_helio)
                                print('')
                        else:
                            sg.popup('If you want to process just one file, please select the one shot value!')
                            continue


                    elif op_var == "rebining":

                        #1) REBIN
                        #if rebinning linear selected, I do it
                        if rebinning_linear == True:
                            task_done = 1
                            task_spec = 1
                            print ('*** Rebinning linear ***')
                            rebinned_wave, rebinned_flux, npoints = spman.resample(wavelength, flux, rebin_step_pix)

                            #update the variables. necessary because I will use always wavelength and flux for the other functions!
                            wavelength = rebinned_wave
                            flux = rebinned_flux

                            if event == 'Process selected' and save_intermediate_files == True:
                                file_rebinned = result_spec+'rebinned_' + prev_spec_nopath + '.fits'
                                uti.save_fits(wavelength, flux, file_rebinned)
                                print ('File saved: ', file_rebinned)
                                print('')

                        #if rebinning log selected, I do it.
                        if rebinning_log == True:
                            task_done = 1
                            task_spec = 1

                            print ('*** Rebinning log ***')
                            rebinned_wave_log, rebinned_flux_log = spman.log_rebin(wavelength, flux, rebin_step_sigma)
                            wavelength = rebinned_wave_log
                            flux = rebinned_flux_log

                            if event == 'Process selected' and save_intermediate_files == True:
                                file_rebinned_log = result_spec+'rebinned_log_' + prev_spec_nopath + '.fits'
                                uti.save_fits(wavelength, flux, file_rebinned)
                                print ('File saved: ', file_rebinned_log)
                                print('')


                    elif op_var == "degrade":


                        # 2) DEGRADE RESOLUTION
                            #a) DEGRADE FROM R TO R
                        if is_initial_res_r == True and res_degrade_to_r == True:

                            task_done = 1
                            task_spec = 1
                            print ('*** Degrade resolution ***')

                            degraded_wave, degraded_flux = spman.degrade(wavelength, flux, initial_res_r, final_res_r, True)
                            #update the variables. necessary because I will use always wavelength and flux for the other functions!
                            wavelength = degraded_wave
                            flux = degraded_flux

                            if event == 'Process selected' and save_intermediate_files == True:
                                degraded_res = str(int(round(final_res_r)))
                                file_degraded = result_spec+'degraded_R' + degraded_res + '_' + prev_spec_nopath + '.fits'
                                uti.save_fits(wavelength, flux, file_degraded)
                                print ('File saved: ', file_degraded)
                                print('')

                            #B) DEGRADE FROM R TO FWHM
                        if is_initial_res_r == True and res_degrade_to_fwhm == True:
                            task_done = 1
                            task_spec = 1

                            print ('*** Degrade resolution from R to FWHM ***')

                            degraded_wave, degraded_flux = spman.degradeRtoFWHM(wavelength, flux, initial_res_r, final_res_r_to_fwhm)
                            wavelength = degraded_wave
                            flux = degraded_flux

                            if event == 'Process selected' and save_intermediate_files == True:
                                degraded_res_R_to_FWHM = str(float(round(final_res_r_to_fwhm,1)))
                                file_degraded_R_to_FWHM = result_spec+'degraded_FWHM' + degraded_res_R_to_FWHM + '_' + prev_spec_nopath + '.fits'
                                uti.save_fits(wavelength, flux, file_degraded_R_to_FWHM)
                                print ('File saved: ', file_degraded_R_to_FWHM)
                                print('')


                            #C) DEGRADE FROM FWHM TO FWHM
                        if is_initial_res_fwhm == True:

                            task_done = 1
                            task_spec = 1

                            print ('*** Degrade resolution in FWHM ***')

                            degraded_wave, degraded_flux = spman.degrade_lambda(wavelength, flux, initial_res_fwhm, final_res_fwhm)
                            #update the variables. necessary because I will use always wavelength and flux for the other functions!
                            wavelength = degraded_wave
                            flux = degraded_flux

                            if event == 'Process selected' and save_intermediate_files == True:
                                degraded_res_lambda = str(float(round(final_res_fwhm,1)))
                                file_degraded_lambda = result_spec+'degraded_FWHM' + degraded_res_lambda + '_' + prev_spec_nopath + '.fits'
                                uti.save_fits(wavelength, flux, file_degraded_lambda)
                                print ('File saved: ', file_degraded_lambda)
                                print('')


                    elif op_var == "normalize_wave":

                    # 3) NORMALISE SPECTRUM TO
                        task_done = 1
                        task_spec = 1

                        #check the limits
                        if (norm_wave < wave_limits[0] or norm_wave > wave_limits[1]):
                            sg.popup('Normalisation wavelength exceeds the range of the spectrum!')
                            continue

                        print ('*** Normalise ***')
                        step = wavelength[1]-wavelength[0]
                        epsilon_norm = step*10. #averaging on 10 steps values, rather than one value
                        norm_flux = spman.norm_spec(wavelength, flux, norm_wave, epsilon_norm, flux)
                        flux = norm_flux

                        if event == 'Process selected' and save_intermediate_files == True:
                            norm_suffix = str(norm_wave)
                            file_normalized = result_spec+'norm' + norm_suffix + '_' + prev_spec_nopath + '.fits'
                            uti.save_fits(wavelength, flux, file_normalized)
                            print ('File saved: ', file_normalized)
                            print('')


                    elif op_var == "sigma_broad":

                    # 4) SIGMA BROADENING
                    # if (sigma_broad == True):
                        task_done = 1
                        task_spec = 1
                        print ('*** Sigma broadening ***')
                        broadened_flux = spman.sigma_broad(wavelength, flux, sigma_to_add)
                        flux = broadened_flux

                        if event == 'Process selected' and save_intermediate_files == True:
                            broad_suffix = str(int(round(sigma_to_add)))
                            file_broad = result_spec+'broad' + broad_suffix + prev_spec_nopath + '.fits'
                            uti.save_fits(wavelength, flux, file_broad)
                            print ('File saved: ', file_broad)
                            print('')



                    elif op_var == "add_noise":
                    # 5) ADD NOISE
                    # if (add_noise == True):
                        task_done = 1
                        task_spec = 1
                        print ('*** Add noise ***')
                        noisy_flux = spman.add_noise(wavelength, flux, noise_to_add)
                        flux = noisy_flux

                        if event == 'Process selected' and save_intermediate_files == True:
                            noise_suffix = str(int(round(noise_to_add)))
                            file_noise = result_spec+'SNR' + noise_suffix + prev_spec_nopath + '.fits'
                            uti.save_fits(wavelength, flux, file_noise)
                            print ('File saved: ', file_noise)
                            print('')

                    elif op_var == "continuum_sub":

                    # 6) CONTINUUM MODELLING
                        task_done = 1
                        task_spec = 1
                        print ('*** Continuum subtraction ***')

                        if cont_model_filtering == True:
                            #print (cont_math_operation)
                            corrected_flux, continuum_flux = spman.sub_cont(wavelength, flux, cont_math_operation)

                        if cont_model_poly == True:
                            if event == 'Process selected' or event == 'Preview result':
                                corrected_flux, continuum_flux = spman.continuum(wavelength, flux, cont_want_to_maks, cont_mask_ranges, cont_poly_degree, cont_math_operation, False)
                            else:
                                corrected_flux, continuum_flux = spman.continuum(wavelength, flux, cont_want_to_maks, cont_mask_ranges, cont_poly_degree, cont_math_operation, True)

                        flux = corrected_flux

                        if event == 'Process selected' and save_intermediate_files == True:
                            file_cont_sub = result_spec+'cont_sub_' + prev_spec_nopath + '.fits'
                            file_cont = result_spec+'cont_' + prev_spec_nopath + '.fits'
                            uti.save_fits(wavelength, flux, file_cont_sub)
                            uti.save_fits(wavelength, continuum_flux, file_cont)
                            print ('File saved: ', file_cont_sub)
                            print ('File saved: ', file_cont)
                            print('')


                    elif op_var == "subtract_normalized_avg":

                        # 1) subtract normalized average
                        if values['one_spec'] == False:
                            task_done = 1
                            task_spec = 1
                            print ('*** Subract normalised average ***')
                            subtracted_flux = spmt.sub_norm_avg(wavelength, flux, lambda_units, spectra_number, spec_names)
                            flux = subtracted_flux

                            if event == 'Process selected' and save_intermediate_files == True:
                                file_subtracted_avg = result_spec+'subtracted_average' + prev_spec_nopath + '.fits'
                                uti.save_fits(wavelength, flux, file_subtracted_avg)
                                print ('File saved: ', file_subtracted_avg)
                                print('')
                        if values['one_spec'] == True:
                            sg.popup('There is no average to subtract!')
                            continue



                    elif op_var == "subtract_normalized_spec":

                    # 2) subtract normalized single
                    # if (subtract_normalized_spec == True):
                        task_done = 1
                        task_spec = 1
                        print ('*** Subtract normalised spectrum ***')

                        #test if file file exist
                        cond0 = (os.path.isfile(spectra_to_subtract))
                        if cond0 == False:
                            sg.popup('The file to subtract does not exist. Skipping...')
                            continue

                        subtracted_single_flux = spmt.sub_norm_single(wavelength, flux, spectra_to_subtract, lambda_units)
                        flux = subtracted_single_flux

                        if event == 'Process selected' and save_intermediate_files == True:
                            file_subtracted_single = result_spec+'subtracted_single' + prev_spec_nopath + '.fits'
                            uti.save_fits(wavelength, flux, file_subtracted_single)
                            print ('File saved: ', file_subtracted_single)
                            print('')


                    elif op_var == "add_pedestal":

                    # 3) add pedestal
                    # if (add_pedestal == True):
                        task_done = 1
                        task_spec = 1
                        print ('*** Add pedestal ***')
                        flux = flux + pedestal_to_add

                        if event == 'Process selected' and save_intermediate_files == True:
                            pedestal_suffix = str(int(round(pedestal_to_add)))
                            file_pedestal = result_spec+'pedestal' + pedestal_suffix + prev_spec_nopath + '.fits'
                            uti.save_fits(wavelength, flux, file_pedestal)
                            print ('File saved: ', file_pedestal)
                            print('')


                    elif op_var == "multiply":

                    # 4) multiply by a constant
                        task_done = 1
                        task_spec = 1
                        print ('*** Multiply by a constant ***')
                        flux = flux*multiply_factor

                        if event == 'Process selected' and save_intermediate_files == True:
                            multiplied_suffix = str(int(round(multiply_factor)))
                            file_multiplied = result_spec+'multiplied' + multiplied_suffix + prev_spec_nopath + '.fits'
                            uti.save_fits(wavelength, flux, file_multiplied)
                            print ('File saved: ', file_multiplied)
                            print('')



                    elif op_var == "derivatives":

                    # 5) derivatives
                        task_done = 1
                        task_spec = 1
                        print ('*** First and second derivatives ***')
                        print ('WARNING: these are NOT used for spectral analysis tasks')

                        try:
                            first_derivative = np.gradient(flux, wavelength)
                            second_derivative = np.gradient(first_derivative, wavelength)

                            #plotting
                            plt.figure(figsize=(12, 8))

                            plt.subplot(3, 1, 1)
                            plt.plot(wavelength, flux, label='Original spectrum')
                            plt.title('Spectra derivatives')
                            plt.xlabel('Wavelength (nm)')
                            plt.ylabel('Flux')
                            plt.legend()

                            plt.subplot(3, 1, 2)
                            plt.plot(wavelength, first_derivative, label='First derivative')
                            plt.title('First derivative')
                            plt.xlabel('Wavelength (nm)')
                            plt.ylabel('Flux')
                            plt.legend()

                            plt.subplot(3, 1, 3)
                            plt.plot(wavelength, second_derivative, label='Second derivative')
                            plt.title('Second derivative')
                            plt.xlabel('Wavelength (nm)')
                            plt.ylabel('Flux')
                            plt.legend()

                            plt.tight_layout()
                            plt.show()
                            plt.close()

                            if event == 'Process selected':
                                #derivative_suffix = str(int(round(multiply_factor)))
                                file_first_derivative = result_spec+'first_deriv_'+ prev_spec_nopath + '.fits'
                                file_second_derivative = result_spec+'second_deriv_'+ prev_spec_nopath + '.fits'
                                uti.save_fits(wavelength, first_derivative, file_first_derivative)
                                uti.save_fits(wavelength, second_derivative, file_second_derivative)
                                print ('Derivative spectra saved: ', file_first_derivative, file_second_derivative)
                                print('')
                        except Exception:
                            print ('Cannot compute the derivatives. Skipping...')



        #**************** spectra pre-processing ***********************************
            #If I use the SPAN tasks as they appear in the GUI:
            if reorder_op == False:

                #reading the spectrum selected
                try:
                    wavelength, flux, step, name = stm.read_spec(prev_spec, lambda_units)
                    wave_limits = np.array([np.min(wavelength), np.max(wavelength)])
                    original_wavelength = wavelength
                    original_flux = flux
                except IndexError:
                    sg.popup('You still need to load a valid spectrum. I don''t change my mind')
                    continue

                # 1) CROPPING
                if cropping_spectrum == True:
                    task_done = 1
                    task_spec = 1
                    print ('*** Cropping task ***')
                    cropping_range = np.array([cropping_low_wave,cropping_high_wave])
                    cropped_wavelength, cropped_flux = spman.crop_spec(wavelength, flux, cropping_range)
                    if len(cropped_wavelength)> 10:
                        wavelength =  cropped_wavelength
                        flux = cropped_flux
                    else:
                        print ('WARNING: The crop window is not in the spectral range. Skipping...')

                    try:
                        if event == 'Process selected' and save_intermediate_files == True :
                            file_cropped = result_spec+'crop_' + prev_spec_nopath + '.fits'
                            uti.save_fits(wavelength, flux, file_cropped)
                            print ('File saved: ', file_cropped)
                            print('')
                    except ValueError:
                        print ('Something went wrong, cannot complete the task. Check the spectrum. Tip: it is really a spectrum or a SED?')
                        continue

                    #limits wavelength range. Put here because the dopcor task can modify it and I don't need earlier
                    wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

                # 2) DYNAMIC CLEANING
                if sigma_clipping == True and sigma_clip_have_file == False:
                    task_done = 1
                    task_spec = 1
                    print ('*** Sigma clip task ***')

                    clip_wavelength, clip_flux = spman.sigma_clip(wavelength, flux, clip_factor, sigma_clip_resolution, sigma_clip_single_value)
                    wavelength = clip_wavelength
                    flux = clip_flux

                    try:
                        if event == 'Process selected' and save_intermediate_files == True :
                            file_clipped = result_spec+'clip_' + prev_spec_nopath + '.fits'
                            uti.save_fits(wavelength, flux, file_clipped)
                            print ('File saved: ', file_clipped)
                            print('')
                    except ValueError:
                        print ('Something went wrong, cannot complete the task. Check the spectrum. Tip: it is really a spectrum or a SED?')
                        continue

                elif sigma_clipping == True and sigma_clip_have_file == True:
                    sg.popup ('If you want to process just one file, please select a single sigma value')
                    continue


                # 3) WAVELET CLEANING
                if wavelet_cleaning == True:
                    task_done = 1
                    task_spec = 1
                    print ('*** Wavelet denoise task ***')

                    denoised_flux = spman.wavelet_cleaning(wavelength, flux, sigma_wavelets, wavelets_layers)
                    #original_flux = flux
                    flux = denoised_flux
                    try:
                        if event == 'Process selected' and save_intermediate_files == True :
                            file_wavelet = result_spec+'wavelet_' + prev_spec_nopath + '.fits'
                            uti.save_fits(wavelength, flux, file_wavelet)
                            print ('File saved: ', file_wavelet)
                            print('')
                    except ValueError:
                        print ('Something went wrong, cannot complete the task. Check the spectrum. Tip: it is really a spectrum or a SED?')
                        #continue


                # 4) FILTERING AND DENOISING
                if (filter_denoise == True):
                    task_done = 1
                    task_spec = 1
                    print ('*** Denoising ***')

                    if moving_average == True and box_moving_avg == True:
                        denoised_flux = spman.mov_avg(flux, box_moving_avg_size)
                        flux = denoised_flux
                    if moving_average == True and gauss_moving_avg == True:
                        denoised_flux = spman.mov_avg_gauss(wavelength, flux, gauss_moving_avg_kernel)
                        flux = denoised_flux
                    if low_pass_filter == True:
                        denoised_flux = spman.lowpass(wavelength, flux, lowpass_cut_off, lowpass_order)
                        flux = denoised_flux
                    if bandpass_filter == True:
                        denoised_flux = spman.bandpass(wavelength, flux, bandpass_lower_cut_off, bandpass_upper_cut_off, bandpass_order)
                        flux = denoised_flux

                    if event == 'Process selected' and save_intermediate_files == True:
                        #denoised_suffix = str(int(round(box_moving_avg_size)))
                        file_mov_avg = result_spec+'denoised_' + prev_spec_nopath + '.fits'
                        uti.save_fits(wavelength, flux, file_mov_avg)
                        print ('File saved: ', file_mov_avg)
                        print('')


                # 5) DOPPLER CORRECTION
                if (dop_cor == True and dop_cor_single_shot == True):
                    task_done = 1
                    task_spec = 1
                    print ('*** Doppler correction ***')
                    dopcor_wave, dopcor_flux = spman.dopcor(wavelength, flux, dop_cor_single_shot_vel, dop_cor_have_vel)
                    wavelength = dopcor_wave
                    flux = dopcor_flux

                    #limits wavelength range. Put here because the dopcor task can modify it and I don't need earlier
                    wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

                    if event == 'Process selected' and save_intermediate_files == True:
                        file_dopcor = result_spec+'dopcor_' + prev_spec_nopath + '.fits'
                        uti.save_fits(wavelength, flux, file_dopcor)
                        print ('File saved: ', file_dopcor)
                        print('')
                elif (dop_cor == True and dop_cor_single_shot == False):
                    sg.popup('If you want to process just one file, please select the one shot value!')
                    continue


                #6) HELIOCENTRIC CORRECTION
                if (helio_corr == True and helio_single_shot == True):
                    task_done = 1
                    task_spec = 1
                    print ('*** Heliocentric correction ***')
                    correction, new_wavelength, new_flux = spman.helio_corr(wavelength, flux, helio_single_shot_date, helio_single_shot_location, ra_obj, dec_obj)
                    print ('Heliocentric correction: ', correction, 'km/s')
                    wavelength = new_wavelength
                    flux = new_flux

                    #limits wavelength range. Put here because the dopcor task can modify it and I don't need earlier
                    wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

                    if event == 'Process selected' and save_intermediate_files == True:
                        file_helio = result_spec+'helio_' + prev_spec_nopath + '.fits'
                        uti.save_fits(wavelength, flux, file_helio)
                        print ('File saved: ', file_helio)
                        print('')
                elif (helio_corr == True and helio_single_shot == False):
                    sg.popup('If you want to process just one file, please select the one shot value!')
                    continue



        #************************************** SPECTRA PROCESSING *************************

                #1) REBIN
                #if rebinning linear selected, I do it
                if rebinning == True and rebinning_linear == True:
                    task_done = 1
                    task_spec = 1
                    print ('*** Rebinning linear ***')
                    rebinned_wave, rebinned_flux, npoints = spman.resample(wavelength, flux, rebin_step_pix)

                    #update the variables. necessary because I will use always wavelength and flux for the other functions!
                    wavelength = rebinned_wave
                    flux = rebinned_flux

                    if event == 'Process selected' and save_intermediate_files == True:
                        file_rebinned = result_spec+'rebinned_' + prev_spec_nopath + '.fits'
                        uti.save_fits(wavelength, flux, file_rebinned)
                        print ('File saved: ', file_rebinned)
                        print('')

                #if rebinning log selected, I do it.
                if (rebinning == True and rebinning_log == True):
                    task_done = 1
                    task_spec = 1

                    print ('*** Rebinning log ***')
                    rebinned_wave_log, rebinned_flux_log = spman.log_rebin(wavelength, flux, rebin_step_sigma)
                    wavelength = rebinned_wave_log
                    flux = rebinned_flux_log

                    if event == 'Process selected' and save_intermediate_files == True:
                        file_rebinned_log = result_spec+'rebinned_log_' + prev_spec_nopath + '.fits'
                        uti.save_fits(wavelength, flux, file_rebinned)
                        print ('File saved: ', file_rebinned_log)
                        print('')



                # 2) DEGRADE RESOLUTION
                    #a) DEGRADE FROM R TO R
                if degrade == True and is_initial_res_r == True and res_degrade_to_r == True:

                    task_done = 1
                    task_spec = 1
                    print ('*** Degrade resolution ***')

                    degraded_wave, degraded_flux = spman.degrade(wavelength, flux, initial_res_r, final_res_r, True)
                    #update the variables. necessary because I will use always wavelength and flux for the other functions!
                    wavelength = degraded_wave
                    flux = degraded_flux

                    if event == 'Process selected' and save_intermediate_files == True:
                        degraded_res = str(int(round(final_res_r)))
                        file_degraded = result_spec+'degraded_R' + degraded_res + '_' + prev_spec_nopath + '.fits'
                        uti.save_fits(wavelength, flux, file_degraded)
                        print ('File saved: ', file_degraded)
                        print('')


                    #B) DEGRADE FROM R TO FWHM
                if degrade == True and is_initial_res_r == True and res_degrade_to_fwhm == True:
                    task_done = 1
                    task_spec = 1

                    print ('*** Degrade resolution from R to FWHM ***')

                    degraded_wave, degraded_flux = spman.degradeRtoFWHM(wavelength, flux, initial_res_r, final_res_r_to_fwhm)
                    wavelength = degraded_wave
                    flux = degraded_flux

                    if event == 'Process selected' and save_intermediate_files == True:
                        degraded_res_R_to_FWHM = str(float(round(final_res_r_to_fwhm,1)))
                        file_degraded_R_to_FWHM = result_spec+'degraded_FWHM' + degraded_res_R_to_FWHM + '_' + prev_spec_nopath + '.fits'
                        uti.save_fits(wavelength, flux, file_degraded_R_to_FWHM)
                        print ('File saved: ', file_degraded_R_to_FWHM)
                        print('')


                    #C) DEGRADE FROM FWHM TO FWHM
                if degrade == True and is_initial_res_fwhm == True:

                    task_done = 1
                    task_spec = 1

                    print ('*** Degrade resolution in FWHM ***')

                    degraded_wave, degraded_flux = spman.degrade_lambda(wavelength, flux, initial_res_fwhm, final_res_fwhm)
                    #update the variables. necessary because I will use always wavelength and flux for the other functions!
                    wavelength = degraded_wave
                    flux = degraded_flux

                    if event == 'Process selected' and save_intermediate_files == True:
                        degraded_res_lambda = str(float(round(final_res_fwhm,1)))
                        file_degraded_lambda = result_spec+'degraded_FWHM' + degraded_res_lambda + '_' + prev_spec_nopath + '.fits'
                        uti.save_fits(wavelength, flux, file_degraded_lambda)
                        print ('File saved: ', file_degraded_lambda)
                        print('')



                # 3) NORMALISE SPECTRUM TO
                if normalize_wave == True:
                    task_done = 1
                    task_spec = 1

                    #check the limits
                    if (norm_wave < wave_limits[0] or norm_wave > wave_limits[1]):
                        sg.popup('Normalisation wavelength exceeds the range of the spectrum!')
                        continue

                    print ('*** Normalise ***')
                    step = wavelength[1]-wavelength[0]
                    epsilon_norm = step*10. #averaging on 10 steps values, rather than one value
                    norm_flux = spman.norm_spec(wavelength, flux, norm_wave, epsilon_norm, flux)
                    flux = norm_flux

                    if event == 'Process selected' and save_intermediate_files == True:
                        norm_suffix = str(norm_wave)
                        file_normalized = result_spec+'norm' + norm_suffix + '_' + prev_spec_nopath + '.fits'
                        uti.save_fits(wavelength, flux, file_normalized)
                        print ('File saved: ', file_normalized)
                        print('')



                # 4) SIGMA BROADENING
                if (sigma_broad == True):
                    task_done = 1
                    task_spec = 1
                    print ('*** Sigma broadening ***')
                    broadened_flux = spman.sigma_broad(wavelength, flux, sigma_to_add)
                    flux = broadened_flux

                    if event == 'Process selected' and save_intermediate_files == True:
                        broad_suffix = str(int(round(sigma_to_add)))
                        file_broad = result_spec+'broad' + broad_suffix + prev_spec_nopath + '.fits'
                        uti.save_fits(wavelength, flux, file_broad)
                        print ('File saved: ', file_broad)
                        print('')



                # 5) ADD NOISE
                if (add_noise == True):
                    task_done = 1
                    task_spec = 1
                    print ('*** Add noise ***')
                    noisy_flux = spman.add_noise(wavelength, flux, noise_to_add)
                    flux = noisy_flux

                    if event == 'Process selected' and save_intermediate_files == True:
                        noise_suffix = str(int(round(noise_to_add)))
                        file_noise = result_spec+'SNR' + noise_suffix + prev_spec_nopath + '.fits'
                        uti.save_fits(wavelength, flux, file_noise)
                        print ('File saved: ', file_noise)
                        print('')



                # 6) CONTINUUM MODELLING
                if continuum_sub == True:
                    task_done = 1
                    task_spec = 1
                    print ('*** Continuum subtraction ***')

                    if cont_model_filtering == True:
                        #print (cont_math_operation)
                        corrected_flux, continuum_flux = spman.sub_cont(wavelength, flux, cont_math_operation)

                    if cont_model_poly == True:
                        if event == 'Process selected' or event == 'Preview result':
                            corrected_flux, continuum_flux = spman.continuum(wavelength, flux, cont_want_to_maks, cont_mask_ranges, cont_poly_degree, cont_math_operation, False)
                        else:
                            corrected_flux, continuum_flux = spman.continuum(wavelength, flux, cont_want_to_maks, cont_mask_ranges, cont_poly_degree, cont_math_operation, True)

                    flux = corrected_flux

                    if event == 'Process selected' and save_intermediate_files == True:
                        file_cont_sub = result_spec+'cont_sub_' + prev_spec_nopath + '.fits'
                        file_cont = result_spec+'cont_' + prev_spec_nopath + '.fits'
                        uti.save_fits(wavelength, flux, file_cont_sub)
                        uti.save_fits(wavelength, continuum_flux, file_cont)
                        print ('File saved: ', file_cont_sub)
                        print ('File saved: ', file_cont)
                        print('')


        #************************************** SPEC MATH *******************************************

                # 1) subtract normalized average
                if (subtract_normalized_avg == True and values['one_spec'] == False):
                    task_done = 1
                    task_spec = 1
                    print ('*** Subract normalised average ***')
                    subtracted_flux = spmt.sub_norm_avg(wavelength, flux, lambda_units, spectra_number, spec_names)
                    flux = subtracted_flux

                    if event == 'Process selected' and save_intermediate_files == True:
                        file_subtracted_avg = result_spec+'subtracted_average' + prev_spec_nopath + '.fits'
                        uti.save_fits(wavelength, flux, file_subtracted_avg)
                        print ('File saved: ', file_subtracted_avg)
                        print('')
                if (subtract_normalized_avg == True and values['one_spec'] == True):
                    sg.popup('There is no average to subtract!')
                    continue

                # 2) subtract normalized single
                if (subtract_normalized_spec == True):
                    task_done = 1
                    task_spec = 1
                    print ('*** Subtract normalised spectrum ***')

                    #test if file file exist
                    cond0 = (os.path.isfile(spectra_to_subtract))
                    if cond0 == False:
                        sg.popup('The file to subtract does not exist. Skipping...')
                        continue

                    subtracted_single_flux = spmt.sub_norm_single(wavelength, flux, spectra_to_subtract, lambda_units)
                    flux = subtracted_single_flux

                    if event == 'Process selected' and save_intermediate_files == True:
                        file_subtracted_single = result_spec+'subtracted_single' + prev_spec_nopath + '.fits'
                        uti.save_fits(wavelength, flux, file_subtracted_single)
                        print ('File saved: ', file_subtracted_single)
                        print('')

                # 3) add pedestal
                if (add_pedestal == True):
                    task_done = 1
                    task_spec = 1
                    print ('*** Add pedestal ***')
                    flux = flux + pedestal_to_add

                    if event == 'Process selected' and save_intermediate_files == True:
                        pedestal_suffix = str(int(round(pedestal_to_add)))
                        file_pedestal = result_spec+'pedestal' + pedestal_suffix + prev_spec_nopath + '.fits'
                        uti.save_fits(wavelength, flux, file_pedestal)
                        print ('File saved: ', file_pedestal)
                        print('')

                # 4) multiply by a constant
                if (multiply == True):
                    task_done = 1
                    task_spec = 1
                    print ('*** Multiply by a constant ***')
                    flux = flux*multiply_factor

                    if event == 'Process selected' and save_intermediate_files == True:
                        multiplied_suffix = str(int(round(multiply_factor)))
                        file_multiplied = result_spec+'multiplied' + multiplied_suffix + prev_spec_nopath + '.fits'
                        uti.save_fits(wavelength, flux, file_multiplied)
                        print ('File saved: ', file_multiplied)
                        print('')


                # 5) derivatives
                if (derivatives == True):
                    task_done = 1
                    task_spec = 1
                    print ('*** First and second derivatives ***')
                    print ('WARNING: these are NOT used for spectral analysis tasks')

                    try:
                        first_derivative = np.gradient(flux, wavelength)
                        second_derivative = np.gradient(first_derivative, wavelength)

                        #plotting
                        plt.figure(figsize=(12, 8))

                        plt.subplot(3, 1, 1)
                        plt.plot(wavelength, flux, label='Original spectrum')
                        plt.title('Spectra derivatives')
                        plt.xlabel('Wavelength (nm)')
                        plt.ylabel('Flux')
                        plt.legend()

                        plt.subplot(3, 1, 2)
                        plt.plot(wavelength, first_derivative, label='First derivative')
                        plt.title('First derivative')
                        plt.xlabel('Wavelength (nm)')
                        plt.ylabel('Flux')
                        plt.legend()

                        plt.subplot(3, 1, 3)
                        plt.plot(wavelength, second_derivative, label='Second derivative')
                        plt.title('Second derivative')
                        plt.xlabel('Wavelength (nm)')
                        plt.ylabel('Flux')
                        plt.legend()

                        plt.tight_layout()
                        plt.show()
                        plt.close()

                        if event == 'Process selected':
                            #derivative_suffix = str(int(round(multiply_factor)))
                            file_first_derivative = result_spec+'first_deriv_'+ prev_spec_nopath + '.fits'
                            file_second_derivative = result_spec+'second_deriv_'+ prev_spec_nopath + '.fits'
                            uti.save_fits(wavelength, first_derivative, file_first_derivative)
                            uti.save_fits(wavelength, second_derivative, file_second_derivative)
                            print ('Derivative spectra saved: ', file_first_derivative, file_second_derivative)
                            print('')
                    except Exception:
                        print ('Cannot compute the derivatives. Skipping...')

                # end spectra manipulation tasks acting on single spectrum
    ##################################################################################################


            #plotting. Not for the average and sum methods, that is if do_nothing == True
            if (do_nothing == True and event == 'Preview spec.'):
                try:
                    plt.plot(original_wavelength, original_flux, label = 'Original spec.')
                    plt.plot(wavelength, flux, label = 'Processed')
                    plt.xlabel('Wavelength nm', fontsize = 9)
                    plt.title(prev_spec_nopath)
                    plt.ylabel('Flux')
                    plt.legend(fontsize = 10)
                    plt.show()
                    plt.close()
                except ValueError:
                    print ('Something went wrong, cannot complete the task. Check the spectrum. Tip: it is really a spectrum?')
                    continue


            #math operations within all the spectra. Stand-alone task
            if (do_nothing == False):
                print ('WARNING: I will discard all the activated tasks to perform thie operation')

            #average all
                if (average_all == True and values['one_spec'] == False):
                    task_done = 1
                    task_spec = 1
                    print ('*** Average all ***')
                    average_spec = spmt.average(lambda_units, spectra_number, spec_names)
                    proc_wavelength = average_spec[:,0]
                    proc_flux = average_spec[:,1]

                    if event == 'Process selected' and save_intermediate_files == True:
                        file_avg = result_spec+'avg_spectra.fits'
                        uti.save_fits(proc_wavelength, proc_flux, file_avg)
                        print ('File saved: ', file_avg)
                        print('')
                if (average_all == True and values['one_spec'] == True):
                    sg.popup ('You just have one spectrum. Cannot do what you want!')
                    continue

                #normalize and average
                if (norm_and_average == True and values['one_spec'] == False):
                    task_done = 1
                    task_spec = 1
                    print ('*** Normalise and average all ***')
                    average_norm_spec = spmt.average_norm(lambda_units, wavelength, flux, spectra_number, spec_names)
                    proc_wavelength = average_norm_spec[:,0]
                    proc_flux = average_norm_spec[:,1]

                    if event == 'Process selected' and save_intermediate_files == True:
                        #saving file. No need to put the save intermediate option.
                        file_avg_norm = result_spec+'norm_avg_spectra.fits'
                        uti.save_fits(proc_wavelength, proc_flux, file_avg_norm)
                        print ('File saved: ', file_avg_norm)
                        print('')
                if (norm_and_average == True and values['one_spec'] == True):
                    sg.popup ('You just have one spectrum. Cannot do what you want!')
                    continue

                #sum all
                if (sum_all == True and values['one_spec'] == False):
                    task_done = 1
                    task_spec = 1
                    print ('*** Sum all ***')
                    sum_spec = spmt.sum_spec(lambda_units, spectra_number, spec_names)
                    proc_wavelength = sum_spec[:,0]
                    proc_flux = sum_spec[:,1]

                    if event == 'Process selected' and save_intermediate_files == True:
                        #saving file. No need to put the save intermediate option.
                        file_sum = result_spec+'sum_spectra.fits'
                        uti.save_fits(proc_wavelength, proc_flux, file_sum)
                        print ('File saved: ', file_sum)
                        print('')
                if (sum_all == True and values['one_spec'] == True):
                    sg.popup ('You just have one spectrum. Cannot do what you want!')
                    continue

                #normalize and sum
                if (normalize_and_sum_all == True and values['one_spec'] == False):
                    task_done = 1
                    task_spec = 1
                    print ('*** Normalise and sum all ***')
                    sum_norm_spec = spmt.sum_norm_spec(lambda_units, spectra_number, spec_names)
                    proc_wavelength = sum_norm_spec[:,0]
                    proc_flux = sum_norm_spec[:,1]

                    if event == 'Process selected' and save_intermediate_files == True:
                        #saving file. No need to put the save intermediate option.
                        file_sum_norm = result_spec+'norm_sum_spectra.fits'
                        uti.save_fits(proc_wavelength, proc_flux, file_sum_norm)
                        print ('File saved: ', file_sum_norm)
                        print('')
                if (normalize_and_sum_all == True and values['one_spec'] == True):
                    sg.popup ('You just have one spectrum. Cannot do what you want!')
                    continue

                if (use_for_spec_an == True and values['one_spec'] == False):
                    print ('Using sum or average to spectral analysis')
                    wavelength = proc_wavelength
                    flux = proc_flux
                if (use_for_spec_an == True and values['one_spec'] == True):
                    sg.popup ('You just have one spectrum. Cannot do what you want!')
                    continue

                #plotting the spech mat average and sum all
                if (event == 'Preview spec.' and do_nothing == False  and values['one_spec'] == False):
                    plt.plot(original_wavelength, original_flux, label = 'Original spec.')
                    plt.plot(proc_wavelength, proc_flux, label = 'Processed')
                    plt.xlabel('Wavelength nm', fontsize = 9)
                    plt.title('Combined all')
                    plt.ylabel('Flux')
                    plt.legend(fontsize = 10)
                    plt.show()
                    plt.close()
                if (event == 'Preview spec.' and do_nothing == False  and values['one_spec'] == True):
                    sg.popup ('You just have one spectrum. Cannot do what you want!')
                    continue


    #************************************** SPECTRA ANALYSIS ********************************

            # 1) BLACKBODY FITTING
            task_analysis = 0
            if (bb_fit == True and (event == 'Process selected' or event == 'Preview result')):
                task_done = 1
                task_analysis = 1
                #store the spectrum in temp variables
                wavelength_temp = wavelength
                flux_temp = flux

                if wave1_bb >= wave2_bb:
                    sg.popup ('Like I said, the first wavelength cannot be greater than the second!')
                    continue

                #check the limits
                if (wave1_bb < wave_limits[0] or wave2_bb > wave_limits[1]):
                    sg.popup('Wavelength interval for blackbody fitting exceeds the range of the spectrum!')
                    continue

                print ('*** Blackbody fitting *** ')

                temperature_bb, residual_bb = span.blackbody_fit(wavelength, flux, wave1_bb, wave2_bb, t_guess, True)
                print ('Best Black body temperature: ', int(temperature_bb), ' K')
                print ('')



            # 2) CROSS-CORRELATION
            if (cross_corr == True and (event == 'Process selected' or event == 'Preview result')):
                task_done = 1
                task_analysis = 1
                #store the spectrum in temp variables
                wavelength_temp = wavelength
                flux_temp = flux
                #test if file file exist
                cond01 = (os.path.isfile(template_crosscorr))
                if cond01 == False:
                    sg.popup('The template file does not exist. Skipping...')
                    continue

                #reading the template for the check
                wave_temp_xcorr, flux_temp_xcorr, step_temp_xcorr, name_temp_xcorr = stm.read_spec(template_crosscorr, lambda_units_template_crosscorr)
                wave_limits_template_xcorr = np.array([wave_temp_xcorr[0], wave_temp_xcorr[len(wave_temp_xcorr)-1]])

                #check the limits
                if (real_low_wave_corr < wave_limits[0] or real_high_wave_corr > wave_limits[1] or real_low_wave_corr < wave_limits_template_xcorr[0] or real_high_wave_corr > wave_limits_template_xcorr[1]):
                    sg.popup('Wavelength interval for cross-correlation exceeds the range of the spectrum or the template!')
                    continue

                print ('*** Cross-correlation *** ')

                if is_vel_xcorr == True:
                    try:
                        rv, cc, rv_at_max, max_corr_fcn, wavelength_temp, flux_temp, wavelength_template_crosscorr, flux_template_crosscorr = span.crosscorr (wavelength_temp, flux_temp, template_crosscorr, lambda_units_template_crosscorr, wave_interval_corr, smooth_value_crosscorr, vel_interval_corr, is_vel_xcorr)
                        print ('Rv:', rv_at_max, 'km/s')
                        print ('')

                        #if preview result I do also the plots
                        if event == 'Preview result':
                            rv_plot = str(round(rv_at_max,1))
                            fig, (ax1, ax2) = plt.subplots(1, 2, figsize = (8.5,4.5))
                            fig.suptitle('Cross-correlation for ' + prev_spec_nopath + ' with ' + template_crosscorr)
                            ax1.plot(rv, cc)
                            ax1.plot(rv_at_max, max_corr_fcn, 'ro', label = 'RV: ' + rv_plot + 'km/s')
                            ax1.set_xlabel('RV (km/s)')
                            ax1.set_ylabel('Xcorr fcn')
                            ax1.legend(fontsize = 10)

                            ax2.plot(wavelength_temp, flux_temp/np.median(flux_temp), label = 'Spectrum')
                            ax2.plot(wavelength_template_crosscorr, flux_template_crosscorr, label = 'Template')
                            ax2.set_xlim(real_low_wave_corr, real_high_wave_corr)
                            ax2.set_ylim(0.4, 1.8)
                            ax2.set_xlabel('Wavelength (nm)')
                            ax2.set_ylabel('Norm flux')
                            ax2.legend(fontsize = 10)
                            plt.show()
                            plt.close()
                    except Exception as e:
                        sg.Popup ('Cannot find cross-correlation within the velocity ranges you inserted. Try again with different (smaller?) ranges')

                if is_vel_xcorr == False:

                    try:
                        z, cc, z_at_max, max_corr_fcn, wavelength_temp, flux_temp, wavelength_template_crosscorr, flux_template_crosscorr = span.crosscorr (wavelength_temp, flux_temp, template_crosscorr, lambda_units_template_crosscorr, wave_interval_corr, smooth_value_crosscorr, z_interval_corr, is_vel_xcorr)
                        print ('Z:', z_at_max)
                        print ('')

                        #if preview result I do also the plots
                        if event == 'Preview result':
                            z_plot = str(round(z_at_max,5))
                            fig, (ax1, ax2) = plt.subplots(1, 2, figsize = (8.5,4.5))
                            fig.suptitle('Cross-correlation for ' + prev_spec_nopath + ' with ' + template_crosscorr)
                            ax1.plot(z, cc)
                            ax1.plot(z_at_max, max_corr_fcn, 'ro', label = 'Z: ' + z_plot)
                            ax1.set_xlabel('Z')
                            ax1.set_ylabel('Xcorr fcn')
                            ax1.legend(fontsize = 10)

                            ax2.plot(wavelength_temp, flux_temp/np.median(flux_temp), label = 'Spectrum')
                            ax2.plot(wavelength_template_crosscorr, flux_template_crosscorr, label = 'Template')
                            ax2.set_xlim(real_low_wave_corr, real_high_wave_corr)
                            ax2.set_ylim(0.4, 1.8)
                            ax2.set_xlabel('Wavelength (nm)')
                            ax2.set_ylabel('Norm flux')
                            ax2.legend(fontsize = 10)
                            plt.show()
                            plt.close()
                    except Exception as e:
                        sg.Popup ('Cannot find cross-correlation within the z ranges you inserted. Try again with different (smaller?) ranges')


            # 3) VELOCITY DISPERSION
            if (sigma_measurement == True and event == 'Process selected'):
                task_done = 1
                task_analysis = 1
                #test if file file exist
                cond02 = (os.path.isfile(template_sigma))
                if cond02 == False:
                    sg.popup('The template file does not exist. Skipping...')
                    continue

                #reading the template for the check
                wave_temp_sigma, flux_temp_sigma, step_temp_sigma, name_temp_sigma = stm.read_spec(template_sigma, lambda_units_template_sigma)
                wave_limits_template_sigma = np.array([wave_temp_sigma[0], wave_temp_sigma[len(wave_temp_sigma)-1]])

                #check the limits, for the spectrum and the template
                if ((band_sigma[0] < wave_limits[0] or cont_sigma[0] < wave_limits[0] or band_sigma[1]> wave_limits[1] or cont_sigma[1] > wave_limits[1] or band_sigma[0] < wave_limits_template_sigma[0] or cont_sigma[0] < wave_limits_template_sigma[0] or band_sigma[1]> wave_limits_template_sigma[1] or cont_sigma[1] > wave_limits_template_sigma[1])):
                    sg.popup('Wavelength interval for the band is out the range of the spectrum or the template!')
                    continue

                if (band_custom == True and (band_sigma[0] > band_sigma[1] or cont_sigma[0] > cont_sigma[1])):
                    sg.popup('It seems we have a problem. Did you invert the wavelength range?')
                    continue

                print ('*** Sigma measurement (might take a while!) ***')
                sigma, error, chisqr, band_wave, band_flux, band_flux_template_fitted, sigma_instrumental = span.sigma_measurement(wavelength, flux, template_sigma, lambda_units_template_sigma, resolution_spec, resolution_template, band_sigma, cont_sigma, True)
                print (prev_spec_nopath)
                print ('Sigma: ', sigma, '+/-', round(error,2), '    Chi Square: ', chisqr)
                print ('')

            if (sigma_measurement == True and event == 'Preview result'):
                task_done = 1
                task_analysis = 1
                #test if file file exist
                cond02 = (os.path.isfile(template_sigma))
                if cond02 == False:
                    sg.popup('The template file does not exist. Skipping...')
                    continue

                            #reading the template for the check
                wave_temp_sigma, flux_temp_sigma, step_temp_sigma, name_temp_sigma = stm.read_spec(template_sigma, lambda_units_template_sigma)
                wave_limits_template_sigma = np.array([wave_temp_sigma[0], wave_temp_sigma[len(wave_temp_sigma)-1]])

                if ((band_sigma[0] < wave_limits[0] or cont_sigma[0] < wave_limits[0] or band_sigma[1]> wave_limits[1] or cont_sigma[1] > wave_limits[1] or band_sigma[0] < wave_limits_template_sigma[0] or cont_sigma[0] < wave_limits_template_sigma[0] or band_sigma[1]> wave_limits_template_sigma[1] or cont_sigma[1] > wave_limits_template_sigma[1])):
                    sg.popup('Wavelength interval for the band is out the range of the spectrum or the template!')
                    continue

                if (band_custom == True and (band_sigma[0] > band_sigma[1] or cont_sigma[0] > cont_sigma[1])):
                    sg.popup('It seems we have a problem. Did you invert the wavelength range?')
                    continue

                sigma, error, chisqr, band_wave, band_flux, band_flux_template_fitted, sigma_instrumental = span.sigma_measurement(wavelength, flux, template_sigma, lambda_units_template_sigma, resolution_spec, resolution_template, band_sigma, cont_sigma, False) # False means that I don't calculate the errors in the sigma_measurement function. Useful if you want to save time!

                if sigma == sigma_instrumental:
                    sg.popup('WARNING: The real velocity dispersion is lower than the instrumental sigma of the spectrum. Do not trust the result!')

                #plot
                sigma_title = str(round(sigma,1))

                fig, (ax1, ax2) = plt.subplots(2, figsize = (8.5,8.5), gridspec_kw={'height_ratios': [3, 1]})

                fig.suptitle(prev_spec_nopath + '  Sigma:' + sigma_title + 'km/s')
                ax1.plot(band_wave, band_flux, label = 'Spectrum')
                ax1.plot(band_wave, band_flux_template_fitted, label = 'Fitted template')
                ax1.set_xlabel('Wavelength (nm)')
                ax1.set_ylabel('Norm flux')
                ax1.legend(fontsize = 10)

                #plot residuals
                ax2.plot(band_wave, band_flux-band_flux_template_fitted, linewidth=0.5, label = 'Residuals')
                ax2.hlines(y=0, xmin=min(band_wave), xmax=max(band_wave), linestyles='--', lw=2, linewidth=2, color='r')
                ax2.set_xlabel('Wavelength (nm)')
                ax2.set_ylabel('Residuals')
                ax2.legend(fontsize = 10)
                plt.show()
                plt.close()



            # 4) EQUIVALENT WIDTH (EW)
                #a) If I want to measure just one index
            if (ew_measurement == True and single_index == True and (event == 'Process selected' or event == 'Preview result')):
                task_done = 1
                task_analysis = 1
                #checking limits
                if (np.min(index_usr) < wave_limits[0] or np.max(index_usr > wave_limits[1])):
                    sg.popup ('The index definition wavelength exceeds the wavelength range of the spectrum')
                    continue

                #verify the index definition is in the correct sequence
                if (index_usr[0] > index_usr[1] or index_usr[2] >index_usr[3] or index_usr[4] > index_usr[5]):
                    sg.popup('It seems we have a problem. Did you invert the wavelengths of the indices?')
                    continue

                print ('*** Equivalent width measurement for a single index ***')

                plot = True
                verbose = True
                with_uncertainties = True
                no_save_plot = False
                normalise_spec = True

                id_array, ew_array, err_array, snr_ew_array,ew_array_mag, err_array_mag = ls.ew_measurement(wavelength, flux, index_usr, single_index, plot, verbose, with_uncertainties, no_save_plot, prev_spec, normalise_spec, result_plot_dir)

                print ('EW:', round(ew_array,3), '+/-', round(err_array,3))
                print ('EW Mag:', round(ew_array_mag,3), '+/-', round(err_array_mag,3))
                print ('SNR:', int(snr_ew_array), 'per pix')
                print ('')

                #b) If I have an index list file
            if (ew_measurement == True and have_index_file == True and (event == 'Process selected' or event == 'Preview result')):
                task_done = 1
                task_analysis = 1
                #chechink if the file exist
                cond03 = (os.path.isfile(index_file))
                if cond03 == False:
                    sg.popup('The index file does not exist. Skipping...')
                    continue

                print ('*** Equivalent width measurement for a list of indices ***')

                #exploring the index file for errors
                try:
                    idx_names, indices = ls.read_idx(index_file)
                except ValueError:
                    sg.popup('At least one index in the file is not valid')
                    continue

                if len(indices[:,0]) < 6:
                    sg.popup ('The length of at least one index is not correct')
                    continue

                bad_idx = []
                num_indices_test = len(idx_names)
                true_cond = 0
                idx_error = 0
                for t in range(num_indices_test):
                    if (indices[0,t] > indices[1,t] or indices[2,t] > indices[3,t] or indices[4,t] > indices[5,t]):
                        bad_idx.append(idx_names[t])
                        true_cond = 1
                if true_cond == 1:
                    sg.popup('It seems we have a problem. Did you invert the wavelengths of these indices?', bad_idx)
                    continue

                if (event == 'Preview result'):
                    plot = True
                    verbose = True
                    with_uncertainties = True
                    no_save_plot = False
                    normalise_spec = True

                    id_array, ew_array, err_array, snr_ew_array, ew_array_mag, err_array_mag = ls.ew_measurement(wavelength, flux, index_file, single_index, plot, verbose, with_uncertainties, no_save_plot, prev_spec, normalise_spec, result_plot_dir)

                else:
                    plot = False
                    verbose = True
                    with_uncertainties = True
                    normalise_spec = True

                    id_array, ew_array, err_array, snr_ew_array, ew_array_mag, err_array_mag = ls.ew_measurement(wavelength, flux, index_file, single_index, plot, verbose, with_uncertainties, save_plot, prev_spec_nopath, normalise_spec, result_plot_dir)
                print (id_array)
                print (np.round(ew_array,3))
                print ('EW in Mag: ', np.round(ew_array,3))
                print ('SNR: ', np.round(snr_ew_array), 'per pix')

                #c) If I want to measure the Lick/IDS indices
            if (ew_measurement == True and lick_ew == True and (event == 'Process selected' or event == 'Preview result')):
                task_done = 1
                task_analysis = 1

                print ('*** Equivalent width measurement of Lick/IDS indices ***')

                # 1) reading the Lick index file
                lick_idx_names, lick_indices = ls.read_idx(lick_index_file)


                lick_wavelength = wavelength
                lick_flux = flux
                blocking_cond = 0
                #checking limits
                #wave limits of the spectrum
                lick_wave_limits = np.array([lick_wavelength[0], lick_wavelength[len(lick_wavelength)-1]])
                lick_wave_lower_limit = 420
                lick_wave_upper_limit = 630

                if ((lick_wave_limits[0] < lick_wave_lower_limit and lick_wave_limits[1]< lick_wave_lower_limit) or (lick_wave_limits[0] > lick_wave_upper_limit and lick_wave_limits[1]> lick_wave_upper_limit)):
                    sg.Popup ('The window band is completely off the spectrum range')
                    blocking_cond = 1

                if blocking_cond == 0:
                    # 2) If I want to correct for the emission or doppler correction or sigma correction
                    if lick_correct_emission == True or dop_correction_lick == True or (correct_ew_sigma == True and radio_lick_sigma_auto == True):

                        #1 running ppxf to fit the emission and retrieve the emission corrected spectra with parameters optimised for kinematics
                        additive_degree_lick = -1 #Not using additive degree to preserve the absorption lines
                        multiplicative_degree_lick = 10
                        min_wavelength = np.min(lick_wavelength)
                        max_wavelength = np.max(lick_wavelength)

                        #since ppxf is time consuming, let's limit the wavelength interval to correct the emission
                        if max_wavelength > 650:
                            max_wavelength_lick = 650
                        else:
                            max_wavelength_lick = max_wavelength
                        if min_wavelength < 400:
                            min_wavelength_lick = 400
                        else:
                            min_wavelength_lick = min_wavelength

                        sigma_guess_lick = 100
                        fit_components_lick = ('with_gas')
                        lick_ppxf_with_errors = False
                        lick_save_plot = False
                        regul_err_lick = 0.04 #force some regularization to smooth the fit
                        ppxf_pop_noise_lick = 0.0163 #use a random noise value
                        ppxf_pop_age_range_lick = np.array([0,16])
                        ppxf_pop_met_range_lick = np.array([-2,0.8])

                        if lick_correct_emission == True:
                            print ('Removing the emission lines with ppxf...')
                        if dop_correction_lick == True:
                            print('Doppler correction with ppxf...')


                        emiles_resolution = 2.5

                        #setting up the other parameters for pPXF
                        convolve_temp_lick = True #convolve the templates to galaxy resolution to a better estimation of sigma
                        have_user_mask_lick = False
                        mask_ranges_lick = None
                        custom_emiles_lick = False
                        custom_emiles_folder_lick = None
                        custom_npz_lick = False
                        custom_npz_file_lick = None
                        mask_emission_lick = False
                        custom_temp_suffix_lick = None
                        best_param_lick = False
                        best_noise_estimate_lick = False
                        frac_chi_lick = 1
                        dust_correction_stars_lick = False
                        dust_correction_gas_lick = False
                        tied_balmer_lick = False
                        spec_name_lick = None
                        with_plots_lick = False
                        ppxf_pop_error_nsim_lick = None
                        lick_lg_age = True

                        #performing ppxf
                        if lick_constant_fwhm == True: # with a fixed delta lambda resolution, no problem
                            #issue a warning in case the resolution of EMILES templates is lower than the galaxy
                            if spec_lick_res_fwhm < emiles_resolution:
                                print('WARNING: the resolution of the templates is REALLY lower than the galaxy. Consider to first reduce the resolution of your spectrum with the Degrade resolution task')

                            kinematics_lick, info_pop_lick, info_pop_mass_lick, mass_light_lick, errors_lick, galaxy_lick, bestfit_flux_lick, bestfit_wave_lick, bestfit_flux_gas_lick, residual_lick, chi_square_lick, age_err_lower_abs_lick, age_err_upper_abs_lick, met_err_lower_lick, met_err_upper_lick, alpha_err_lower_lick, alpha_err_upper_lick, mass_age_err_lower_abs_lick, mass_age_err_upper_abs_lick, mass_met_err_lower_lick, mass_met_err_upper_lick, mass_alpha_err_lower_lick, mass_alpha_err_upper_lick, emission_corrected_flux, pop_age, light_weights_age_bin, mass_weights_age_bin, cumulative_mass, snr_pop_lick, light_weights_lick, mass_weights_lick = span.ppxf_pop(lick_wavelength, lick_flux, min_wavelength_lick, max_wavelength_lick, spec_lick_res_fwhm, z_guess_lick_emission, sigma_guess_lick, fit_components_lick, with_plots_lick, lick_ppxf_with_errors, lick_save_plot, spec_name_lick, regul_err_lick, additive_degree_lick, multiplicative_degree_lick, tied_balmer_lick, stellar_library_lick, dust_correction_stars_lick, dust_correction_gas_lick, ppxf_pop_noise_lick, ppxf_pop_age_range_lick, ppxf_pop_met_range_lick, custom_emiles_lick, custom_emiles_folder_lick, custom_npz_lick, custom_npz_file_lick, mask_emission_lick, custom_temp_suffix_lick, best_param_lick, best_noise_estimate_lick, frac_chi_lick, convolve_temp_lick, have_user_mask_lick, mask_ranges_lick, ppxf_pop_error_nsim_lick, lick_lg_age, result_plot_dir)


                        #if I don't have a constant FWHM resolution:
                        if lick_constant_fwhm == False:
                            #considering a mean fwhm along the lick band. The errors for the indices used for stellar parameters are about 5%, so it's good for now.
                            mean_ref_lick_wavelength = 508
                            spec_lick_res_fwhm = mean_ref_lick_wavelength/spec_lick_res_r*10 #converting in A

                            #issue a warning in case the resolution of EMILES templates is lower than the galaxy
                            if spec_lick_res_fwhm < emiles_resolution:
                                print('WARNING: the resolution of the templates is REALLY lower than the galaxy. Consider to first reduce the resolution of your spectrum with the Degrade resolution task')

                            kinematics_lick, info_pop_lick, info_pop_mass_lick, mass_light_lick, errors_lick, galaxy_lick, bestfit_flux_lick, bestfit_wave_lick, bestfit_flux_gas_lick, residual_lick, chi_square_lick, age_err_lower_abs_lick, age_err_upper_abs_lick, met_err_lower_lick, met_err_upper_lick, alpha_err_lower_lick, alpha_err_upper_lick, mass_age_err_lower_abs_lick, mass_age_err_upper_abs_lick, mass_met_err_lower_lick, mass_met_err_upper_lick, mass_alpha_err_lower_lick, mass_alpha_err_upper_lick, emission_corrected_flux, pop_age, light_weights_age_bin, mass_weights_age_bin, cumulative_mass, snr_pop_lick, light_weights_lick, mass_weights_lick = span.ppxf_pop(lick_wavelength, lick_flux, min_wavelength_lick, max_wavelength_lick, spec_lick_res_fwhm, z_guess_lick_emission, sigma_guess_lick, fit_components_lick, with_plots_lick, lick_ppxf_with_errors, lick_save_plot, spec_name_lick, regul_err_lick, additive_degree_lick, multiplicative_degree_lick, tied_balmer_lick, stellar_library_lick, dust_correction_stars_lick, dust_correction_gas_lick, ppxf_pop_noise_lick, ppxf_pop_age_range_lick, ppxf_pop_met_range_lick, custom_emiles_lick, custom_emiles_folder_lick, custom_npz_lick, custom_npz_file_lick, mask_emission_lick, custom_temp_suffix_lick, best_param_lick, best_noise_estimate_lick, frac_chi_lick, convolve_temp_lick, have_user_mask_lick, mask_ranges_lick, ppxf_pop_error_nsim_lick, lick_lg_age, result_plot_dir)


                        if lick_correct_emission == True:
                            lick_wavelength = bestfit_wave_lick/10
                            lick_flux = emission_corrected_flux #using the emission corrected flux from PPXF
                            lick_step = lick_wavelength[1] - lick_wavelength[0]

                            #rebinning linear
                            lick_wavelength, lick_flux, npoint_resampled = spman.resample(lick_wavelength, lick_flux, lick_step)


                        if dop_correction_lick == True: #CAUTION HERE: IF PPXF FINDS NO GAS COMPONENTS?
                            #rebinning linear if not done before
                            if lick_correct_emission == False:
                                #rebinning linear
                                lick_flux = galaxy_lick #using the galaxy flux from pPXF
                                lick_wavelength = bestfit_wave_lick/10 #using the wavelength grid from pPXF
                                lick_step = lick_wavelength[1] - lick_wavelength[0]
                                lick_wavelength, lick_flux, npoint_resampled = spman.resample(lick_wavelength, lick_flux, lick_step) #Rebinning linear
                            lick_doppler_vel = (kinematics_lick[0])
                            dop_vel = lick_doppler_vel[0]
                            lick_wavelength, lick_flux = spman.dopcor(lick_wavelength, lick_flux, dop_vel, True) #doppler correction. The cosmological z correction has been already performed by the span.ppxf_pop function, prior to really run pPXF. Here I correct only for the real velocity component measured by the fit.

                        if radio_lick_sigma_auto == True:
                            sigma_lick_ppxf = (kinematics_lick[0])
                            sigma_to_correct_lick = sigma_lick_ppxf[1]



                    # 3) degrading the resolution, only if smaller than the lick system
                    if lick_constant_fwhm == True and spec_lick_res_fwhm < 8.4:
                        lick_degraded_wavelength, lick_degraded_flux = spman.degrade_to_lick(lick_wavelength, lick_flux, spec_lick_res_fwhm, lick_constant_fwhm)
                    elif lick_constant_fwhm == False and spec_lick_res_r > 600:
                        lick_degraded_wavelength, lick_degraded_flux = spman.degrade_to_lick(lick_wavelength, lick_flux, spec_lick_res_r, lick_constant_fwhm)
                    else:
                        print('WARNING: The resolution of the spectrum is smaller than the one needed for the Lick/IDS system. I will still calculate the Lick/IDS indices but the results might be inaccurate.')
                        lick_degraded_wavelength = lick_wavelength
                        lick_degraded_flux = lick_flux


                    # 4) Measuring the EW and doing plot
                    if (event == 'Preview result'):
                        lick_single_index = False
                        lick_ew_plot = True
                        lick_verbose = True
                        lick_with_uncertainties = True
                        lick_save_plot = False
                        lick_normalise_spec = True

                        lick_id_array, lick_ew_array, lick_err_array, lick_snr_ew_array, lick_ew_array_mag, lick_err_array_mag = ls.ew_measurement(lick_degraded_wavelength, lick_degraded_flux, lick_index_file, lick_single_index, lick_ew_plot, lick_verbose, lick_with_uncertainties, lick_save_plot, prev_spec, lick_normalise_spec, result_plot_dir)

                        print (lick_id_array)
                        print (lick_ew_array)
                        print ('')
                        print ('Raw EW in Mag: ')
                        print (np.round(lick_ew_array_mag, decimals = 3))
                        print ('SNR: ')
                        print (np.round(lick_snr_ew_array), 'per pix')
                        print ('')

                        # 4) Correcting the EWs
                        if correct_ew_sigma == True and radio_lick_sigma_single == True:
                            corrected_lick_ew_array, corrected_lick_err_array, corrected_lick_ew_mag_array, corrected_lick_err_mag_array = ls.corr_ew_lick(lick_ew_array, lick_err_array, lick_ew_array_mag, sigma_lick_coeff_file, sigma_single_lick)

                            print ('Corrected EWs for sigma (A):')
                            print (np.round(corrected_lick_ew_array, decimals = 3))
                            print ('Corrected Errors for sigma:')
                            print (np.round(corrected_lick_err_array, decimals = 3))
                            print ('Corrected EWs for sigma (mag):')
                            print (np.round(corrected_lick_ew_mag_array, decimals = 3))
                            print ('Corrected mag Errors for sigma: ')
                            print (np.round(corrected_lick_err_mag_array, decimals = 3))
                            print ('')

                            #uodating the values
                            lick_ew_array = corrected_lick_ew_array
                            lick_err_array = corrected_lick_err_array
                            lick_ew_array_mag = corrected_lick_ew_mag_array
                            lick_err_array_mag = corrected_lick_err_mag_array

                        if correct_ew_sigma == True and radio_lick_sigma_list == True:
                            print ('WARNING: cannot correct for sigma broadening one spectrum with a list of sigmas. Select the single value. Skipping the correction for now...')

                        if correct_ew_sigma == True and radio_lick_sigma_auto == True:
                            corrected_lick_ew_array, corrected_lick_err_array, corrected_lick_ew_mag_array, corrected_lick_err_mag_array = ls.corr_ew_lick(lick_ew_array, lick_err_array, lick_ew_array_mag, sigma_lick_coeff_file, sigma_to_correct_lick)

                            print ('Corrected EWs for sigma (A):')
                            print (np.round(corrected_lick_ew_array, decimals = 3))
                            print ('Corrected Errors for sigma:')
                            print (np.round(corrected_lick_err_array, decimals = 3))
                            print ('Corrected EWs for sigma (mag):')
                            print (np.round(corrected_lick_ew_mag_array, decimals = 3))
                            print ('Corrected mag Errors for sigma: ')
                            print (np.round(corrected_lick_err_mag_array, decimals = 3))
                            print ('')

                            #uodating the values
                            lick_ew_array = corrected_lick_ew_array
                            lick_err_array = corrected_lick_err_array
                            lick_ew_array_mag = corrected_lick_ew_mag_array
                            lick_err_array_mag = corrected_lick_err_mag_array


                    else: #In the case of process selected event, no need to show the plots
                        lick_single_index = False
                        lick_ew_plot = False
                        lick_verbose = True
                        lick_with_uncertainties = True
                        lick_normalise_spec = True

                        lick_id_array, lick_ew_array, lick_err_array, lick_snr_ew_array, lick_ew_array_mag, lick_err_array_mag = ls.ew_measurement(lick_degraded_wavelength, lick_degraded_flux, lick_index_file, lick_single_index, lick_ew_plot, lick_verbose, lick_with_uncertainties, save_plot, prev_spec_nopath, lick_normalise_spec, result_plot_dir)

                        print (lick_id_array)
                        print (lick_ew_array)
                        print ('')
                        print ('Raw EW in Mag: ')
                        print (np.round(lick_ew_array_mag, decimals = 3))
                        print ('SNR: ')
                        print (np.round(lick_snr_ew_array), 'per pix')
                        print ('')

                                    # 4) Correcting the EWs
                        if correct_ew_sigma == True and radio_lick_sigma_single == True:
                            corrected_lick_ew_array, corrected_lick_err_array, corrected_lick_ew_mag_array, corrected_lick_err_mag_array = ls.corr_ew_lick(lick_ew_array, lick_err_array, lick_ew_array_mag, sigma_lick_coeff_file, sigma_single_lick)

                            print ('Corrected EWs for sigma (A):')
                            print (np.round(corrected_lick_ew_array, decimals = 3))
                            print ('Corrected uncertainties for sigma:')
                            print (np.round(corrected_lick_err_array, decimals = 3))
                            print ('Corrected EWs for sigma (mag):')
                            print (np.round(corrected_lick_ew_mag_array, decimals = 3))
                            print ('Corrected mag uncertainties for sigma: ')
                            print (np.round(corrected_lick_err_mag_array, decimals = 3))
                            print ('')

                            #uodating the values
                            lick_ew_array = corrected_lick_ew_array
                            lick_err_array = corrected_lick_err_array
                            lick_ew_array_mag = corrected_lick_ew_mag_array
                            lick_err_array_mag = corrected_lick_err_mag_array

                        if correct_ew_sigma == True and radio_lick_sigma_list == True:
                            print ('WARNING: cannot correct for sigma broadening one spectrum with a list of sigmas. Select the single value. Skipping the correction for now...')

                        if correct_ew_sigma == True and radio_lick_sigma_auto == True:

                            corrected_lick_ew_array, corrected_lick_err_array, corrected_lick_ew_mag_array, corrected_lick_err_mag_array = ls.corr_ew_lick(lick_ew_array, lick_err_array, lick_ew_array_mag, sigma_lick_coeff_file, sigma_to_correct_lick)

                            print ('Corrected EWs for sigma (A):')
                            print (np.round(corrected_lick_ew_array, decimals = 3))
                            print ('Corrected uncertainties for sigma:')
                            print (np.round(corrected_lick_err_array, decimals = 3))
                            print ('Corrected EWs for sigma (mag):')
                            print (np.round(corrected_lick_ew_mag_array, decimals = 3))
                            print ('Corrected mag uncertainties for sigma: ')
                            print (np.round(corrected_lick_err_mag_array, decimals = 3))

                            #uodating the values
                            lick_ew_array = corrected_lick_ew_array
                            lick_err_array = corrected_lick_err_array
                            lick_ew_array_mag = corrected_lick_ew_mag_array
                            lick_err_array_mag = corrected_lick_err_mag_array


                    #5) Constraining the stellar parameters and uncertainties
                    if stellar_parameters_lick == True:

                        #assigning meaningful names to the indices used for stellar populations and creating the combined ones
                        Hbeta = lick_ew_array[0]
                        Hbetae = lick_err_array[0]
                        Mg2 = lick_ew_array_mag[1]
                        Mg2e = lick_err_array_mag[1]
                        Mgb = lick_ew_array[2]
                        Mgbe = lick_err_array[2]
                        Fe5270 = lick_ew_array[3]
                        Fe5270e = lick_err_array[3]
                        Fe5335 = lick_ew_array[4]
                        Fe5335e = lick_err_array[4]
                        Fem = (Fe5270+Fe5335)/2
                        Feme = np.sqrt((0.5*Fe5270e)**2+(0.5*Fe5335e)**2)
                        MgFe = (np.sqrt(Mgb*(0.72*Fe5270+0.28*Fe5335)))
                        MgFe = np.nan_to_num(MgFe, nan=0)
                        MgFee = np.sqrt((((Fe5270*18/25+Fe5335*7/25)/(2*np.sqrt(Mgb*(Fe5270*18/25+Fe5335*7/25))))*Mgbe)**2+((Mgb*18/25/(2*np.sqrt(Mgb*(Fe5270*18/25+Fe5335*7/25))))*Fe5270e)**2+((Mgb*7/25/(2*np.sqrt(Mgb*(Fe5270*18/25+Fe5335*7/25))))*Fe5335e)**2)
                        MgFee = np.nan_to_num(MgFee, nan=0)

                        ssp_lick_indices_list = np.column_stack((Hbeta, MgFe, Fem, Mgb))
                        ssp_lick_indices = ssp_lick_indices_list.reshape(-1)
                        ssp_lick_indices_err_list = np.column_stack((Hbetae, MgFee, Feme, Mgbe))
                        ssp_lick_indices_err = ssp_lick_indices_err_list.reshape(-1)


                    if (event == 'Preview result' and stellar_parameters_lick == True):
                        age, met, alpha, err_age, err_met, err_alpha = span.lick_pop(ssp_lick_indices, ssp_lick_indices_err, ssp_model, interp_model)
                        #doing the plot
                        span.lick_grids(ssp_model, ssp_lick_indices_list, ssp_lick_indices_err_list, age, True, False, 'none', result_plot_dir)

                        print ('')
                        print ('Age (Gyr):', round(age,2), '+/-', round(err_age, 2))
                        print ('[M/H] (dex):', round(met, 2), '+/-', round(err_met,2))
                        print ('[Alpha/Fe]:', round(alpha, 2), '+/-', round(err_alpha,2))
                        print('')

                    if (event == 'Process selected' and stellar_parameters_lick == True): #no need to show the plots generated by the lick_pop function
                        age, met, alpha, err_age, err_met, err_alpha = span.lick_pop(ssp_lick_indices, ssp_lick_indices_err, ssp_model, interp_model)

                        print ('')
                        print ('Age (Gyr):', round(age,2), '+/-', round(err_age, 2))
                        print ('[M/H] (dex):', round(met, 2), '+/-', round(err_met,2))
                        print ('[Alpha/Fe]:', round(alpha, 2), '+/-', round(err_alpha,2))
                        print('')


                else:
                    print('Nothing to show')



            # 5) LINE(S) FITTING
            #cat
            if (line_fitting == True and cat_band_fit == True and (event == 'Process selected' or event == 'Preview result')):
                task_done = 1
                task_analysis = 1

                print ('*** CaT fitting with combination of gaussians ***')

                #Performing the fitting of the CaT lines
                #checking limits
                if ( min(wave_interval_fit) < wave_limits[0] or max(wave_interval_fit) > wave_limits[1]):
                    sg.popup ('The window band is out of the spectrum range')
                    continue

                cat_wave, cat_flux_norm, cat_fit, momentum = span.cat_fitting(wavelength,flux)

                #finding the relative minima that will be the central CaT line wavelengths:
                min_values_arg = argrelextrema(cat_fit, np.less)
                min_values_arg_extracted = min_values_arg[0]


                #if the fit fails a line:
                try:
                    min_wave1 = round(cat_wave[min_values_arg_extracted[0]],1)
                except IndexError:
                    min_wave1 = 0.
                try:
                    min_wave2 = round(cat_wave[min_values_arg_extracted[1]],1)
                except IndexError:
                    min_wave2 = 0.
                try:
                    min_wave3 = round(cat_wave[min_values_arg_extracted[2]],1)
                except IndexError:
                    min_wave3 = 0.
                try:
                    min_flux1 = cat_fit[min_values_arg_extracted[0]]
                except IndexError:
                    min_flux1 = 0.
                try:
                    min_flux2 = cat_fit[min_values_arg_extracted[1]]
                except IndexError:
                    min_flux2 = 0.
                try:
                    min_flux3 = cat_fit[min_values_arg_extracted[2]]
                except IndexError:
                    min_flux3 = 0.

                #Differences in observed and calculated peaks
                residual_wave1 = min_wave1-real_cat1
                residual_wave2 = min_wave2-real_cat2
                residual_wave3 = min_wave3-real_cat3

                #converting the wavelength residuals in velocities
                c = 299792.458
                delta_rv1 = (residual_wave1/real_cat1)*c
                delta_rv2 = (residual_wave2/real_cat2)*c
                delta_rv3 = (residual_wave3/real_cat3)*c

                #Assigning the sigma of the lines (in pixels)
                sigma_cat1 = momentum[3]
                sigma_cat2 = momentum[9]
                sigma_cat3 = momentum[15]

                #converting to velocities
                sigma_cat1_vel = (sigma_cat1/min_wave1)*c
                sigma_cat2_vel = (sigma_cat2/min_wave1)*c
                sigma_cat3_vel = (sigma_cat3/min_wave1)*c

                #residual spectrum
                residual_flux = cat_flux_norm - cat_fit

                #printing data from the fit
                print ('Central wavelength of the fitted CaT lines (nm)')
                print (min_wave1,min_wave2,min_wave3)
                print ('Real central wavelength of the CaT lines (nm)')
                print (real_cat1,real_cat2,real_cat3)
                print ('Residuals (nm):')
                print (residual_wave1,residual_wave2,residual_wave3)
                print ('Residuals in km/s')
                print (delta_rv1,delta_rv2,delta_rv3)
                print ('Mean delta RV:')
                print ((delta_rv1+delta_rv2+delta_rv3)/3)
                print ('Sigma (nm)')
                print (sigma_cat1, sigma_cat2, sigma_cat3)
                print ('Sigma (km/s)')
                print (sigma_cat1_vel,sigma_cat2_vel,sigma_cat3_vel)


                #plotting the fit result
                fig, (ax1, ax2) = plt.subplots(2, figsize = (8.5,8.5), gridspec_kw={'height_ratios': [3, 1]})

                fig.suptitle('CaT lines fitting')
                ax1.plot(cat_wave, cat_flux_norm, label = 'Spectrum')
                ax1.plot(cat_wave, cat_fit, label = 'Fit line spec')
                ax1.set_xlabel('Wavelength (nm)')
                ax1.set_ylabel('Norm flux')
                ax1.legend(fontsize = 10)

                #plot residuals
                ax2.plot(cat_wave, residual_flux, linewidth=0.5, label = 'Residuals')
                ax2.hlines(y=0, xmin=min(cat_wave), xmax=max(cat_wave), linestyles='--', lw=2, linewidth=2, color='r')
                ax2.set_xlabel('Wavelength (nm)')
                ax2.set_ylabel('Residuals')
                ax2.legend(fontsize = 10)
                plt.show()
                plt.close()

                #EW measurement of the fitted lines
                cat_single_index = True
                cat_plot = False
                cat_verbose = False
                cat_with_uncertainties = True
                cat_save_plot = False
                cat_normalise_spec = False

                #ca1
                id_array, ew_array_ca1, err_array, snr_ew_array,ew_array_mag, err_array_mag = ls.ew_measurement(cat_wave, cat_fit, index_ca1, cat_single_index, cat_plot, cat_verbose, cat_with_uncertainties, cat_save_plot, prev_spec, cat_normalise_spec, result_plot_dir)

                #ca2
                id_array, ew_array_ca2, err_array, snr_ew_array,ew_array_mag, err_array_mag = ls.ew_measurement(cat_wave, cat_fit, index_ca2, cat_single_index, cat_plot, cat_verbose, cat_with_uncertainties, cat_save_plot, prev_spec, cat_normalise_spec, result_plot_dir)

                #ca3
                id_array, ew_array_ca3, err_array, snr_ew_array,ew_array_mag, err_array_mag = ls.ew_measurement(cat_wave, cat_fit, index_ca3, cat_single_index, cat_plot, cat_verbose, cat_with_uncertainties, cat_save_plot, prev_spec, cat_normalise_spec, result_plot_dir)

                #some infos
                print ('Equivalent width from the fit (Ang):')
                print ('Ca1  Ca2  Ca3')
                print (round(ew_array_ca1,2), round(ew_array_ca2,2), round(ew_array_ca3,2))
                print ('')


            #line fitting user line
            if (line_fitting == True and cat_band_fit == False and (event == 'Process selected' or event == 'Preview result')):
                task_done = 1
                task_analysis = 1

                print ('*** Line fitting with combination of gaussian and a line for the slope ***')

                #check on the limits of the parameters
                wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

                #checking limits
                if ( min(wave_interval_fit) < wave_limits[0] or max(wave_interval_fit) > wave_limits[1]):
                    sg.popup ('The window band is out of the spectrum range')
                    continue

                #Performing the fitting of the line
                line_wave, line_flux_norm, line_fit, momentum = span.line_fitting (wavelength, flux, wave_interval_fit, guess_param)

                #finding the minimum that will be the central CaT line wavelengths:
                if emission_line == False:
                    min_value_wave_arg = np.argmin(line_fit)
                    min_wave = line_wave[min_value_wave_arg]

                #if I have emission I calculate the maximum!
                if emission_line == True:
                    min_value_wave_arg = np.argmax(line_fit)
                    min_wave = line_wave[min_value_wave_arg]

                #Assigning the sigma of the lines (in pixels)
                sigma_line = abs(momentum[3])

                #converting to velocities
                c = 299792.458
                sigma_line_vel = (sigma_line/min_wave)*c

                #residual spectrum
                residual_flux = line_flux_norm - line_fit

                #printing data from the fit
                print ('Central wavelength of the fitted line (nm)')
                print (min_wave)
                print ('Sigma (nm)')
                print (sigma_line)
                print ('Sigma (km/s)')
                print (sigma_line_vel)

                #plotting the fit result
                fig, (ax1, ax2) = plt.subplots(2, figsize = (8.5,8.5), gridspec_kw={'height_ratios': [3, 1]})

                fig.suptitle('line fitting')
                ax1.plot(line_wave, line_flux_norm, label = 'Spectrum')
                ax1.plot(line_wave, line_fit, label = 'Fit line spec')
                ax1.set_xlabel('Wavelength (nm)')
                ax1.set_ylabel('Norm flux')
                ax1.legend(fontsize = 10)

                #plot residuals
                ax2.plot(line_wave, residual_flux, linewidth=0.5, label = 'Residuals')
                ax2.hlines(y=0, xmin=min(line_wave), xmax=max(line_wave), linestyles='--', lw=2, linewidth=2, color='r')
                ax2.set_xlabel('Wavelength (nm)')
                ax2.set_ylabel('Residuals')
                ax2.legend(fontsize = 10)
                plt.show()
                plt.close()


            # 6) KINEMATICS WITH PPXF
            if (perform_kinematics == True and (event == 'Process selected' or event == 'Preview result')):
                task_done = 1
                task_analysis = 1

                print ('*** Kinematics with the ppxf algorithm ***')

                #wave limits of the spectrum
                wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

                #check on the limits of the input parameters
                if wave1_kin < wave2_kin:
                    wave_limits_kin = (wave1_kin,wave2_kin)
                elif wave1_kin > wave2_kin:
                    #I suppose the wavelength range is inverted:
                    wave1_kin_tmp = wave1_kin
                    wave1_kin = wave2_kin
                    wave2_kin = wave1_kin_tmp
                    wave_limits_kin = (wave1_kin, wave2_kin)

                #checking limits
                if ( wave1_kin < wave_limits[0] or wave2_kin > wave_limits[1]):
                    sg.popup ('The window band is out of the spectrum range')
                    continue

                try:
                    if constant_resolution_lambda == True: #if I gave the resolution in FWHM
                        #fitting with ppxf
                        kinematics, error_kinematics, bestfit_flux, bestfit_wavelength, kin_component, snr_kin, error_kinematics_mc = span.ppxf_kinematics(wavelength, flux, wave1_kin, wave2_kin, resolution_kin, constant_resolution_lambda, resolution_kin_r, redshift_guess_kin, sigma_guess_kin, stellar_library_kin, additive_degree_kin, kin_moments, ppxf_kin_noise, gas_kin, no_gas_kin, kin_best_noise, with_errors_kin, ppxf_kin_custom_lib, ppxf_kin_lib_folder, ppxf_kin_custom_temp_suffix, ppxf_kin_dust_gas, ppxf_kin_dust_stars, ppxf_kin_tie_balmer, ppxf_kin_two_stellar_components, ppxf_kin_age_model1, ppxf_kin_met_model1, ppxf_kin_age_model2, ppxf_kin_met_model2, ppxf_kin_vel_model1, ppxf_kin_sigma_model1, ppxf_kin_vel_model2, ppxf_kin_sigma_model2, ppxf_kin_mask_emission, ppxf_kin_mc_sim)


                    if constant_resolution_lambda == False: #if I gave the resolution in R
                        #fitting with ppxf
                        kinematics, error_kinematics, bestfit_flux, bestfit_wavelength, kin_component, snr_kin,error_kinematics_mc = span.ppxf_kinematics(wavelength, flux, wave1_kin, wave2_kin, resolution_kin, constant_resolution_lambda, resolution_kin_r, redshift_guess_kin, sigma_guess_kin, stellar_library_kin, additive_degree_kin, kin_moments, ppxf_kin_noise, gas_kin, no_gas_kin, kin_best_noise, with_errors_kin, ppxf_kin_custom_lib, ppxf_kin_lib_folder, ppxf_kin_custom_temp_suffix, ppxf_kin_dust_gas, ppxf_kin_dust_stars, ppxf_kin_tie_balmer, ppxf_kin_two_stellar_components, ppxf_kin_age_model1, ppxf_kin_met_model1, ppxf_kin_age_model2, ppxf_kin_met_model2, ppxf_kin_vel_model1, ppxf_kin_sigma_model1, ppxf_kin_vel_model2, ppxf_kin_sigma_model2, ppxf_kin_mask_emission, ppxf_kin_mc_sim)


                    #plotting using pPXF
                    plt.plot(bestfit_wavelength, bestfit_flux)

                    #inserting plotting info for stellar single component
                    if kin_component == 0 and ppxf_kin_two_stellar_components == False:
                        vel_string = str(int(kinematics[0]))
                        sigma_string = str(int(kinematics[1]))
                        h3_string = str(round(kinematics[2],3))
                        h4_string = str(round(kinematics[3],3))
                        plt.title('v = '+ vel_string + ' km/s.  Sigma = '+ sigma_string + ' km/s.  H3 = ' + h3_string + '.  H4 = ' + h4_string)
                        plt.show()
                        plt.close()

                        if np.any(kinematics) == 0: #if the return of the fit are all zeros, means that the fit has not been performed for the following reason:
                            sg.popup ('Template resolution greater than galaxy spectrum. Fit aborted')
                        #continue

                    #plotting info for stellar double component
                    elif kin_component == 0 and ppxf_kin_two_stellar_components == True:
                        vel_string1 = str(int(kinematics[0][0]))
                        sigma_string1 = str(int(kinematics[0][1]))
                        h3_string1 = str(round(kinematics[0][2],3))
                        h4_string1 = str(round(kinematics[0][3],3))
                        vel_string2 = str(int(kinematics[1][0]))
                        sigma_string2 = str(int(kinematics[1][1]))
                        h3_string2 = str(round(kinematics[1][2],3))
                        h4_string2 = str(round(kinematics[1][3],3))

                        plt.title('v1 = '+ vel_string1 + ' km/s.  Sigma1 = '+ sigma_string1 + ' km/s.  v2 = ' + vel_string2 + '. Sigma2 = '+ sigma_string2 + ' km/s')
                        plt.show()
                        plt.close()

                        if np.any(kinematics) == 0: #if the return of the fit are all zeros, means that the fit has not been performed for the following reason:
                            sg.popup ('Template resolution greater than galaxy spectrum. Fit aborted')
                        #continue

                    #plotting info for stellar and gas components
                    else:
                        vel_string = str(int(kinematics[0][0]))
                        sigma_string = str(int(kinematics[0][1]))
                        h3_string = str(round(kinematics[0][2],3))
                        h4_string = str(round(kinematics[0][3],3))
                        plt.title('v = '+ vel_string + ' km/s.  Sigma = '+ sigma_string + ' km/s.  H3 = ' + h3_string + '.  H4 = ' + h4_string)
                        plt.show()
                        plt.close()

                        if np.any(kinematics[0]) == 0: #if the return of the fit are all zeros, means that the fit has not been performed for the following reason:
                            sg.popup ('Template resolution greater than galaxy spectrum. Fit aborted')
                        #continue

                except:
                    print ('Something went wrong. The parameters inserted are not correct, the resolution of your spectra is lower than the templates used, if you are using the Xshooter or custom library or the custom templates do not exist. ')



            # 7) STELLAR POPULATIONS WITH PPXF
            if (stellar_pop == True and (event == 'Process selected' or event == 'Preview result')):
                task_done = 1
                task_analysis = 1

                print ('*** Stellar populations with the ppxf algorithm ***')

                #wave limits of the spectrum
                wave_limits = np.array([np.min(wavelength), np.max(wavelength)])

                #check on the limits of the input parameters
                if wave1_pop < wave2_pop:
                    wave_limits_pop = (wave1_pop,wave2_pop)
                elif wave1_pop > wave2_pop:
                    #I suppose the wavelength range is inverted:
                    wave1_pop_tmp = wave1_pop
                    wave1_pop = wave2_pop
                    wave2_pop = wave1_pop_tmp
                    wave_limits_pop = (wave1_pop, wave2_pop)

                #checking limits
                if ( wave1_pop < wave_limits[0] or wave2_pop > wave_limits[1]):
                    sg.popup ('The window band is out of the spectrum range')
                    continue

                if ppxf_pop_custom_lib == True and ppxf_pop_custom_npz == False:
                    matching_temp = glob.glob(os.path.join(ppxf_pop_lib_folder, ppxf_custom_temp_suffix))
                    if not matching_temp:
                        sg.popup ('Well, like I said, the templates you want to use do not exist. Stopping')
                        continue

                #doing it
                if with_errors == True:
                    print ('')
                    print ('********* Calculating the errors for age and metallicity. Please sit and wait...*****')
                    print ('')

                try:
                    kinematics, info_pop, info_pop_mass, mass_light, errors, galaxy, bestfit_flux, bestfit_wave, bestfit_flux_gas, residual_flux, chi_square, age_err_lower_abs, age_err_upper_abs, met_err_lower, met_err_upper, alpha_err_lower, alpha_err_upper, mass_age_err_lower_abs, mass_age_err_upper_abs, mass_met_err_lower, mass_met_err_upper, mass_alpha_err_lower, mass_alpha_err_upper, emission_corrected_flux, pop_age, light_weights_age_bin, mass_weights_age_bin, cumulative_mass, snr_pop, light_weights, mass_weights = span.ppxf_pop(wavelength, flux, wave1_pop, wave2_pop, res_pop, z_pop, sigma_guess_pop, fit_components, True, with_errors, False, 'none', regul_err, additive_degree, multiplicative_degree, ppxf_pop_tie_balmer, stellar_library, ppxf_pop_dust_stars, ppxf_pop_dust_gas, ppxf_pop_noise, age_range_array, met_range_array, ppxf_pop_custom_lib, ppxf_pop_lib_folder, ppxf_pop_custom_npz, ppxf_pop_npz_file, ppxf_pop_mask, ppxf_custom_temp_suffix, ppxf_best_param, ppxf_best_noise_estimate, ppxf_frac_chi, ppxf_pop_convolve, ppxf_pop_want_to_mask, ppxf_pop_mask_ranges, ppxf_pop_error_nsim, ppxf_pop_lg_age, result_plot_dir)


                    #If the stellar parameters also with Lick/IDS indices is activated:
                    if stellar_parameters_lick_ppxf == True:

                        #Extracting the kinematics from the pPXF fit. THe walues to extract depends whether I have gas or not
                        try:
                            num_comp_kinematics = len(kinematics)
                            kin_stars = np.array(kinematics[0])
                            dop_vel_pop_ppxf = kin_stars[0]
                            sigma_pop_ppxf = kin_stars[1]


                        except (ValueError, IndexError):
                            num_comp_kinematics = 0
                            kin_stars = kinematics
                            dop_vel_pop_ppxf = kinematics[0]
                            sigma_pop_ppxf = kinematics[1]

                        #Extracting the wave (in nm) and emission corrected flux from the ppxf fit
                        lick_wavelength_ppxf = bestfit_wave/10
                        lick_flux_ppxf = emission_corrected_flux
                        lick_step_ppxf = lick_wavelength_ppxf[1] - lick_wavelength_ppxf[0]

                        #rebinning linear
                        lick_wavelength_ppxf, lick_flux_ppxf, npoint_resampled = spman.resample(lick_wavelength_ppxf, lick_flux_ppxf, lick_step_ppxf)
                        lick_constant_fwhm_ppxf = True

                        #Doppler correction from the velociy calculated by pPXF
                        lick_wavelength_ppxf, lick_flux_ppxf = spman.dopcor(lick_wavelength_ppxf, lick_flux_ppxf, dop_vel_pop_ppxf, True) #doppler correction. The cosmological z correction has been already performed by the span.ppxf_pop function, prior to really run pPXF. Here I correct only for the real velocity component measured by the fit.

                        # 3) degrading the resolution, only if smaller than the lick system
                        if res_pop < 8.4:
                            lick_degraded_wavelength_ppxf, lick_degraded_flux_ppxf = spman.degrade_to_lick(lick_wavelength_ppxf, lick_flux_ppxf, res_pop, lick_constant_fwhm_ppxf)
                        else:
                            print('WARNING: The resolution of the spectrum is smaller than the one needed for the Lick/IDS system. I will still calculate the Lick/IDS indices but the results might be inaccurate.')
                            lick_degraded_wavelength_ppxf = lick_wavelength_ppxf
                            lick_degraded_flux_ppxf = lick_flux_ppxf

                        # 4) Measuring the EW and doing plot
                        lick_single_index_ppxf = False
                        lick_ew_plot_ppxf = False
                        lick_verbose_ppxf = False
                        lick_with_uncertainties_ppxf = True
                        lick_save_plot_ppxf = False
                        lick_normalise_spec_ppxf = True

                        lick_id_array_ppxf, lick_ew_array_ppxf, lick_err_array_ppxf, lick_snr_ew_array_ppxf, lick_ew_array_mag_ppxf, lick_err_array_mag_ppxf = ls.ew_measurement(lick_degraded_wavelength_ppxf, lick_degraded_flux_ppxf, lick_index_file, lick_single_index_ppxf, lick_ew_plot_ppxf, lick_verbose_ppxf, lick_with_uncertainties_ppxf, lick_save_plot_ppxf, prev_spec, lick_normalise_spec_ppxf, result_plot_dir)


                        # 5) Correcting the EWs for sigma by extracting the sigma determined by pPXF. The location changes whether fitting with of tiwthout gas
                        sigma_to_correct_lick_ppxf = sigma_pop_ppxf

                        #now correcting for real
                        corrected_lick_ew_array_ppxf, corrected_lick_err_array_ppxf, corrected_lick_ew_mag_array_ppxf, corrected_lick_err_mag_array_ppxf = ls.corr_ew_lick(lick_ew_array_ppxf, lick_err_array_ppxf, lick_ew_array_mag_ppxf, sigma_lick_coeff_file, sigma_to_correct_lick_ppxf)

                        #uodating the values
                        lick_ew_array_ppxf = corrected_lick_ew_array_ppxf
                        lick_err_array_ppxf = corrected_lick_err_array_ppxf
                        lick_ew_array_mag_ppxf = corrected_lick_ew_mag_array_ppxf
                        lick_err_array_mag_ppxf = corrected_lick_err_mag_array_ppxf

                        #assigning meaningful names to the indices used for stellar populations and creating the combined ones
                        Hbeta_ppxf_single = lick_ew_array_ppxf[0]
                        Hbetae_ppxf_single = lick_err_array_ppxf[0]
                        Mg2_ppxf_single = lick_ew_array_mag_ppxf[1]
                        Mg2e_ppxf_single = lick_err_array_mag_ppxf[1]
                        Mgb_ppxf_single = lick_ew_array_ppxf[2]
                        Mgbe_ppxf_single = lick_err_array_ppxf[2]
                        Fe5270_ppxf_single = lick_ew_array_ppxf[3]
                        Fe5270e_ppxf_single = lick_err_array_ppxf[3]
                        Fe5335_ppxf_single = lick_ew_array_ppxf[4]
                        Fe5335e_ppxf_single = lick_err_array_ppxf[4]
                        Fem_ppxf_single = (Fe5270_ppxf_single+Fe5335_ppxf_single)/2
                        Feme_ppxf_single = np.sqrt((0.5*Fe5270e_ppxf_single)**2+(0.5*Fe5335e_ppxf_single)**2)
                        MgFe_ppxf_single = (np.sqrt(Mgb_ppxf_single*(0.72*Fe5270_ppxf_single+0.28*Fe5335_ppxf_single)))
                        MgFe_ppxf_single = np.nan_to_num(MgFe_ppxf_single, nan=0)
                        MgFee_ppxf_single = np.sqrt((((Fe5270_ppxf_single*18/25+Fe5335_ppxf_single*7/25)/(2*np.sqrt(Mgb_ppxf_single*(Fe5270_ppxf_single*18/25+Fe5335_ppxf_single*7/25))))*Mgbe_ppxf_single)**2+((Mgb_ppxf_single*18/25/(2*np.sqrt(Mgb_ppxf_single*(Fe5270_ppxf_single*18/25+Fe5335_ppxf_single*7/25))))*Fe5270e_ppxf_single)**2+((Mgb_ppxf_single*7/25/(2*np.sqrt(Mgb_ppxf_single*(Fe5270_ppxf_single*18/25+Fe5335_ppxf_single*7/25))))*Fe5335e_ppxf_single)**2)
                        MgFee_ppxf_single = np.nan_to_num(MgFee_ppxf_single, nan=0)

                        ssp_lick_indices_list_ppxf = np.column_stack((Hbeta_ppxf_single, MgFe_ppxf_single, Fem_ppxf_single, Mgb_ppxf_single))
                        ssp_lick_indices_ppxf = ssp_lick_indices_list_ppxf.reshape(-1)
                        ssp_lick_indices_err_list_ppxf = np.column_stack((Hbetae_ppxf_single, MgFee_ppxf_single, Feme_ppxf_single, Mgbe_ppxf_single))
                        ssp_lick_indices_err_ppxf = ssp_lick_indices_err_list_ppxf.reshape(-1)

                        #Determining the stellar parameters
                        age, met, alpha, err_age, err_met, err_alpha = span.lick_pop(ssp_lick_indices_ppxf, ssp_lick_indices_err_ppxf, ssp_model_ppxf, interp_model_ppxf)

                        print ('')
                        print ('Age (Gyr):', round(age,2), '+/-', round(err_age, 2))
                        print ('[M/H] (dex):', round(met, 2), '+/-', round(err_met,2))
                        print ('[Alpha/Fe]:', round(alpha, 2), '+/-', round(err_alpha,2))
                        print('')

                except Exception as e:
                    sg.Popup ('Something went wrong with the fit. Maybe too small age-metallicity range, bad templates or you masked out all the spectrum? Skipping...')
                    kinematics=info_pop=info_pop_mass=mass_light=errors=bestfit_flux=bestfit_wave=bestfit_flux_gas=chi_square=err_age=err_met=err_mass_age_abs=err_mass_met=emission_corrected_flux = pop_age=mass_weights_age_bin = cumulative_mass= snr_pop =0


                #saving the file with the fit
                if event == 'Process selected':
                    try:
                        #saving the spectra
                        file_fit_pop = result_spec+'ppxf_fit_pop_residuals_' + prev_spec_nopath + '.fits'
                        file_fit_stellar_template = result_spec+'ppxf_fit_pop_stellar_template_' + prev_spec_nopath + '.fits'
                        file_spec_emission_corrected = result_spec+'ppxf_fit_pop_emission_corrected_' + prev_spec_nopath + '.fits'

                        #saving the SFH and weights
                        file_sfh = result_ppxf_pop_data_dir+'/'+spectra_list_name+'_ppxf_fit_pop_SFH_' + prev_spec_nopath + '.dat'
                        file_all_light_weights = result_ppxf_pop_data_dir+'/'+spectra_list_name+'_ppxf_fit_pop_light_weights_' + prev_spec_nopath + '.dat'
                        file_all_mass_weights = result_ppxf_pop_data_dir+'/'+spectra_list_name+'_ppxf_fit_pop_mass_weights_' + prev_spec_nopath + '.dat'

                        bestfit_wave = bestfit_wave/10. #converting to nm

                        #in case I don't have gas
                        try:
                            #saving the SFH with lg ages or with linear ages
                            if ppxf_pop_lg_age == True:
                                np.savetxt(file_sfh, np.column_stack([pop_age, light_weights_age_bin, mass_weights_age_bin]), header="lg_age(dex)\tlum_fraction\tmass_fraction", delimiter='\t')
                            else:
                                np.savetxt(file_sfh, np.column_stack([pop_age, light_weights_age_bin, mass_weights_age_bin]), header="age(Gyr)\tlum_fraction\tmass_fraction", delimiter='\t')

                            print ('File containing the luminosity and mass SFH saved: ', file_sfh)

                            #saving the light weights
                            np.savetxt(file_all_light_weights, light_weights.reshape(-1, light_weights.shape[-1]), fmt="%.8e", delimiter=' ', header="Light weights")
                            print ('File containing the light weights saved: ', file_all_light_weights)

                            #saving the mass weights
                            np.savetxt(file_all_mass_weights, mass_weights.reshape(-1, mass_weights.shape[-1]), fmt="%.8e", delimiter=' ', header="Mass weights")
                            print ('File containing the mass weights saved: ', file_all_mass_weights)

                            if bestfit_flux_gas == 0:

                                #saving the residual file
                                uti.save_fits_2d(bestfit_wave, residual_flux, file_fit_pop) #using the save_fits_2d function because the wavelength sampling is not linear

                                #saving the template without gas:
                                uti.save_fits_2d(bestfit_wave, bestfit_flux, file_fit_stellar_template)

                                print ('File containing the residuals of the fit saved: ', file_fit_pop)
                                print ('File containing the stellar fitted template: ', file_fit_stellar_template)
                                print('')

                        except ValueError: #considering also the gas template if I receive this error

                            #saving the residual file
                            uti.save_fits_2d(bestfit_wave, residual_flux, file_fit_pop)

                            #saving the best template without gas:
                            stellar_fit_flux = bestfit_flux-bestfit_flux_gas
                            uti.save_fits_2d(bestfit_wave, stellar_fit_flux, file_fit_stellar_template)

                            #saving the emission corrected spectra in linear step
                            uti.save_fits_2d(bestfit_wave, emission_corrected_flux, file_spec_emission_corrected)

                            print ('File containing the residuals of the fit saved: ', file_fit_pop)
                            print ('File containing the stellar fitted template: ', file_fit_stellar_template)
                            print ('File containing the emission corrected spectra (empty if no gas selected): ', file_spec_emission_corrected)
                            print('')
                    except TypeError:
                        print ('Something went wrong')


    #******************************************************************
    #************************************END OF TASKS *****************
    #******************************************************************
            if (task_analysis == 0 and event == 'Preview result'):
                sg.popup ('No spectral analysis task selected. Nothing to preview!')
                continue


            #Setting up the text files to be saved

            #Test to save only the final results, without the intermediate files
            if (save_intermediate_files == True and event == 'Process selected' and task_done == 0):
                sg.popup ('Nothing to process!')
            if (save_intermediate_files == False and event == 'Process selected' and task_spec == 1):
                file_final = result_spec+'proc_' + prev_spec_nopath + '.fits'
                uti.save_fits(wavelength, flux, file_final)

                #considering also the cont sub task that saves the continuum!
                if (continuum_sub == True):
                    file_cont = result_spec+'cont_' + prev_spec_nopath + '.fits'
                    uti.save_fits(wavelength, continuum_flux, file_cont)
                    print ('File saved: ', file_cont)

                print ('File saved: ', file_final)
                print('')
            elif (save_intermediate_files == False and event == 'Process selected' and task_done == 0):
                sg.popup ('Nothing to process!')

            if (event == 'Preview result' and task_done == 0):
                sg.popup ('Nothing to preview. Please, select a Spectral analysis task!')


    ################################################################################################
    ##################################### END TASKS ################################################
    ################################################################################################


    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################
    ################################################################################################



    #################################################################################################
    # ******************************* MEGA EVENT PROCESS ALL **************************************


        if (event == 'Process all' and values['one_spec'] == False):

            #Setting up the ASCII files with the results of the spectral analysis, only if I selected the task! This is useful because if an error occurs during the computation, you still will have the results written until the error!

            #1) Blackbody
            if (bb_fit == True):
                bb_file = result_bb_dir+'/'+spectra_list_name+'_bb_data_' +timestamp + '.dat'
                bb_id = ['#Spectrum', 'T(K)']
                bb_values = np.zeros(spectra_number)
                bb_data_array = np.column_stack((spec_names_nopath, bb_values))

                #generating the dataframe and adding the data
                df_bb = pd.DataFrame(bb_data_array, columns = bb_id)

                #writing to a file
                df_bb.to_csv(bb_file, index= True, sep=' ')


            #2) Cross correlation
            if (cross_corr == True):
                rv_file = result_xcorr_dir+'/'+spectra_list_name+'_rv_data_' +timestamp + '.dat'
                rv_id = ['#Spectrum', 'RV(km/s)']
                rv_values = np.zeros(spectra_number)
                rv_data_array = np.column_stack((spec_names_nopath, rv_values))

                #generating the dataframe and adding the data
                df_rv = pd.DataFrame(rv_data_array, columns = rv_id)

                #writing to a file
                df_rv.to_csv(rv_file, index= True, sep=' ')


            #3) Velocity dispersion measurement
            if (sigma_measurement == True):
                sigma_file = result_vel_disp_dir+'/'+spectra_list_name+'_sigma_data_'+timestamp +'.dat'
                sigma_id = ['#Spectrum', 'Sigma(km/s)', 'err']
                sigma_values = np.zeros(spectra_number)
                err_values = np.zeros(spectra_number)
                sigma_data_array = np.column_stack((spec_names_nopath, sigma_values, err_values))

                #generating the dataframe and adding the data
                df_sigma = pd.DataFrame(sigma_data_array, columns = sigma_id)

                #writing to a file
                df_sigma.to_csv(sigma_file, index= True, sep=' ')


            #4) EW measurement
            if (ew_measurement == True and single_index == True):
                ew_file = result_ew_data_dir+'/'+spectra_list_name+'_ew_data_' +timestamp + '.dat'
                ew_id = ['#Spectrum', 'ew(A)', 'err']
                ew_values = np.zeros(spectra_number)
                err_ew_values = np.zeros(spectra_number)
                ew_data_array = np.column_stack((spec_names_nopath, ew_values, err_ew_values))

                #EW mag file
                ew_file_mag = result_ew_data_dir+'/'+spectra_list_name+'_ew_data_mag_' +timestamp + '.dat'
                ew_id_mag = ['#Spectrum', 'ew(Mag)', 'err']
                ew_values_mag = np.zeros(spectra_number)
                err_ew_values_mag = np.zeros(spectra_number)
                ew_data_array_mag = np.column_stack((spec_names_nopath, ew_values, err_ew_values))

                #SNR data
                snr_ew_file = result_ew_data_dir+'/'+spectra_list_name+'_snr_ew_data_' +timestamp + '.dat'
                snr_ew_id = ['#Spectrum', 'SNR']
                snr_ew_values = np.zeros(spectra_number)
                snr_ew_data_array = np.column_stack((spec_names_nopath, snr_ew_values))

                #generating the dataframe and adding the data
                df_ew = pd.DataFrame(ew_data_array, columns = ew_id)
                df_snr_ew = pd.DataFrame(snr_ew_data_array, columns = snr_ew_id)
                df_ew_mag = pd.DataFrame(ew_data_array_mag, columns = ew_id_mag)

                #writing to a file EW
                df_ew.to_csv(ew_file, index= True, sep=' ')
                df_snr_ew.to_csv(snr_ew_file, index= True, sep=' ')

                #writing to a file EW Mag
                df_ew_mag.to_csv(ew_file_mag, index= True, sep=' ')

            if (ew_measurement == True and have_index_file == True):
                cond33 = (os.path.isfile(index_file))
                if cond33 == False:
                    sg.popup('The index file does not exist. Skipping...')
                    continue

                #exploring the index file for errors
                try:
                    idx_names, indices = ls.read_idx(index_file)
                except ValueError:
                    sg.popup('At least one index in the file is not valid')
                    continue

                if len(indices[:,0]) < 6:
                    sg.popup ('The length of at least one index is not correct')
                    continue

                bad_idx = []
                num_indices_test = len(idx_names)
                true_cond = 0
                idx_error = 0
                for t in range(num_indices_test):
                    if (indices[0,t] > indices[1,t] or indices[2,t] > indices[3,t] or indices[4,t] > indices[5,t]):
                        bad_idx.append(idx_names[t])
                        true_cond = 1
                if true_cond == 1:
                    sg.popup('It seems we have a problem. Did you invert the wavelengths of these indices?', bad_idx)
                    continue

                ew_file = result_ew_data_dir+'/'+spectra_list_name+'_ew_data_' +timestamp + '.dat'
                ew_file_mag = result_ew_data_dir+'/'+spectra_list_name+'_ew_data_mag' +timestamp + '.dat'
                snr_ew_file = result_ew_data_dir+'/'+spectra_list_name+'_snr_ew_data_' +timestamp + '.dat'
                id_array, index = ls.read_idx(index_file)
                num_indices = len(id_array)

                shape = (spectra_number, num_indices)
                ew_all = np.zeros(shape)
                ew_all_mag = np.zeros(shape)
                snr_ew_all = np.zeros(shape)
                err_all = np.zeros(shape)


                spectra_id = ['#Spectrum']
                err_col_type = np.chararray(num_indices)
                err_col_type = 'e'
                err_col_names = np.char.add(id_array, err_col_type)

                #merging the arrays
                col_names = np.concatenate((id_array, err_col_names))
                ew_id = np.concatenate((spectra_id, col_names))
                ew_data = np.column_stack((spec_names_nopath, ew_all, err_all))
                ew_id_mag = np.concatenate((spectra_id, col_names))
                ew_data_mag = np.column_stack((spec_names_nopath, ew_all_mag, err_all))

                df_ew = pd.DataFrame(ew_data, columns = ew_id)
                df_ew.to_csv(ew_file, index= True, sep=' ')

                df_ew_mag = pd.DataFrame(ew_data_mag, columns = ew_id_mag)
                df_ew_mag.to_csv(ew_file_mag, index= True, sep=' ')

                #SNR
                snr_col_names = id_array
                snr_ew_id = np.concatenate((spectra_id, snr_col_names))
                snr_ew_data = np.column_stack((spec_names_nopath, snr_ew_all))
                df_snr_ew = pd.DataFrame(snr_ew_data, columns = snr_ew_id)
                df_snr_ew.to_csv(snr_ew_file, index= True, sep=' ')


            if (ew_measurement == True and lick_ew == True):
                cond33 = (os.path.isfile(lick_index_file))
                if cond33 == False:
                    sg.popup('The index file does not exist. Skipping...')
                    continue

                ew_lick_file = result_ew_data_dir+'/'+spectra_list_name+'_ew_lick_data_' +timestamp + '.dat'
                ew_lick_file_mag = result_ew_data_dir+'/'+spectra_list_name+'_ew_lick_data_mag' +timestamp + '.dat'
                snr_lick_ew_file = result_ew_data_dir+'/'+spectra_list_name+'_snr_ew_lick_data_' +timestamp + '.dat'
                id_lick_array, lick_index = ls.read_idx(lick_index_file)
                num_lick_indices = len(id_lick_array)

                shape = (spectra_number, num_lick_indices)
                ew_lick_all = np.zeros(shape)
                ew_lick_all_mag = np.zeros(shape)
                snr_lick_ew_all = np.zeros(shape)
                err_lick_all = np.zeros(shape)


                spectra_lick_id = ['#Spectrum']
                err_lick_col_type = np.chararray(num_lick_indices)
                err_lick_col_type = 'e'
                err_lick_col_names = np.char.add(id_lick_array, err_lick_col_type)

                #merging the arrays
                col_lick_names = np.concatenate((id_lick_array, err_lick_col_names))
                ew_lick_id = np.concatenate((spectra_lick_id, col_lick_names))
                ew_lick_data = np.column_stack((spec_names_nopath, ew_lick_all, err_lick_all))
                ew_lick_id_mag = np.concatenate((spectra_lick_id, col_lick_names))
                ew_lick_data_mag = np.column_stack((spec_names_nopath, ew_lick_all_mag, err_lick_all))

                df_ew_lick = pd.DataFrame(ew_lick_data, columns = ew_lick_id)
                df_ew_lick.to_csv(ew_lick_file, index= True, sep=' ')

                df_ew_lick_mag = pd.DataFrame(ew_lick_data_mag, columns = ew_lick_id_mag)
                df_ew_lick_mag.to_csv(ew_lick_file_mag, index= True, sep=' ')

                #SNR
                snr_lick_col_names = id_lick_array
                snr_lick_ew_id = np.concatenate((spectra_lick_id, snr_lick_col_names))
                snr_lick_ew_data = np.column_stack((spec_names_nopath, snr_lick_ew_all))
                df_snr_lick_ew = pd.DataFrame(snr_lick_ew_data, columns = snr_lick_ew_id)
                df_snr_lick_ew.to_csv(snr_lick_ew_file, index= True, sep=' ')


            if (ew_measurement == True and lick_ew == True and stellar_parameters_lick == True):

                ssp_param_file = result_ew_data_dir+'/'+spectra_list_name+'_ssp_param_lick_' +timestamp + '.dat'
                ssp_param_id = ['#Spectrum', 'age(Gyr)', 'err_age', 'met', 'err_met', 'alpha','err_alpha']

                age_ssp = np.zeros(spectra_number)
                age_err_ssp = np.zeros(spectra_number)
                met_ssp = np.zeros(spectra_number)
                met_err_ssp = np.zeros(spectra_number)
                alpha_ssp = np.zeros(spectra_number)
                alpha_err_ssp = np.zeros(spectra_number)

                ssp_param_array = np.column_stack((spec_names_nopath, age_ssp,age_err_ssp,met_ssp,met_err_ssp,alpha_ssp,alpha_err_ssp))

                #generating the dataframe and adding the data
                df_ssp_param = pd.DataFrame(ssp_param_array, columns = ssp_param_id)

                #writing to a file
                df_ssp_param.to_csv(ssp_param_file, index= True, sep=' ')



            #5) Line(s) fitting
            if (line_fitting == True and cat_band_fit == True):
                fit_file = result_line_fitting_dir+'/'+spectra_list_name+'_fit_data_' +timestamp + '.dat'
                fit_id = ['#Spectrum', 'ca1_wave', 'ca2_wave', 'ca3_wave', 'dw_ca1', 'dw_ca2','dw_ca3', 'ew_ca1','ew_ca2','ew_ca3']

                ca1_wave = np.zeros(spectra_number)
                ca2_wave = np.zeros(spectra_number)
                ca3_wave = np.zeros(spectra_number)
                dw_ca1 = np.zeros(spectra_number)
                dw_ca2 = np.zeros(spectra_number)
                dw_ca3 = np.zeros(spectra_number)
                ew_ca1 = np.zeros(spectra_number)
                ew_ca2 = np.zeros(spectra_number)
                ew_ca3 = np.zeros(spectra_number)

                fit_data_array = np.column_stack((spec_names_nopath, ca1_wave,ca2_wave,ca3_wave,dw_ca1,dw_ca2,dw_ca3,ew_ca1,ew_ca2,ew_ca3))

                #generating the dataframe and adding the data
                df_fit = pd.DataFrame(fit_data_array, columns = fit_id)

                #writing to a file
                df_fit.to_csv(fit_file, index= True, sep=' ')

            #5-bis) Line fitting 2
            if (line_fitting == True and cat_band_fit == False):
                fit_file = result_line_fitting_dir+'/'+spectra_list_name+'_fit_data_' +timestamp + '.dat'
                fit_id = ['#Spectrum', 'line_wave']
                fit_values = np.zeros(spectra_number)
                fit_data_array = np.column_stack((spec_names_nopath, fit_values))

                #generating the dataframe and adding the data
                df_fit = pd.DataFrame(fit_data_array, columns = fit_id)

                #writing to a file
                df_fit.to_csv(fit_file, index= True, sep=' ')


            #6) kinematics with ppxf
            if (perform_kinematics == True):
                kin_file = result_ppxf_kin_data_dir+'/'+spectra_list_name+'_kin_data_stars_' +timestamp + '.dat'
                kin_id = ['#Spectrum', 'RV(km/s)', 'Sigma(km/s)', 'H3', 'H4', 'H5', 'H6', 'errRV','errSigma', 'errH3','errH4', 'errH5', 'errH6', 'S/N']

                rv_kin = np.zeros(spectra_number)
                sigma_kin = np.zeros(spectra_number)
                h3_kin = np.zeros(spectra_number)
                h4_kin = np.zeros(spectra_number)
                h5_kin = np.zeros(spectra_number)
                h6_kin = np.zeros(spectra_number)
                err_rv_kin = np.zeros(spectra_number)
                err_sigma_kin = np.zeros(spectra_number)
                err_h3_kin = np.zeros(spectra_number)
                err_h4_kin = np.zeros(spectra_number)
                err_h5_kin = np.zeros(spectra_number)
                err_h6_kin = np.zeros(spectra_number)
                snr_kin = np.zeros(spectra_number)

                kin_data_array = np.column_stack((spec_names_nopath, rv_kin,sigma_kin,h3_kin,h4_kin, h5_kin, h6_kin,err_rv_kin,err_sigma_kin,err_h3_kin,err_h4_kin, err_h5_kin, err_h6_kin, snr_kin))


                #generating the dataframe and adding the data
                df_kin = pd.DataFrame(kin_data_array, columns = kin_id)

                #writing to a file
                df_kin.to_csv(kin_file, index= True, sep=' ')


                if with_errors_kin == True:

                    kin_file_mc = result_ppxf_kin_data_dir+'/'+spectra_list_name+'_kin_data_stars_mc_errors_' +timestamp + '.dat'
                    kin_id_mc = ['#Spectrum', 'RV(km/s)', 'Sigma(km/s)', 'H3', 'H4', 'H5', 'H6', 'errRV','errSigma', 'errH3','errH4', 'errH5', 'errH6', 'S/N']

                    err_rv_kin_mc = np.zeros(spectra_number)
                    err_sigma_kin_mc = np.zeros(spectra_number)
                    err_h3_kin_mc = np.zeros(spectra_number)
                    err_h4_kin_mc = np.zeros(spectra_number)
                    err_h5_kin_mc = np.zeros(spectra_number)
                    err_h6_kin_mc = np.zeros(spectra_number)
                    snr_kin = np.zeros(spectra_number)

                    kin_data_array_mc = np.column_stack((spec_names_nopath, rv_kin,sigma_kin,h3_kin,h4_kin, h5_kin, h6_kin,err_rv_kin_mc,err_sigma_kin_mc,err_h3_kin_mc,err_h4_kin_mc, err_h5_kin_mc, err_h6_kin_mc, snr_kin))


                    #generating the dataframe and adding the data
                    df_kin_mc = pd.DataFrame(kin_data_array_mc, columns = kin_id_mc)

                    #writing to a file
                    df_kin.to_csv(kin_file_mc, index= True, sep=' ')


                if gas_kin == True:
                    #generating the gas kinematics file
                    kin_file_gas = result_ppxf_kin_data_dir+'/'+spectra_list_name+'_kin_data_gas_' +timestamp + '.dat'
                    kin_id_gas = ['#Spectrum', 'RV(km/s)_1', 'Sigma(km/s)_1', 'H3_1', 'H4_1', 'H5_1', 'H6_1', 'errRV_1','errSigma_1','errH3_1', 'errH4_1', 'errH5_1', 'errH6_1', 'RV(km/s)_2', 'Sigma(km/s)_2', 'H3_2', 'H4_2', 'H5_2', 'H6_2', 'errRV_2','errSigma_2','errH3_2', 'errH4_2', 'errH5_2', 'errH6_2', 'RV(km/s)_3', 'Sigma(km/s)_3', 'H3_3', 'H4_3', 'H5_3', 'H6_3', 'errRV_3','errSigma_3','errH3_3', 'errH4_3', 'errH5_3', 'errH6_3']

                    rv_kin_balmer = np.zeros(spectra_number)
                    sigma_kin_balmer = np.zeros(spectra_number)
                    h3_kin_balmer = np.zeros(spectra_number)
                    h4_kin_balmer = np.zeros(spectra_number)
                    h5_kin_balmer = np.zeros(spectra_number)
                    h6_kin_balmer = np.zeros(spectra_number)
                    err_rv_kin_balmer = np.zeros(spectra_number)
                    err_sigma_kin_balmer = np.zeros(spectra_number)
                    err_h3_kin_balmer = np.zeros(spectra_number)
                    err_h4_kin_balmer = np.zeros(spectra_number)
                    err_h5_kin_balmer = np.zeros(spectra_number)
                    err_h6_kin_balmer = np.zeros(spectra_number)

                    rv_kin_forbidden = np.zeros(spectra_number)
                    sigma_kin_forbidden = np.zeros(spectra_number)
                    h3_kin_forbidden = np.zeros(spectra_number)
                    h4_kin_forbidden = np.zeros(spectra_number)
                    h5_kin_forbidden = np.zeros(spectra_number)
                    h6_kin_forbidden = np.zeros(spectra_number)
                    err_rv_kin_forbidden = np.zeros(spectra_number)
                    err_sigma_kin_forbidden = np.zeros(spectra_number)
                    err_h3_kin_forbidden = np.zeros(spectra_number)
                    err_h4_kin_forbidden = np.zeros(spectra_number)
                    err_h5_kin_forbidden = np.zeros(spectra_number)
                    err_h6_kin_forbidden = np.zeros(spectra_number)


                    rv_kin_other = np.zeros(spectra_number)
                    sigma_kin_other = np.zeros(spectra_number)
                    h3_kin_other = np.zeros(spectra_number)
                    h4_kin_other = np.zeros(spectra_number)
                    h5_kin_other = np.zeros(spectra_number)
                    h6_kin_other = np.zeros(spectra_number)
                    err_rv_kin_other = np.zeros(spectra_number)
                    err_sigma_kin_other = np.zeros(spectra_number)
                    err_h3_kin_other = np.zeros(spectra_number)
                    err_h4_kin_other = np.zeros(spectra_number)
                    err_h5_kin_other = np.zeros(spectra_number)
                    err_h6_kin_other = np.zeros(spectra_number)


                    kin_gas_data_array = np.column_stack((spec_names_nopath, rv_kin_balmer,sigma_kin_balmer,h3_kin_balmer, h4_kin_balmer, h5_kin_balmer, h6_kin_balmer, err_rv_kin_balmer,err_sigma_kin_balmer, err_h3_kin_balmer, err_h4_kin_balmer, err_h5_kin_balmer, err_h6_kin_balmer, rv_kin_forbidden,sigma_kin_forbidden, h3_kin_forbidden, h4_kin_forbidden, h5_kin_forbidden, h6_kin_forbidden, err_rv_kin_forbidden,err_sigma_kin_forbidden, err_h3_kin_forbidden, err_h4_kin_forbidden, err_h5_kin_forbidden, err_h6_kin_forbidden, rv_kin_other,sigma_kin_other, h3_kin_other, h4_kin_other, h5_kin_other, h6_kin_other, err_rv_kin_other,err_sigma_kin_other, err_h3_kin_other, err_h4_kin_other, err_h5_kin_other, err_h6_kin_other))


                    #generating the dataframe and adding the data
                    df_kin_gas = pd.DataFrame(kin_gas_data_array, columns = kin_id_gas)

                    #writing to a file
                    df_kin_gas.to_csv(kin_file_gas, index= True, sep=' ')






            #7) Stellar populations with ppxf
            if (stellar_pop == True):
                pop_file = result_ppxf_pop_data_dir+'/'+spectra_list_name+'_pop_data_' +timestamp + '.dat'

                if ppxf_pop_lg_age == True:
                    pop_id = ['#Spectrum', 'RV(km/s)', 'Sigma(km/s)', 'H3', 'H4', 'lum_lg_age(dex)','lum_met(dex)', 'lum_alpha(dex)', 'err_lum_lg_age_lower(dex)', 'err_lum_lg_age_upper(dex)', 'err_lum_met_lower(dex)', 'err_lum_met_upper(dex)', 'err_lum_alpha_lower(dex)', 'err_lum_alpha_upper(dex)', 'M/L', 'mass_lg_age(dex)', 'mass_met(dex)', 'mass_alpha(dex)', 'err_mass_lg_age_lower(dex)', 'err_mass_age_upper(dex)', 'err_mass_met_lower(dex)', 'err_mass_met_upper(dex)', 'err_mass_alpha_lower(dex)', 'err_mass_alpha_upper(dex)', 'Chi2', 'S/N']
                else:
                    pop_id = ['#Spectrum', 'RV(km/s)', 'Sigma(km/s)', 'H3', 'H4', 'lum_age(Gyr)','lum_met(dex)', 'lum_alpha(dex)', 'err_lum_age_lower(Gyr)', 'err_lum_age_upper(Gyr)', 'err_lum_met_lower(dex)', 'err_lum_met_upper(dex)', 'err_lum_alpha_lower(dex)', 'err_lum_alpha_upper(dex)', 'M/L', 'mass_age(Gyr)', 'mass_met(dex)', 'mass_alpha(dex)', 'err_mass_age_lower(Gyr)', 'err_mass_age_upper(Gyr)', 'err_mass_met_lower(dex)', 'err_mass_met_upper(dex)', 'err_mass_alpha_lower(dex)', 'err_mass_alpha_upper(dex)', 'Chi2', 'S/N']

                rv_pop = np.zeros(spectra_number)
                sigma_pop = np.zeros(spectra_number)
                h3_pop = np.zeros(spectra_number)
                h4_pop = np.zeros(spectra_number)
                age_pop = np.zeros(spectra_number)
                alpha_pop = np.zeros(spectra_number)
                met_pop = np.zeros(spectra_number)
                mass_age_pop = np.zeros(spectra_number)
                mass_met_pop = np.zeros(spectra_number)
                mass_alpha_pop = np.zeros(spectra_number)
                ml_pop = np.zeros(spectra_number)
                chi2_pop = np.zeros(spectra_number)

                err_age_lower_pop = np.zeros(spectra_number)
                err_age_upper_pop = np.zeros(spectra_number)
                err_met_lower_pop = np.zeros(spectra_number)
                err_met_upper_pop = np.zeros(spectra_number)
                err_alpha_lower_pop = np.zeros(spectra_number)
                err_alpha_upper_pop = np.zeros(spectra_number)
                err_mass_age_lower_pop = np.zeros(spectra_number)
                err_mass_age_upper_pop = np.zeros(spectra_number)
                err_mass_met_lower_pop = np.zeros(spectra_number)
                err_mass_met_upper_pop = np.zeros(spectra_number)
                err_mass_alpha_lower_pop = np.zeros(spectra_number)
                err_mass_alpha_upper_pop = np.zeros(spectra_number)
                snr_pop = np.zeros(spectra_number)

                pop_data_array = np.column_stack((spec_names_nopath, rv_pop,sigma_pop,h3_pop,h4_pop,age_pop,met_pop,alpha_pop,err_age_lower_pop, err_age_upper_pop, err_met_lower_pop, err_met_upper_pop, err_alpha_lower_pop, err_alpha_upper_pop, ml_pop, mass_age_pop, mass_met_pop,mass_alpha_pop,err_mass_age_lower_pop, err_mass_age_upper_pop,err_mass_met_lower_pop, err_mass_met_upper_pop, err_mass_alpha_lower_pop, err_mass_alpha_upper_pop,chi2_pop,snr_pop))


                #generating the dataframe and adding the data
                df_pop = pd.DataFrame(pop_data_array, columns = pop_id)

                #writing to a file
                df_pop.to_csv(pop_file, index= True, sep=' ')

                #creating the Lick/IDS stellar parameters file, if activated
                if stellar_parameters_lick_ppxf == True:

                    ssp_param_file_ppxf = result_ppxf_pop_data_dir+'/'+spectra_list_name+'_ssp_param_lick_ppxf_' +timestamp + '.dat'
                    ssp_param_id_ppxf = ['#Spectrum','Hbeta(A)', 'Hbeta_err(A)', 'Mg2(mag)', 'Mg2_err(mag)', 'Mgb(A)', 'Mgb_err(A)', 'Fem(A)', 'Fem_err(A)', 'MgFe(A)', 'MgFe_err(A)', 'age(Gyr)', 'err_age', 'met', 'err_met', 'alpha','err_alpha']

                    #Innitialising the arrays to be stored
                    hbeta_ssp_ppxf = np.zeros(spectra_number)
                    hbetaerr_ssp_ppxf = np.zeros(spectra_number)
                    mg2_ssp_ppxf = np.zeros(spectra_number)
                    mg2err_ssp_ppxf = np.zeros(spectra_number)
                    mgb_ssp_ppxf = np.zeros(spectra_number)
                    mgberr_ssp_ppxf = np.zeros(spectra_number)
                    fem_ssp_ppxf = np.zeros(spectra_number)
                    femerr_ssp_ppxf = np.zeros(spectra_number)
                    mgfe_ssp_ppxf = np.zeros(spectra_number)
                    mgfeerr_ssp_ppxf = np.zeros(spectra_number)
                    age_ssp_ppxf = np.zeros(spectra_number)
                    age_err_ssp_ppxf = np.zeros(spectra_number)
                    met_ssp_ppxf = np.zeros(spectra_number)
                    met_err_ssp_ppxf = np.zeros(spectra_number)
                    alpha_ssp_ppxf = np.zeros(spectra_number)
                    alpha_err_ssp_ppxf = np.zeros(spectra_number)

                    ssp_param_array_ppxf = np.column_stack((spec_names_nopath, hbeta_ssp_ppxf, hbetaerr_ssp_ppxf, mg2_ssp_ppxf, mg2err_ssp_ppxf, mgb_ssp_ppxf, mgberr_ssp_ppxf, fem_ssp_ppxf, femerr_ssp_ppxf, mgfe_ssp_ppxf, mgfeerr_ssp_ppxf, age_ssp_ppxf, age_err_ssp_ppxf, met_ssp_ppxf, met_err_ssp_ppxf, alpha_ssp_ppxf, alpha_err_ssp_ppxf))

                    #generating the dataframe and adding the data
                    df_ssp_param_ppxf = pd.DataFrame(ssp_param_array_ppxf, columns = ssp_param_id_ppxf)

                    #writing to a file
                    df_ssp_param_ppxf.to_csv(ssp_param_file_ppxf, index= True, sep=' ')


    #***********************************************************************************************
    #***********************************************************************************************
    #********************* FILE DEFINITION ENDS ****************************************************
    #***********************************************************************************************

    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************
    #***********************************************************************************************





    #***********************************************************************************************
    #***********************************************************************************************
    # *************************** cycle for all the spectra! ***************************************
            for i in range(spectra_number):

                print (spec_names_nopath[i])

                # 1) READ THE SPECTRA
                wavelength, flux, original_step, obj_name = stm.read_spec(spec_names[i], lambda_units)
                wave_limits = np.array([np.min(wavelength), np.max(wavelength)])

                #**************** spectra pre-processing

                try:
                    original_wavelength = wavelength
                    original_flux = flux
                except:
                    print ('Something went wrong')


                # If the user re-ordering is activated:
                if reorder_op == True:

                    # The operations on all the spectra are not available for 'Process all'
                    if do_nothing == False or use_for_spec_an == True:
                        if i == 0:
                            sg.popup('Mean and sum of all the spectra require click on process selected')
                        continue

                    #Cycling for all the active re-ordered tasks
                    for op_name, op_var in reordered_operations:



                # 1) CROPPING
                        if op_var == "cropping_spectrum":
                            task_done2 = 1
                            task_spec2 = 1
                            if i == 0:
                                print ('*** Cropping task ***')
                            cropping_range = np.array([cropping_low_wave,cropping_high_wave])
                            cropped_wavelength, cropped_flux = spman.crop_spec(wavelength, flux, cropping_range)

                            if len(cropped_wavelength)>10:
                                wavelength =  cropped_wavelength
                                flux = cropped_flux
                            else:
                                print ('WARNING: The crop window is not in the spectral range. Skipping...')


                            try:
                                if save_intermediate_files == True :
                                    file_cropped = result_spec+'crop_' + spec_names_nopath[i] + '.fits'
                                    uti.save_fits(wavelength, flux, file_cropped)
                                    print ('File saved: ', file_cropped)
                                    print('')
                            except ValueError:
                                print ('Something went wrong, cannot complete the task. Check the spectrum. Tip: it is really a spectrum or a SED?')
                                #continue

                            if save_plot == True:
                                plt.plot
                                plt.title('Cropped ' + spec_names_nopath[i])
                                plt.plot(original_wavelength, original_flux, label = 'Original')
                                plt.plot(wavelength, flux, label = 'Cropped')
                                plt.xlabel('Wavelength (nm)')
                                plt.ylabel('Flux')
                                plt.legend(fontsize = 10)

                                plt.savefig(result_plot_dir + '/'+ 'cropped_' + spec_names_nopath[i] + '.png', format='png', dpi=300)
                                plt.close()

                            #putting the NEW limit range of the spectra
                            wave_limits = np.array([np.min(wavelength), np.max(wavelength)])



                    # 2) DYNAMIC CLEANING
                        elif op_var == "sigma_clipping":
                            if sigma_clip_have_file == False:
                                task_done2 = 1
                                task_spec2 = 1
                                if i == 0:
                                    print ('Running sigma clipping task...')

                                clip_wavelength, clip_flux = spman.sigma_clip(wavelength, flux, clip_factor, sigma_clip_resolution, sigma_clip_single_value)

                                wavelength = clip_wavelength
                                flux = clip_flux

                                #writing file
                                try:
                                    if (save_intermediate_files == True):
                                        file_clipped = result_spec+'clip_' + spec_names_nopath[i] + '.fits'
                                        uti.save_fits(wavelength, flux, file_clipped)
                                        print ('File saved: ', file_clipped)
                                        print('')
                                except ValueError:
                                    print ('Something went wrong with the spectrum. Tip: it is really a spectrum or a SED? Skipping...')

                                if save_plot == True:
                                    plt.plot
                                    plt.title('cleaned ' + spec_names_nopath[i])
                                    plt.plot(original_wavelength, original_flux, label = 'Original')
                                    plt.plot(wavelength, flux, label = 'Cleaned')
                                    plt.xlabel('Wavelength (nm)')
                                    plt.ylabel('Flux')
                                    plt.legend(fontsize = 10)

                                    plt.savefig(result_plot_dir + '/'+ 'cleaned_' + spec_names_nopath[i] + '.png', format='png', dpi=300)
                                    plt.close()

                            elif sigma_clip_have_file == True:
                                task_done2 = 1
                                task_spec2 = 1
                                if i == 0:
                                    print ('Running sigma clipping task...')

                                if i == 0:
                                    cond_clip = (os.path.isfile(sigma_clip_sigma_file))

                                if cond_clip == False:
                                    if i == 0:
                                        sg.popup('The sigma clip file does not exist. I will skip it...')
                                    continue


                                #check if the data in the file are ok
                                if i == 0:
                                    bad_file = 0
                                    try:
                                        sigma_clip_resolution = np.loadtxt(sigma_clip_sigma_file, usecols =[1])
                                        sigma_clip_vel_value = np.loadtxt(sigma_clip_sigma_file, usecols =[2])
                                    except ValueError:
                                        bad_file = 1

                                #if they are NOT ok
                                if bad_file == 1:
                                    if i == 0:
                                        sg.popup ('Input sigma clip data file not valid!')
                                    continue

                                #check the length of the file
                                if len(sigma_clip_vel_value) != spectra_number:
                                    if i == 0:
                                        sg.popup ('The sigma clip file does not have the same length of the spectra list file')
                                    continue

                                #doing the calculation only if the file is ok
                                if bad_file == 0:

                                    clip_wavelength, clip_flux = spman.sigma_clip(wavelength, flux, clip_factor, sigma_clip_resolution[i], sigma_clip_vel_value[i])

                                    wavelength = clip_wavelength
                                    flux = clip_flux

                                    #writing file
                                    try:
                                        if (save_intermediate_files == True):
                                            file_clipped = result_spec+'clip_' + spec_names_nopath[i] + '.fits'
                                            uti.save_fits(wavelength, flux, file_clipped)
                                            print ('File saved: ', file_clipped)
                                            print('')
                                    except ValueError:
                                        print ('Something went wrong with the spectrum. Tip: it is really a spectrum or a SED? Skipping...')
                                        continue

                                    if save_plot == True:
                                        plt.plot
                                        plt.title('cleaned ' + spec_names_nopath[i])
                                        plt.plot(original_wavelength, original_flux, label = 'Original')
                                        plt.plot(wavelength, flux, label = 'Cleaned')
                                        plt.xlabel('Wavelength (nm)')
                                        plt.ylabel('Flux')
                                        plt.legend(fontsize = 10)

                                        plt.savefig(result_plot_dir + '/'+ 'cleaned_' + spec_names_nopath[i] + '.png', format='png', dpi=300)
                                        plt.close()



                    # 3) WAVELET CLEANING
                        elif op_var == "wavelet_cleaning":
                            task_done2 = 1
                            task_spec2 = 1
                            if i == 0:
                                print ('*** Wavelet denoise task ***')

                            denoised_flux = spman.wavelet_cleaning(wavelength, flux, sigma_wavelets, wavelets_layers)
                            flux = denoised_flux
                            try:
                                if save_intermediate_files == True :
                                    file_wavelet = result_spec+'wavelet_' + spec_names_nopath[i] + '.fits'
                                    uti.save_fits(wavelength, flux, file_wavelet)
                                    print ('File saved: ', file_wavelet)
                                    print('')
                            except ValueError:
                                print ('Something went wrong, cannot complete the task. Check the spectrum. Tip: it is really a spectrum or a SED?')

                            if save_plot == True:
                                plt.plot
                                plt.title('wavelet_cleaned_ ' + spec_names_nopath[i])
                                plt.plot(original_wavelength, original_flux, label = 'Original')
                                plt.plot(wavelength, flux, label = 'Cleaned')
                                plt.xlabel('Wavelength (nm)')
                                plt.ylabel('Flux')
                                plt.legend(fontsize = 10)

                                plt.savefig(result_plot_dir + '/'+ 'wavelet_cleaned_' + spec_names_nopath[i] + '.png', format='png', dpi=300)
                                plt.close()



                    # 4) FILTERING AND DENOISING
                        elif op_var == "filter_denoise":
                            task_done2 = 1
                            task_spec2 = 1
                            if i == 0:
                                print ('Running denoising task')

                            if moving_average == True and box_moving_avg == True:
                                denoised_flux = spman.mov_avg(flux, box_moving_avg_size)
                                flux = denoised_flux
                            if moving_average == True and gauss_moving_avg == True:
                                denoised_flux = spman.mov_avg_gauss(wavelength, flux, gauss_moving_avg_kernel)
                                flux = denoised_flux
                            if low_pass_filter == True:
                                denoised_flux = spman.lowpass(wavelength, flux, lowpass_cut_off, lowpass_order)
                                flux = denoised_flux
                            if bandpass_filter == True:
                                denoised_flux = spman.bandpass(wavelength, flux, bandpass_lower_cut_off, bandpass_upper_cut_off, bandpass_order)
                                flux = denoised_flux

                            if event == 'Process selected' and save_intermediate_files == True:
                                file_mov_avg = result_spec+'denoised_' + prev_spec_nopath + '.fits'
                                uti.save_fits(wavelength, flux, file_mov_avg)
                                print ('File saved: ', file_mov_avg)
                                print('')


                            if (save_intermediate_files == True):
                                file_denoised = result_spec+'denoised_' + spec_names_nopath[i] + '.fits'
                                uti.save_fits(wavelength, flux, file_denoised)
                                print ('File saved: ', file_denoised)
                                print('')



                    # 5) DOPPLER CORRECTION
                        #dopcor, for process all
                        elif op_var == "dop_cor":
                            if dop_cor_single_shot == False:
                                task_done2 = 1
                                task_spec2 = 1
                                if i == 0:
                                    print ('Running doppler correction task...')

                                #test if file file exist
                                if i == 0:
                                    cond = (os.path.isfile(dop_cor_file))
                                if cond == False:
                                    if i == 0:
                                        sg.popup('The doppler correction file does not exist. I will skip it...')
                                    continue

                                #check if the data in the file are ok
                                if i == 0:
                                    bad_file = 0
                                    try:
                                        dopcor_values = np.loadtxt(dop_cor_file, usecols=[1])
                                    except ValueError:
                                        bad_file = 1

                                #if they are not ok:
                                if bad_file == 1:
                                    if i == 0:
                                        sg.popup ('Input dopcor data file not valid!')
                                    continue

                                #check on the length of the file
                                if len(dopcor_values) != spectra_number:
                                    if i == 0:
                                        sg.popup ('The dopcor file does not have the same length of the spectra list file')
                                    continue

                                #doing the calculation only if the file is ok
                                if bad_file == 0:
                                    dopcor_wave, dopcor_flux = spman.dopcor(wavelength, flux, dopcor_values[i], dop_cor_have_vel)
                                    wavelength = dopcor_wave
                                    flux = dopcor_flux
                                    #output to see if the names and values match
                                    print(spec_names_nopath[i], dopcor_values[i])

                                    #writing to file
                                    if (save_intermediate_files == True):
                                        file_dopcor = result_spec+'dopcor_' + spec_names_nopath[i] + '.fits'
                                        uti.save_fits(wavelength, flux, file_dopcor)
                                        print ('File saved: ', file_dopcor)
                                        print('')

                                #putting the NEW limit range of the spectra
                                wave_limits = np.array([np.min(wavelength), np.max(wavelength)])

                            #to calculate also with just one value
                            elif dop_cor_single_shot == True:
                                task_done2 = 1
                                task_spec2 = 1
                                if i == 0:
                                    print ('Running doppler correction task...')
                                dopcor_wave, dopcor_flux = spman.dopcor(wavelength, flux, dop_cor_single_shot_vel, dop_cor_have_vel)
                                wavelength = dopcor_wave
                                flux = dopcor_flux
                                #output to see if the names and values match
                                print(spec_names_nopath[i], dop_cor_single_shot_vel)

                                #writing to file
                                if (save_intermediate_files == True):
                                    file_dopcor = result_spec+'dopcor_' + spec_names_nopath[i] + '.fits'
                                    uti.save_fits(wavelength, flux, file_dopcor)
                                    print ('File saved: ', file_dopcor)
                                    print('')

                                #putting the NEW limit range of the spectra
                                wave_limits = np.array([np.min(wavelength), np.max(wavelength)])



                    # 6) HELIOCENTRIC CORRECTION
                        elif op_var == "helio_corr":
                            if helio_single_shot == False:
                                task_done2 = 1
                                task_spec2 = 1
                                if i == 0:
                                    print ('Running heliocentric correction task...')

                                #test if file file exist
                                if i == 0:
                                    cond2 = (os.path.isfile(helio_file))
                                if cond2 == False:
                                    if i == 0:
                                        sg.popup('The heliocentric file correction does not exist. I will skip it...')
                                    continue

                                #load the file
                                #the string part
                                if cond2 == True:
                                    location, date = np.loadtxt(helio_file, dtype = 'str', usecols=[0,1]).T
                                #the numbers
                                if i == 0:
                                    bad_file = 0
                                    go_conditions = 0
                                    try:
                                        ra, dec = np.loadtxt(helio_file, usecols=[2,3]).T
                                    except ValueError:
                                        bad_file = 1

                                if bad_file == 1:
                                    if i == 0:
                                        sg.popup ('Input data not valid!')
                                    continue


                                #Checking if the loaded data are ok. Canoot do before because otherwise the control will be performed even when I don't press the correct button
                                if  i == 0:
                                    coord_not_valid = 0
                                    date_not_valid  = 0
                                    location_not_valid = 0

                                    for s in range(len(location)):
                                        try:
                                            datetime.datetime.strptime(date[s], '%Y-%m-%d')
                                        except ValueError:
                                            date_not_valid = 1
                                            continue
                                        try:
                                            location_test = EarthLocation.of_site(location[s])
                                        except Exception:
                                            location_not_valid = 1
                                            continue

                                if (date_not_valid == 1 or location_not_valid == 1):
                                    if i == 0:
                                        sg.popup ('Data in the heliocentric file is not valid. Please check!')
                                    continue

                                #check on the length of the file
                                if len(location) != spectra_number:
                                    if i == 0:
                                        sg.popup ('The helio file does not have the same length of the spectra file')
                                    continue

                                if i == 0:
                                    go_conditions = bad_file+date_not_valid+location_not_valid

                                if go_conditions == 0:
                                    correction, new_wavelength, new_flux = spman.helio_corr(wavelength, flux, date[i], location[i], ra[i], dec[i])
                                    wavelength = new_wavelength
                                    flux = new_flux

                                    #putting the NEW limit range of the spectra
                                    wave_limits = np.array([np.min(wavelength), np.max(wavelength)])
                                    #output
                                    print (spec_names_nopath[i], date[i], location[i], ra[i],dec[i], correction, 'km/s')
                                    print ('')

                                    #writing to a file
                                    if (save_intermediate_files == True):
                                        file_heliocorr = result_spec+'heliocorr_' + spec_names_nopath[i] + '.fits'
                                        uti.save_fits(wavelength, flux, file_heliocorr)
                                        print ('File saved: ', file_heliocorr)
                                        print('')

                            elif helio_single_shot == True:
                                task_done2 = 1
                                task_spec2 = 1
                                if i == 0:
                                    print ('Running heliocentric correction task...')

                                correction, new_wavelength, new_flux = spman.helio_corr(wavelength, flux, helio_single_shot_date, helio_single_shot_location, ra_obj, dec_obj)
                                wavelength = new_wavelength
                                flux = new_flux
                                #output
                                print (spec_names_nopath[i], helio_single_shot_date, helio_single_shot_location, ra_obj, dec_obj, correction, 'km/s')
                                print ('')

                                #putting the NEW limit range of the spectra
                                wave_limits = np.array([np.min(wavelength), np.max(wavelength)])

                                #writing to a file
                                if (save_intermediate_files == True):
                                    file_heliocorr = result_spec+'heliocorr_' + spec_names_nopath[i] + '.fits'
                                    uti.save_fits(wavelength, flux, file_heliocorr)
                                    print ('File saved: ', file_heliocorr)
                                    print('')





            #************************************** SPECTRA PROCESSING *************************

                        elif op_var == "rebining":
                            # 1) REBIN
                            #a) linear
                            if rebinning_linear == True:
                                task_done2 = 1
                                task_spec2 = 1
                                if i == 0:
                                    print ('Running rebin linear task...')

                                rebinned_wave, rebinned_flux, npoints = spman.resample(wavelength, flux, rebin_step_pix)
                                wavelength = rebinned_wave
                                flux = rebinned_flux

                                #writing file
                                if (save_intermediate_files == True):
                                    file_rebinned = result_spec+'rebin_lin_' + spec_names_nopath[i] + '.fits'
                                    uti.save_fits(wavelength, flux, file_rebinned)
                                    print ('File saved: ', file_rebinned)
                                    print('')

                                #b) log
                            if rebinning_log == True:
                                task_done2 = 1
                                task_spec2 = 1

                                if i == 0:
                                    print ('Running log rebin task...')

                                rebinned_wave_log, rebinned_flux_log = spman.log_rebin(wavelength, flux, rebin_step_sigma)
                                wavelength = rebinned_wave_log
                                flux = rebinned_flux_log

                                #writing file
                                if (save_intermediate_files == True):
                                    file_rebinned_log = result_spec+'rebin_log_' + spec_names_nopath[i] + '.fits'
                                    uti.save_fits(wavelength, flux, file_rebinned_log)
                                    print ('File saved: ', file_rebinned_log)
                                    print('')



                    # 2) DEGRADE RESOLUTION
                        elif op_var == "degrade":
                            #a) DEGRADE FROM R TO R
                            if is_initial_res_r == True and res_degrade_to_r == True:

                                task_done2 = 1
                                task_spec2 = 1
                                if i == 0:
                                    print ('Running degrade resolution task...')

                                degraded_wave, degraded_flux = spman.degrade(wavelength, flux, initial_res_r, final_res_r, True)
                                wavelength = degraded_wave
                                flux = degraded_flux

                                if save_intermediate_files == True:
                                    degraded_res = str(int(round(final_res_r)))
                                    file_degraded = result_spec+'degraded_R' + degraded_res + '_' + spec_names_nopath[i] + '.fits'
                                    uti.save_fits(wavelength, flux, file_degraded)
                                    print ('File saved: ', file_degraded)
                                    print('')


                                #b) DEGRADE FROM R TO FWHM
                            if is_initial_res_r == True and res_degrade_to_fwhm == True:
                                task_done2 = 1
                                task_spec2 = 1

                                if i == 0:
                                    print ('Running degrade resolution task...')

                                degraded_wave, degraded_flux = spman.degradeRtoFWHM(wavelength, flux, initial_res_r, final_res_r_to_fwhm)
                                wavelength = degraded_wave
                                flux = degraded_flux

                                if save_intermediate_files == True:
                                    degraded_res_R_to_FWHM = str(float(round(final_res_r_to_fwhm,1)))
                                    file_degraded_R_to_FWHM = result_spec+'degraded_FWHM' + degraded_res_R_to_FWHM + '_' + spec_names_nopath[i] + '.fits'
                                    uti.save_fits(wavelength, flux, file_degraded_R_to_FWHM)
                                    print ('File saved: ', file_degraded_R_to_FWHM)
                                    print('')


                                #c) DEGRADE FROM FWHM TO FWHM
                            if is_initial_res_fwhm == True:

                                task_done2 = 1
                                task_spec2 = 1
                                if i == 0:
                                    print ('Running degrade resolution in lambda task...')

                                degraded_wave, degraded_flux = spman.degrade_lambda(wavelength, flux, initial_res_fwhm, final_res_fwhm)

                                #update the variables. necessary because I will use always wavelength and flux for the other functions!
                                wavelength = degraded_wave
                                flux = degraded_flux

                                if save_intermediate_files == True:
                                    degraded_res_lambda = str(float(round(final_res_fwhm,1)))
                                    file_degraded_lambda = result_spec+'degraded_FWHM' + degraded_res_lambda + '_' + spec_names_nopath[i] + '.fits'
                                    uti.save_fits(wavelength, flux, file_degraded_lambda)
                                    print ('File saved: ', file_degraded_lambda)
                                    print('')



                    # 3) NORMALISE SPECTRUM TO
                        elif op_var == "normalize_wave":

                            task_done2 = 1
                            task_spec2 = 1
                                        #check the limits
                            if (norm_wave < wave_limits[0] or norm_wave > wave_limits[1]):
                                print('Normalisation wavelength exceeds the range of the spectrum! Skipping')

                            else:
                                if i == 0:
                                    print ('Running normalise task...')

                                step = wavelength[1]-wavelength[0]
                                epsilon_norm = step*10. #averaging on 10 steps values, rather than one value
                                norm_flux = spman.norm_spec(wavelength, flux, norm_wave, epsilon_norm, flux)
                                flux = norm_flux

                                if (save_intermediate_files == True):
                                    norm_suffix = str(norm_wave)
                                    file_normalized = result_spec+'norm' + norm_suffix + '_' + spec_names_nopath[i] + '.fits'
                                    uti.save_fits(wavelength, flux, file_normalized)
                                    print ('File saved: ', file_normalized)
                                    print('')



                    # 4) SIGMA BROADENING
                        elif op_var == "sigma_broad":
                            task_done2 = 1
                            task_spec2 = 1
                            if i == 0:
                                print ('Running sigma broadening task...')

                            broadened_flux = spman.sigma_broad(wavelength, flux, sigma_to_add)
                            flux = broadened_flux

                            if (save_intermediate_files == True):
                                broad_suffix = str(int(round(sigma_to_add)))
                                file_broad = result_spec+'broad' + broad_suffix + spec_names_nopath[i] + '.fits'
                                uti.save_fits(wavelength, flux, file_broad)
                                print ('File saved: ', file_broad)
                                print('')



                    # 5) ADD NOISE
                        elif op_var == "add_noise":
                            task_done2 = 1
                            task_spec2 = 1
                            if i == 0:
                                print ('Running add noise task...')

                            noisy_flux = spman.add_noise(wavelength, flux, noise_to_add)
                            flux = noisy_flux

                            if (save_intermediate_files == True):
                                noise_suffix = str(int(round(noise_to_add)))
                                file_noise = result_spec+'SNR' + noise_suffix +'_'+ spec_names_nopath[i] + '.fits'
                                uti.save_fits(wavelength, flux, file_noise)
                                print ('File saved: ', file_noise)
                                print('')



                    # 6) CONTINUUM MODELLING
                        elif op_var == "continuum_sub":
                            task_done2 = 1
                            task_spec2 = 1
                            if i == 0:
                                print ('Running continuum subtraction task...')

                            if cont_model_filtering == True:
                                corrected_flux, continuum_flux = spman.sub_cont(wavelength, flux, cont_math_operation)

                            if cont_model_poly == True:
                                corrected_flux, continuum_flux = spman.continuum(wavelength, flux, cont_want_to_maks, cont_mask_ranges, cont_poly_degree, cont_math_operation, False)

                            flux = corrected_flux

                            if (save_intermediate_files == True):
                                file_cont_sub = result_spec+'cont_sub_' + spec_names_nopath[i] + '.fits'
                                file_cont = result_spec+'cont_' + spec_names_nopath[i] + '.fits'
                                uti.save_fits(wavelength, flux, file_cont_sub)
                                uti.save_fits(wavelength, continuum_flux, file_cont)
                                print ('File saved: ', file_cont_sub)
                                print ('File saved: ', file_cont)
                                print('')




            #******************************************* SPEC MATH ********************************************


                    # 1) subtract normalized average
                        elif op_var == "subtract_normalized_avg":
                            task_done2 = 1
                            task_spec2 = 1
                            if i == 0:
                                print ('Running subtract normalised average task...')

                            subtracted_flux = spmt.sub_norm_avg(wavelength, flux, lambda_units, spectra_number, spec_names)
                            flux = subtracted_flux

                            if (save_intermediate_files == True):
                                file_subtracted_avg = result_spec+'subtracted_average' + spec_names_nopath[i] + '.fits'
                                uti.save_fits(wavelength, flux, file_subtracted_avg)
                                print ('File saved: ', file_subtracted_avg)
                                print('')


                    # 2) subtract normalized single
                        elif op_var == "subtract_normalized_spec":
                            task_done2 = 1
                            task_spec2 = 1

                            #test if file file exist
                            cond000 = (os.path.isfile(spectra_to_subtract))
                            if cond000 == False:
                                if i == 0:
                                    sg.popup('The file to subtract does not exist. Skipping...')

                            if cond000 == True:
                                if i == 0:
                                    print ('Running subtract normalised spectrum task...')

                                subtracted_single_flux = spmt.sub_norm_single(wavelength, flux, spectra_to_subtract, lambda_units)
                                flux = subtracted_single_flux

                                if (save_intermediate_files == True):
                                    file_subtracted_single = result_spec+'subtracted_single' + spec_names_nopath[i] + '.fits'
                                    uti.save_fits(wavelength, flux, file_subtracted_single)
                                    print ('File saved: ', file_subtracted_single)
                                    print('')


                    # 3) add pedestal
                        elif op_var == "add_pedestal":
                            task_done2 = 1
                            task_spec2 = 1
                            if i == 0:
                                print ('Running add pedestal task...')

                            flux = flux + pedestal_to_add

                            if (save_intermediate_files == True):
                                pedestal_suffix = str(int(round(pedestal_to_add)))
                                file_pedestal = result_spec+'pedestal' + pedestal_suffix + spec_names_nopath[i] + '.fits'
                                uti.save_fits(wavelength, flux, file_pedestal)
                                print ('File saved: ', file_pedestal)
                                print('')


                    # 4) multiply by a constant
                        elif op_var == "multiply":
                            task_done2 = 1
                            task_spec2 = 1
                            if i == 0:
                                print ('Running add pedestal task...')

                            flux = flux*multiply_factor

                            if (save_intermediate_files == True):
                                multiplied_suffix = str(int(round(multiply_factor)))
                                file_multiplied = result_spec+'multiplied' + multiplied_suffix + spec_names_nopath[i] + '.fits'
                                uti.save_fits(wavelength, flux, file_multiplied)
                                print ('File saved: ', file_multiplied)
                                print('')


                    # 5) derivatives
                        elif op_var == "derivatives":
                            task_done2 = 1
                            task_spec2 = 1
                            print ('*** First and second derivatives ***')
                            print ('WARNING: these are NOT used for spectral analysis tasks')

                            try:
                                first_derivative = np.gradient(flux, wavelength)
                                second_derivative = np.gradient(first_derivative, wavelength)

                                file_first_derivative = result_spec+'first_deriv_'+ spec_names_nopath[i] + '.fits'
                                file_second_derivative = result_spec+'second_deriv_'+ spec_names_nopath[i] + '.fits'
                                uti.save_fits(wavelength, first_derivative, file_first_derivative)
                                uti.save_fits(wavelength, second_derivative, file_second_derivative)
                                print ('Derivative spectra saved: ', file_first_derivative, file_second_derivative)
                                print('')

                            except Exception:
                                print ('Cannot compute the derivatives. Skipping...')


                # If the user re-ordering is activated:
                if reorder_op == False:

                    # The operations on all the spectra are not available for 'Process all'
                    if do_nothing == False or use_for_spec_an == True:
                        if i == 0:
                            sg.popup('Mean and sum of all the spectra require click on process selected')
                        continue


                # 1) CROPPING
                    if cropping_spectrum == True:
                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('*** Cropping task ***')
                        cropping_range = np.array([cropping_low_wave,cropping_high_wave])
                        cropped_wavelength, cropped_flux = spman.crop_spec(wavelength, flux, cropping_range)

                        if len(cropped_wavelength)>10:
                            wavelength =  cropped_wavelength
                            flux = cropped_flux
                        else:
                            print ('WARNING: The crop window is not in the spectral range. Skipping...')


                        try:
                            if save_intermediate_files == True :
                                file_cropped = result_spec+'crop_' + spec_names_nopath[i] + '.fits'
                                uti.save_fits(wavelength, flux, file_cropped)
                                print ('File saved: ', file_cropped)
                                print('')
                        except ValueError:
                            print ('Something went wrong, cannot complete the task. Check the spectrum. Tip: it is really a spectrum or a SED?')
                            #continue

                        if save_plot == True:
                            plt.plot
                            plt.title('Cropped ' + spec_names_nopath[i])
                            plt.plot(original_wavelength, original_flux, label = 'Original')
                            plt.plot(wavelength, flux, label = 'Cropped')
                            plt.xlabel('Wavelength (nm)')
                            plt.ylabel('Flux')
                            plt.legend(fontsize = 10)

                            plt.savefig(result_plot_dir + '/'+ 'cropped_' + spec_names_nopath[i] + '.png', format='png', dpi=300)
                            plt.close()

                        #putting the NEW limit range of the spectra
                        wave_limits = np.array([np.min(wavelength), np.max(wavelength)])



                # 2) DYNAMIC CLEANING
                    if sigma_clipping == True and sigma_clip_have_file == False:
                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('Running sigma clipping task...')

                        clip_wavelength, clip_flux = spman.sigma_clip(wavelength, flux, clip_factor, sigma_clip_resolution, sigma_clip_single_value)

                        wavelength = clip_wavelength
                        flux = clip_flux

                        #writing file
                        try:
                            if (save_intermediate_files == True):
                                file_clipped = result_spec+'clip_' + spec_names_nopath[i] + '.fits'
                                uti.save_fits(wavelength, flux, file_clipped)
                                print ('File saved: ', file_clipped)
                                print('')
                        except ValueError:
                            print ('Something went wrong with the spectrum. Tip: it is really a spectrum or a SED? Skipping...')

                        if save_plot == True:
                            plt.plot
                            plt.title('cleaned ' + spec_names_nopath[i])
                            plt.plot(original_wavelength, original_flux, label = 'Original')
                            plt.plot(wavelength, flux, label = 'Cleaned')
                            plt.xlabel('Wavelength (nm)')
                            plt.ylabel('Flux')
                            plt.legend(fontsize = 10)

                            plt.savefig(result_plot_dir + '/'+ 'cleaned_' + spec_names_nopath[i] + '.png', format='png', dpi=300)
                            plt.close()

                    elif (sigma_clipping == True and sigma_clip_have_file == True):
                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('Running sigma clipping task...')

                        if i == 0:
                            cond_clip = (os.path.isfile(sigma_clip_sigma_file))

                        if cond_clip == False:
                            if i == 0:
                                sg.popup('The sigma clip file does not exist. I will skip it...')
                            continue


                        #check if the data in the file are ok
                        if i == 0:
                            bad_file = 0
                            try:
                                sigma_clip_resolution = np.loadtxt(sigma_clip_sigma_file, usecols =[1])
                                sigma_clip_vel_value = np.loadtxt(sigma_clip_sigma_file, usecols =[2])
                            except ValueError:
                                bad_file = 1

                        #if they are NOT ok
                        if bad_file == 1:
                            if i == 0:
                                sg.popup ('Input sigma clip data file not valid!')
                            continue

                        #check the length of the file
                        if len(sigma_clip_vel_value) != spectra_number:
                            if i == 0:
                                sg.popup ('The sigma clip file does not have the same length of the spectra list file')
                            continue

                        #doing the calculation only if the file is ok
                        if bad_file == 0:

                            clip_wavelength, clip_flux = spman.sigma_clip(wavelength, flux, clip_factor, sigma_clip_resolution[i], sigma_clip_vel_value[i])

                            wavelength = clip_wavelength
                            flux = clip_flux

                            #writing file
                            try:
                                if (save_intermediate_files == True):
                                    file_clipped = result_spec+'clip_' + spec_names_nopath[i] + '.fits'
                                    uti.save_fits(wavelength, flux, file_clipped)
                                    print ('File saved: ', file_clipped)
                                    print('')
                            except ValueError:
                                print ('Something went wrong with the spectrum. Tip: it is really a spectrum or a SED? Skipping...')
                                continue

                            if save_plot == True:
                                plt.plot
                                plt.title('cleaned ' + spec_names_nopath[i])
                                plt.plot(original_wavelength, original_flux, label = 'Original')
                                plt.plot(wavelength, flux, label = 'Cleaned')
                                plt.xlabel('Wavelength (nm)')
                                plt.ylabel('Flux')
                                plt.legend(fontsize = 10)

                                plt.savefig(result_plot_dir + '/'+ 'cleaned_' + spec_names_nopath[i] + '.png', format='png', dpi=300)
                                plt.close()



                # 3) WAVELET CLEANING
                    if wavelet_cleaning == True:
                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('*** Wavelet denoise task ***')

                        denoised_flux = spman.wavelet_cleaning(wavelength, flux, sigma_wavelets, wavelets_layers)
                        flux = denoised_flux
                        try:
                            if save_intermediate_files == True :
                                file_wavelet = result_spec+'wavelet_' + spec_names_nopath[i] + '.fits'
                                uti.save_fits(wavelength, flux, file_wavelet)
                                print ('File saved: ', file_wavelet)
                                print('')
                        except ValueError:
                            print ('Something went wrong, cannot complete the task. Check the spectrum. Tip: it is really a spectrum or a SED?')

                        if save_plot == True:
                            plt.plot
                            plt.title('wavelet_cleaned_ ' + spec_names_nopath[i])
                            plt.plot(original_wavelength, original_flux, label = 'Original')
                            plt.plot(wavelength, flux, label = 'Cleaned')
                            plt.xlabel('Wavelength (nm)')
                            plt.ylabel('Flux')
                            plt.legend(fontsize = 10)

                            plt.savefig(result_plot_dir + '/'+ 'wavelet_cleaned_' + spec_names_nopath[i] + '.png', format='png', dpi=300)
                            plt.close()



                # 4) FILTERING AND DENOISING
                    if (filter_denoise == True):
                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('Running denoising task')

                        if moving_average == True and box_moving_avg == True:
                            denoised_flux = spman.mov_avg(flux, box_moving_avg_size)
                            flux = denoised_flux
                        if moving_average == True and gauss_moving_avg == True:
                            denoised_flux = spman.mov_avg_gauss(wavelength, flux, gauss_moving_avg_kernel)
                            flux = denoised_flux
                        if low_pass_filter == True:
                            denoised_flux = spman.lowpass(wavelength, flux, lowpass_cut_off, lowpass_order)
                            flux = denoised_flux
                        if bandpass_filter == True:
                            denoised_flux = spman.bandpass(wavelength, flux, bandpass_lower_cut_off, bandpass_upper_cut_off, bandpass_order)
                            flux = denoised_flux

                        if event == 'Process selected' and save_intermediate_files == True:
                            file_mov_avg = result_spec+'denoised_' + prev_spec_nopath + '.fits'
                            uti.save_fits(wavelength, flux, file_mov_avg)
                            print ('File saved: ', file_mov_avg)
                            print('')


                        if (save_intermediate_files == True):
                            file_denoised = result_spec+'denoised_' + spec_names_nopath[i] + '.fits'
                            uti.save_fits(wavelength, flux, file_denoised)
                            print ('File saved: ', file_denoised)
                            print('')



                # 5) DOPPLER CORRECTION
                    #dopcor, for process all
                    if (dop_cor == True and dop_cor_single_shot == False):
                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('Running doppler correction task...')

                        #test if file file exist
                        if i == 0:
                            cond = (os.path.isfile(dop_cor_file))
                        if cond == False:
                            if i == 0:
                                sg.popup('The doppler correction file does not exist. I will skip it...')
                            continue

                        #check if the data in the file are ok
                        if i == 0:
                            bad_file = 0
                            try:
                                dopcor_values = np.loadtxt(dop_cor_file, usecols=[1])
                            except ValueError:
                                bad_file = 1

                        #if they are not ok:
                        if bad_file == 1:
                            if i == 0:
                                sg.popup ('Input dopcor data file not valid!')
                            continue

                        #check on the length of the file
                        if len(dopcor_values) != spectra_number:
                            if i == 0:
                                sg.popup ('The dopcor file does not have the same length of the spectra list file')
                            continue

                        #doing the calculation only if the file is ok
                        if bad_file == 0:
                            dopcor_wave, dopcor_flux = spman.dopcor(wavelength, flux, dopcor_values[i], dop_cor_have_vel)
                            wavelength = dopcor_wave
                            flux = dopcor_flux
                            #output to see if the names and values match
                            print(spec_names_nopath[i], dopcor_values[i])

                            #writing to file
                            if (save_intermediate_files == True):
                                file_dopcor = result_spec+'dopcor_' + spec_names_nopath[i] + '.fits'
                                uti.save_fits(wavelength, flux, file_dopcor)
                                print ('File saved: ', file_dopcor)
                                print('')

                        #putting the NEW limit range of the spectra
                        wave_limits = np.array([np.min(wavelength), np.max(wavelength)])

                    #to calculate also with just one value
                    elif(dop_cor == True and dop_cor_single_shot == True):
                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('Running doppler correction task...')
                        dopcor_wave, dopcor_flux = spman.dopcor(wavelength, flux, dop_cor_single_shot_vel, dop_cor_have_vel)
                        wavelength = dopcor_wave
                        flux = dopcor_flux
                        #output to see if the names and values match
                        print(spec_names_nopath[i], dop_cor_single_shot_vel)

                        #writing to file
                        if (save_intermediate_files == True):
                            file_dopcor = result_spec+'dopcor_' + spec_names_nopath[i] + '.fits'
                            uti.save_fits(wavelength, flux, file_dopcor)
                            print ('File saved: ', file_dopcor)
                            print('')

                        #putting the NEW limit range of the spectra
                        wave_limits = np.array([np.min(wavelength), np.max(wavelength)])



                # 6) HELIOCENTRIC CORRECTION
                    if (helio_corr == True and helio_single_shot == False):
                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('Running heliocentric correction task...')

                        #test if file file exist
                        if i == 0:
                            cond2 = (os.path.isfile(helio_file))
                        if cond2 == False:
                            if i == 0:
                                sg.popup('The heliocentric file correction does not exist. I will skip it...')
                            continue

                        #load the file
                        #the string part
                        if cond2 == True:
                            location, date = np.loadtxt(helio_file, dtype = 'str', usecols=[0,1]).T
                        #the numbers
                        if i == 0:
                            bad_file = 0
                            go_conditions = 0
                            try:
                                ra, dec = np.loadtxt(helio_file, usecols=[2,3]).T
                            except ValueError:
                                bad_file = 1

                        if bad_file == 1:
                            if i == 0:
                                sg.popup ('Input data not valid!')
                            continue


                        #Checking if the loaded data are ok. Canoot do before because otherwise the control will be performed even when I don't press the correct button
                        if  i == 0:
                            coord_not_valid = 0
                            date_not_valid  = 0
                            location_not_valid = 0

                            for s in range(len(location)):
                                try:
                                    datetime.datetime.strptime(date[s], '%Y-%m-%d')
                                except ValueError:
                                    date_not_valid = 1
                                    continue
                                try:
                                    location_test = EarthLocation.of_site(location[s])
                                except Exception:
                                    location_not_valid = 1
                                    continue

                        if (date_not_valid == 1 or location_not_valid == 1):
                            if i == 0:
                                sg.popup ('Data in the heliocentric file is not valid. Please check!')
                            continue

                        #check on the length of the file
                        if len(location) != spectra_number:
                            if i == 0:
                                sg.popup ('The helio file does not have the same length of the spectra file')
                            continue

                        if i == 0:
                            go_conditions = bad_file+date_not_valid+location_not_valid

                        if go_conditions == 0:
                            correction, new_wavelength, new_flux = spman.helio_corr(wavelength, flux, date[i], location[i], ra[i], dec[i])
                            wavelength = new_wavelength
                            flux = new_flux

                            #putting the NEW limit range of the spectra
                            wave_limits = np.array([np.min(wavelength), np.max(wavelength)])
                            #output
                            print (spec_names_nopath[i], date[i], location[i], ra[i],dec[i], correction, 'km/s')
                            print ('')

                            #writing to a file
                            if (save_intermediate_files == True):
                                file_heliocorr = result_spec+'heliocorr_' + spec_names_nopath[i] + '.fits'
                                uti.save_fits(wavelength, flux, file_heliocorr)
                                print ('File saved: ', file_heliocorr)
                                print('')

                    elif(helio_corr == True and helio_single_shot == True):
                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('Running heliocentric correction task...')

                        correction, new_wavelength, new_flux = spman.helio_corr(wavelength, flux, helio_single_shot_date, helio_single_shot_location, ra_obj, dec_obj)
                        wavelength = new_wavelength
                        flux = new_flux
                        #output
                        print (spec_names_nopath[i], helio_single_shot_date, helio_single_shot_location, ra_obj, dec_obj, correction, 'km/s')
                        print ('')

                        #putting the NEW limit range of the spectra
                        wave_limits = np.array([np.min(wavelength), np.max(wavelength)])

                        #writing to a file
                        if (save_intermediate_files == True):
                            file_heliocorr = result_spec+'heliocorr_' + spec_names_nopath[i] + '.fits'
                            uti.save_fits(wavelength, flux, file_heliocorr)
                            print ('File saved: ', file_heliocorr)
                            print('')





        #************************************** SPECTRA PROCESSING *************************

                # 1) REBIN
                        #a) linear
                    if rebinning == True and rebinning_linear == True:
                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('Running rebin linear task...')

                        rebinned_wave, rebinned_flux, npoints = spman.resample(wavelength, flux, rebin_step_pix)
                        wavelength = rebinned_wave
                        flux = rebinned_flux

                        #writing file
                        if (save_intermediate_files == True):
                            file_rebinned = result_spec+'rebin_lin_' + spec_names_nopath[i] + '.fits'
                            uti.save_fits(wavelength, flux, file_rebinned)
                            print ('File saved: ', file_rebinned)
                            print('')

                        #b) log
                    if (rebinning == True and rebinning_log == True):
                        task_done2 = 1
                        task_spec2 = 1

                        if i == 0:
                            print ('Running log rebin task...')

                        rebinned_wave_log, rebinned_flux_log = spman.log_rebin(wavelength, flux, rebin_step_sigma)
                        wavelength = rebinned_wave_log
                        flux = rebinned_flux_log

                        #writing file
                        if (save_intermediate_files == True):
                            file_rebinned_log = result_spec+'rebin_log_' + spec_names_nopath[i] + '.fits'
                            uti.save_fits(wavelength, flux, file_rebinned_log)
                            print ('File saved: ', file_rebinned_log)
                            print('')



                # 2) DEGRADE RESOLUTION
                        #a) DEGRADE FROM R TO R
                    if degrade == True and is_initial_res_r == True and res_degrade_to_r == True:

                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('Running degrade resolution task...')

                        degraded_wave, degraded_flux = spman.degrade(wavelength, flux, initial_res_r, final_res_r, True)
                        wavelength = degraded_wave
                        flux = degraded_flux

                        if save_intermediate_files == True:
                            degraded_res = str(int(round(final_res_r)))
                            file_degraded = result_spec+'degraded_R' + degraded_res + '_' + spec_names_nopath[i] + '.fits'
                            uti.save_fits(wavelength, flux, file_degraded)
                            print ('File saved: ', file_degraded)
                            print('')


                        #b) DEGRADE FROM R TO FWHM
                    if degrade == True and is_initial_res_r == True and res_degrade_to_fwhm == True:
                        task_done2 = 1
                        task_spec2 = 1

                        if i == 0:
                            print ('Running degrade resolution task...')

                        degraded_wave, degraded_flux = spman.degradeRtoFWHM(wavelength, flux, initial_res_r, final_res_r_to_fwhm)
                        wavelength = degraded_wave
                        flux = degraded_flux

                        if save_intermediate_files == True:
                            degraded_res_R_to_FWHM = str(float(round(final_res_r_to_fwhm,1)))
                            file_degraded_R_to_FWHM = result_spec+'degraded_FWHM' + degraded_res_R_to_FWHM + '_' + spec_names_nopath[i] + '.fits'
                            uti.save_fits(wavelength, flux, file_degraded_R_to_FWHM)
                            print ('File saved: ', file_degraded_R_to_FWHM)
                            print('')


                        #c) DEGRADE FROM FWHM TO FWHM
                    if degrade == True and is_initial_res_fwhm == True:

                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('Running degrade resolution in lambda task...')

                        degraded_wave, degraded_flux = spman.degrade_lambda(wavelength, flux, initial_res_fwhm, final_res_fwhm)

                        #update the variables. necessary because I will use always wavelength and flux for the other functions!
                        wavelength = degraded_wave
                        flux = degraded_flux

                        if save_intermediate_files == True:
                            degraded_res_lambda = str(float(round(final_res_fwhm,1)))
                            file_degraded_lambda = result_spec+'degraded_FWHM' + degraded_res_lambda + '_' + spec_names_nopath[i] + '.fits'
                            uti.save_fits(wavelength, flux, file_degraded_lambda)
                            print ('File saved: ', file_degraded_lambda)
                            print('')



                # 3) NORMALISE SPECTRUM TO
                    if normalize_wave == True:
                        task_done2 = 1
                        task_spec2 = 1
                                    #check the limits
                        if (norm_wave < wave_limits[0] or norm_wave > wave_limits[1]):
                            print('Normalisation wavelength exceeds the range of the spectrum! Skipping')

                        else:
                            if i == 0:
                                print ('Running normalise task...')

                            step = wavelength[1]-wavelength[0]
                            epsilon_norm = step*10. #averaging on 10 steps values, rather than one value
                            norm_flux = spman.norm_spec(wavelength, flux, norm_wave, epsilon_norm, flux)
                            flux = norm_flux

                            if (save_intermediate_files == True):
                                norm_suffix = str(norm_wave)
                                file_normalized = result_spec+'norm' + norm_suffix + '_' + spec_names_nopath[i] + '.fits'
                                uti.save_fits(wavelength, flux, file_normalized)
                                print ('File saved: ', file_normalized)
                                print('')



                # 4) SIGMA BROADENING
                    if (sigma_broad == True):
                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('Running sigma broadening task...')

                        broadened_flux = spman.sigma_broad(wavelength, flux, sigma_to_add)
                        flux = broadened_flux

                        if (save_intermediate_files == True):
                            broad_suffix = str(int(round(sigma_to_add)))
                            file_broad = result_spec+'broad' + broad_suffix + spec_names_nopath[i] + '.fits'
                            uti.save_fits(wavelength, flux, file_broad)
                            print ('File saved: ', file_broad)
                            print('')



                # 5) ADD NOISE
                    if (add_noise == True):
                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('Running add noise task...')

                        noisy_flux = spman.add_noise(wavelength, flux, noise_to_add)
                        flux = noisy_flux

                        if (save_intermediate_files == True):
                            noise_suffix = str(int(round(noise_to_add)))
                            file_noise = result_spec+'SNR' + noise_suffix +'_'+ spec_names_nopath[i] + '.fits'
                            uti.save_fits(wavelength, flux, file_noise)
                            print ('File saved: ', file_noise)
                            print('')



                # 6) CONTINUUM MODELLING
                    if continuum_sub == True:
                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('Running continuum subtraction task...')

                        if cont_model_filtering == True:
                            corrected_flux, continuum_flux = spman.sub_cont(wavelength, flux, cont_math_operation)

                        if cont_model_poly == True:
                            corrected_flux, continuum_flux = spman.continuum(wavelength, flux, cont_want_to_maks, cont_mask_ranges, cont_poly_degree, cont_math_operation, False)

                        flux = corrected_flux

                        if (save_intermediate_files == True):
                            file_cont_sub = result_spec+'cont_sub_' + spec_names_nopath[i] + '.fits'
                            file_cont = result_spec+'cont_' + spec_names_nopath[i] + '.fits'
                            uti.save_fits(wavelength, flux, file_cont_sub)
                            uti.save_fits(wavelength, continuum_flux, file_cont)
                            print ('File saved: ', file_cont_sub)
                            print ('File saved: ', file_cont)
                            print('')




        #******************************************* SPEC MATH ********************************************
                    # The operations on all the spectra are not available for 'Process all'
                    if do_nothing == False or use_for_spec_an == True:
                        if i == 0:
                            sg.popup('Mean and sum of all the spectra require click on process selected')
                        continue

                # 1) subtract normalized average
                    if (subtract_normalized_avg == True):
                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('Running subtract normalised average task...')

                        subtracted_flux = spmt.sub_norm_avg(wavelength, flux, lambda_units, spectra_number, spec_names)
                        flux = subtracted_flux

                        if (save_intermediate_files == True):
                            file_subtracted_avg = result_spec+'subtracted_average' + spec_names_nopath[i] + '.fits'
                            uti.save_fits(wavelength, flux, file_subtracted_avg)
                            print ('File saved: ', file_subtracted_avg)
                            print('')


                # 2) subtract normalized single
                    if (subtract_normalized_spec == True):
                        task_done2 = 1
                        task_spec2 = 1

                        #test if file file exist
                        cond000 = (os.path.isfile(spectra_to_subtract))
                        if cond000 == False:
                            if i == 0:
                                sg.popup('The file to subtract does not exist. Skipping...')

                        if cond000 == True:
                            if i == 0:
                                print ('Running subtract normalised spectrum task...')

                            subtracted_single_flux = spmt.sub_norm_single(wavelength, flux, spectra_to_subtract, lambda_units)
                            flux = subtracted_single_flux

                            if (save_intermediate_files == True):
                                file_subtracted_single = result_spec+'subtracted_single' + spec_names_nopath[i] + '.fits'
                                uti.save_fits(wavelength, flux, file_subtracted_single)
                                print ('File saved: ', file_subtracted_single)
                                print('')


                # 3) add pedestal
                    if (add_pedestal == True):
                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('Running add pedestal task...')

                        flux = flux + pedestal_to_add

                        if (save_intermediate_files == True):
                            pedestal_suffix = str(int(round(pedestal_to_add)))
                            file_pedestal = result_spec+'pedestal' + pedestal_suffix + spec_names_nopath[i] + '.fits'
                            uti.save_fits(wavelength, flux, file_pedestal)
                            print ('File saved: ', file_pedestal)
                            print('')


                # 4) multiply by a constant
                    if (multiply == True):
                        task_done2 = 1
                        task_spec2 = 1
                        if i == 0:
                            print ('Running add pedestal task...')

                        flux = flux*multiply_factor

                        if (save_intermediate_files == True):
                            multiplied_suffix = str(int(round(multiply_factor)))
                            file_multiplied = result_spec+'multiplied' + multiplied_suffix + spec_names_nopath[i] + '.fits'
                            uti.save_fits(wavelength, flux, file_multiplied)
                            print ('File saved: ', file_multiplied)
                            print('')


                # 5) derivatives
                    if (derivatives == True):
                        task_done2 = 1
                        task_spec2 = 1
                        print ('*** First and second derivatives ***')
                        print ('WARNING: these are NOT used for spectral analysis tasks')

                        try:
                            first_derivative = np.gradient(flux, wavelength)
                            second_derivative = np.gradient(first_derivative, wavelength)

                            file_first_derivative = result_spec+'first_deriv_'+ spec_names_nopath[i] + '.fits'
                            file_second_derivative = result_spec+'second_deriv_'+ spec_names_nopath[i] + '.fits'
                            uti.save_fits(wavelength, first_derivative, file_first_derivative)
                            uti.save_fits(wavelength, second_derivative, file_second_derivative)
                            print ('Derivative spectra saved: ', file_first_derivative, file_second_derivative)
                            print('')

                        except Exception:
                            print ('Cannot compute the derivatives. Skipping...')



    #************************************** SPECTRAL ANALYSIS ********************************

            #1) BLACKBODY FITTING
                if (bb_fit == True):
                    task_done2 = 1
                    #store the spectrum in temp variables
                    wavelength_temp = wavelength
                    flux_temp = flux

                    if wave1_bb >= wave2_bb:
                        print ('Like I said, the first wavelength cannot be greater than the second!')
                        #continue

                    #check the limits
                    elif (wave1_bb < wave_limits[0] or wave2_bb > wave_limits[1]):
                        print ('Wavelength interval for blackbody fitting exceeds the range of the spectrum!')

                    else:
                        if i == 0:
                            print ('Running blackbody fitting ')

                        temperature_bb, residual_bb = span.blackbody_fit(wavelength, flux, wave1_bb, wave2_bb, t_guess, False)
                        print ('Best Black body temperature: ', temperature_bb, ' K')
                        print ('')

                        df_bb.at[i, 'T(K)']= temperature_bb
                        df_bb.to_csv(bb_file, index= False, sep=' ')

                        if i == (spectra_number-1):
                            print ('File saved: ', bb_file)
                            print('')



            # 2) CROSS-CORRELATION
                if (cross_corr == True):
                    task_done2 = 1
                    cond11 = (os.path.isfile(template_crosscorr))
                    #storing the spectrum in temp variables
                    wavelength_temp = wavelength
                    flux_temp = flux
                    if cond11 == False:
                        if i == 0:
                            sg.popup('The template file does not exist. Skipping...')

                    if cond11 == True:
                        if i == 0:
                            print ('Running cross-correlation task...')

                            #reading the template for the check
                            wave_temp_xcorr, flux_temp_xcorr, step_temp_xcorr, name_temp_xcorr = stm.read_spec(template_crosscorr, lambda_units_template_crosscorr)
                            wave_limits_template_xcorr = np.array([wave_temp_xcorr[0], wave_temp_xcorr[len(wave_temp_xcorr)-1]])

                        #check the limits
                        if (real_low_wave_corr < wave_limits[0] or real_high_wave_corr > wave_limits[1] or real_low_wave_corr < wave_limits_template_xcorr[0] or real_high_wave_corr > wave_limits_template_xcorr[1]):
                            print('Wavelength interval for cross-correlation exceeds the range of the spectrum or the template! Skipping')

                        else:
                            print('Template: ', template_crosscorr)
                            if is_vel_xcorr == True:
                                try:
                                    rv, cc, rv_at_max, max_corr_fcn, wavelength_temp, flux_temp, wavelength_template_crosscorr, flux_template_crosscorr = span.crosscorr (wavelength_temp, flux_temp, template_crosscorr, lambda_units_template_crosscorr, wave_interval_corr, smooth_value_crosscorr, vel_interval_corr, is_vel_xcorr)

                                    print ('Rv:', rv_at_max, 'km/s')

                                    df_rv.at[i, 'RV(km/s)']= round(rv_at_max,1)
                                    df_rv.to_csv(rv_file, index= False, sep=' ')

                                    if i == (spectra_number-1):
                                        print ('File saved: ', rv_file)
                                        print('')


                                    #plotting
                                    if (save_plot == True):
                                        rv_plot = str(round(rv_at_max,1))
                                        fig, (ax1, ax2) = plt.subplots(1, 2, figsize = (8.5,4.5))
                                        fig.suptitle('Cross-correlation for ' + spec_names_nopath[i] + ' with ' + template_crosscorr)
                                        ax1.plot(rv, cc)
                                        ax1.plot(rv_at_max, max_corr_fcn, 'ro', label = 'RV: ' + rv_plot + 'km/s')
                                        ax1.set_xlabel('RV (km/s)')
                                        ax1.set_ylabel('Xcorr fcn')
                                        ax1.legend(fontsize = 10)

                                        ax2.plot(wavelength_temp, flux_temp, label = 'Spectrum')
                                        ax2.plot(wavelength_template_crosscorr, flux_template_crosscorr, label = 'Template')
                                        ax2.set_xlim(real_low_wave_corr, real_high_wave_corr)
                                        ax2.set_ylim(0.4, 1.8)
                                        ax2.set_xlabel('Wavelength (nm)')
                                        ax2.set_ylabel('Norm flux')
                                        ax2.legend(fontsize = 10)

                                        plt.savefig(result_plot_dir + '/'+ 'Xcorr_' + spec_names_nopath[i] + '_' + '.png', format='png', dpi=300)
                                        plt.close()
                                except Exception as e:
                                    print ('Cannot find cross-correlation within the velocity ranges you inserted. Try again with different (smaller?) ranges')

                            if is_vel_xcorr == False:
                                try:
                                    z, cc, z_at_max, max_corr_fcn, wavelength_temp, flux_temp, wavelength_template_crosscorr, flux_template_crosscorr = span.crosscorr (wavelength_temp, flux_temp, template_crosscorr, lambda_units_template_crosscorr, wave_interval_corr, smooth_value_crosscorr, z_interval_corr, is_vel_xcorr)

                                    print ('Z:', z_at_max)

                                    #Changing che name of the column RV, now is z!
                                    df_rv.rename(columns={'RV(km/s)': 'z'}, inplace=True)
                                    #filling the values
                                    df_rv.at[i, 'z'] = round(z_at_max, 5)
                                    df_rv.to_csv(rv_file, index= False, sep=' ')

                                    if i == (spectra_number-1):
                                        print ('File saved: ', rv_file)
                                        print('')


                                    #plotting
                                    if (save_plot == True):
                                        z_plot = str(round(z_at_max,5))
                                        fig, (ax1, ax2) = plt.subplots(1, 2, figsize = (8.5,4.5))
                                        fig.suptitle('Cross-correlation for ' + spec_names_nopath[i] + ' with ' + template_crosscorr)
                                        ax1.plot(z, cc)
                                        ax1.plot(z_at_max, max_corr_fcn, 'ro', label = 'Z: ' + z_plot)
                                        ax1.set_xlabel('Z')
                                        ax1.set_ylabel('Xcorr fcn')
                                        ax1.legend(fontsize = 10)

                                        ax2.plot(wavelength_temp, flux_temp, label = 'Spectrum')
                                        ax2.plot(wavelength_template_crosscorr, flux_template_crosscorr, label = 'Template')
                                        ax2.set_xlim(real_low_wave_corr, real_high_wave_corr)
                                        ax2.set_ylim(0.4, 1.8)
                                        ax2.set_xlabel('Wavelength (nm)')
                                        ax2.set_ylabel('Norm flux')
                                        ax2.legend(fontsize = 10)

                                        plt.savefig(result_plot_dir + '/'+ 'Xcorr_' + spec_names_nopath[i] + '_' + '.png', format='png', dpi=300)
                                        plt.close()
                                except Exception as e:
                                    sg.Popup ('Cannot find cross-correlation within the z ranges you inserted. Try again with different (smaller?) ranges')




                # 3) VELOCITY DISPERSION
                if (sigma_measurement == True):
                    task_done2 = 1
                    cond22 = (os.path.isfile(template_sigma))
                    if cond22 == False:
                        if i == 0:
                            sg.popup('The template file does not exist. Skipping...')

                    if cond22 == True:
                        if i == 0:
                            print ('Running sigma measurement task. This might take a while...')
                                        #reading the template for the check
                            wave_temp_sigma, flux_temp_sigma, step_temp_sigma, name_temp_sigma = stm.read_spec(template_sigma, lambda_units_template_sigma)
                            wave_limits_template_sigma = np.array([wave_temp_sigma[0], wave_temp_sigma[len(wave_temp_sigma)-1]])
                            sigma_band_problem = 0
                            if band_sigma[0] > band_sigma[1] or cont_sigma[0] > cont_sigma[1]:
                                if i == 0:
                                    sg.popup('It seems we have a problem. Did you invert the wavelength range?')
                                    sigma_band_problem = 1

                        if sigma_band_problem == 0:
                            #check the limits, for the spectrum and the template
                            if ((band_sigma[0] < wave_limits[0] or cont_sigma[0] < wave_limits[0] or band_sigma[1]> wave_limits[1] or cont_sigma[1] > wave_limits[1] or band_sigma[0] < wave_limits_template_sigma[0] or cont_sigma[0] < wave_limits_template_sigma[0] or band_sigma[1]> wave_limits_template_sigma[1] or cont_sigma[1] > wave_limits_template_sigma[1])):
                                print('Wavelength interval for the band is out the range of the spectrum! Skipping')

                            else:
                                print('Template: ', template_sigma)
                                sigma, error, chisqr, band_wave, band_flux, band_flux_template_fitted, sigma_instrumental = span.sigma_measurement(wavelength, flux, template_sigma, lambda_units_template_sigma, resolution_spec, resolution_template, band_sigma, cont_sigma, True)
                                print ('Sigma: ', sigma, '+/-', round(error,2), '    Chi Square: ', chisqr)

                                #writing to the file
                                df_sigma.at[i, 'Sigma(km/s)']= round(sigma,1)
                                df_sigma.at[i, 'err']= round(error,1)
                                df_sigma.to_csv(sigma_file, index= False, sep=' ')

                                if i == (spectra_number-1):
                                    print ('File saved: ', sigma_file)
                                    print('')


                                #New: plotting
                                if(save_plot == True):

                                    sigma_title = str(round(sigma,1))
                                    fig, (ax1, ax2) = plt.subplots(2, figsize = (8.5,8.5), gridspec_kw={'height_ratios': [3, 1]})

                                    fig.suptitle(spec_names_nopath[i] + '  Sigma:' + sigma_title + 'km/s')
                                    ax1.plot(band_wave, band_flux, label = 'Spectrum')
                                    ax1.plot(band_wave, band_flux_template_fitted, label = 'Fitted template')
                                    ax1.set_xlabel('Wavelength (nm)')
                                    ax1.set_ylabel('Norm flux')
                                    ax1.legend(fontsize = 10)

                                    #plot residuals
                                    ax2.plot(band_wave, band_flux-band_flux_template_fitted, linewidth=0.5, label = 'Residuals')
                                    ax2.hlines(y=0, xmin=min(band_wave), xmax=max(band_wave), linestyles='--', lw=2, linewidth=2, color='r')
                                    ax2.set_xlabel('Wavelength (nm)')
                                    ax2.set_ylabel('Residuals')
                                    ax2.legend(fontsize = 10)

                                    plt.savefig(result_plot_dir + '/'+ 'sigma_vel_' + spec_names_nopath[i] + '.png', format='png', dpi=300)
                                    plt.close()



            # 4) EQUIVALENT WIDTH (EW)

                #a) If I want to measure just one index
                if (ew_measurement == True and single_index == True):
                    task_done2 = 1
                    if i == 0:
                        print ('Running equivalent width measurement task...')

                    #checking limits
                    if (np.min(index_usr) < wave_limits[0] or np.max(index_usr) > wave_limits[1]):
                        print ('The index definition wavelength exceeds the wavelength range of the spectrum. Skipping')

                    #verify the index definition is in the correct sequence
                    elif (index_usr[0] > index_usr[1] or index_usr[2] >index_usr[3] or index_usr[4] > index_usr[5]):
                        print('It seems we have a problem. Did you invert the wavelengths of the indices?')

                    else:
                        plot = False
                        verbose = True
                        with_uncertainties = True
                        normalise_spec = True

                        idx, ew, err, snr_ew, ew_mag, err_mag = ls.ew_measurement(wavelength, flux, index_usr, single_index, plot, verbose, with_uncertainties, save_plot, spec_names_nopath[i], normalise_spec, result_plot_dir)

                        print ('EW:', ew, '+/-', err)
                        print ('EW Mag', ew_mag, '+/-', err_mag)
                        print ('SNR: ', snr_ew, 'per pix')
                        print ('')

                        df_ew.at[i, 'ew(A)']= round(ew,4)
                        df_ew.at[i, 'err']= round(err,4)
                        df_ew.to_csv(ew_file, index= False, sep=' ')

                        err_mag= 0.434*abs(err/ew)
                        df_ew_mag.at[i, 'ew(Mag)']= round(ew_mag,4)
                        df_ew_mag.at[i, 'err']= round(err_mag,4)
                        df_ew_mag.to_csv(ew_file_mag, index= False, sep=' ')

                        df_snr_ew.at[i, 'SNR']= round(snr_ew,4)
                        df_snr_ew.to_csv(snr_ew_file, index= False, sep=' ')

                        if i == (spectra_number-1):
                            print ('File EW saved: ', ew_file)
                            print ('File EW in Mag saved: ', ew_file_mag)
                            print ('File SNR saved: ', snr_ew_file)
                            print('')

                #b) If I have an index list file
                if (ew_measurement == True and have_index_file == True):
                    task_done2 = 1
                    #the existence condition has been set before
                    if i == 0:
                        print ('Running equivalent width measurement task...')

                    #checking if the index file contains meaningful values
                    check_condition = 0

                    plot = False
                    verbose = True
                    with_uncertainties = True
                    normalise_spec = True

                    id_array, ew_array, err_array, snr_ew_array, ew_array_mag, err_array_mag = ls.ew_measurement(wavelength, flux, index_file, single_index, plot, verbose, with_uncertainties, save_plot, spec_names_nopath[i],normalise_spec, result_plot_dir)

                    if i == 0:
                        print ('Measuring indices:')
                        print (id_array)

                    print ('Spectrum: ', spec_names_nopath[i])
                    print ('EWs (A): ', ew_array)
                    print ('EWs (Mag): ', ew_array_mag)
                    print ('SNR: ', snr_ew_array, ' per pix')
                    print('')

                    #filling the file
                    for k in range(num_indices):
                        df_ew.at[i,ew_id[k+len(spectra_id)]]= round(ew_array[k], 4)
                        df_ew.at[i,ew_id[k+num_indices+ len(spectra_id)]] = round(err_array[k],4)
                        df_ew.to_csv(ew_file, index= False, sep=' ')

                        df_ew_mag.at[i,ew_id_mag[k+len(spectra_id)]]= round(ew_array_mag[k], 4)
                        df_ew_mag.at[i,ew_id_mag[k+num_indices+ len(spectra_id)]] = round(err_array_mag[k],4)
                        df_ew_mag.to_csv(ew_file_mag, index= False, sep=' ')

                        df_snr_ew.at[i,snr_ew_id[k+len(spectra_id)]]= round(snr_ew_array[k], 4)
                        df_snr_ew.to_csv(snr_ew_file, index= False, sep=' ')
                    if i == (spectra_number-1):
                        print ('File EW saved: ', ew_file)
                        print ('File EW in Mag saved: ', ew_file_mag)
                        print ('File SNR saved: ', snr_ew_file)
                        print('')


                #c) If I want to measure the Lick/IDS indices
                if (ew_measurement == True and lick_ew == True):
                    task_done2 = 1

                    if i == 0:
                        print ('Running equivalent width measurement task for Lick/IDS indices...')

                        ##TEST NEW LICK INDICES FOR FILE TO BE PASSED TO SSP MODELS
                        Hbeta = []
                        Hbetae = []
                        Mg2 = []
                        Mg2e = []
                        Mgb = []
                        Mgbe = []
                        Fe5270 = []
                        Fe5270e = []
                        Fe5335 = []
                        Fe5335e = []

                    # 1) reading the Lick index file just once
                        lick_idx_names, lick_indices = ls.read_idx(lick_index_file)
                        num_lick_indices = 19

                    check_condition = 0
                    lick_wavelength = wavelength
                    lick_flux = flux

                    blocking_cond = 0

                    #checking limits of the spectra
                    #wave limits of the spectrum
                    lick_wave_limits = np.array([lick_wavelength[0], lick_wavelength[len(lick_wavelength)-1]])
                    lick_wave_lower_limit = 420
                    lick_wave_upper_limit = 630
                    if ((lick_wave_limits[0] < lick_wave_lower_limit and lick_wave_limits[1]< lick_wave_lower_limit) or (lick_wave_limits[0] > lick_wave_upper_limit and lick_wave_limits[1]> lick_wave_upper_limit)):
                        print ('The window band is completely of the spectrum range')
                        blocking_cond = 1


                    if blocking_cond == 0:
                        # 2) If I want to correct for the emission or doppler correction or sigma correction
                        if lick_correct_emission == True or dop_correction_lick == True or (correct_ew_sigma == True and radio_lick_sigma_auto == True):

                            #1 running ppxf to fit the emission and retrieve the emission corrected spectra
                            additive_degree_lick = -1 #Not using additive degree to preserve the absorption lines
                            multiplicative_degree_lick = 10
                            min_wavelength = np.min(lick_wavelength)
                            max_wavelength = np.max(lick_wavelength)

                            #since ppxf is time consuming, let's limit the wavelength interval to correct the emission
                            if max_wavelength > 650:
                                max_wavelength_lick = 650
                            else:
                                max_wavelength_lick = max_wavelength
                            if min_wavelength < 400:
                                min_wavelength_lick = 400
                            else:
                                min_wavelength_lick = min_wavelength

                            #min_wavelength_lick = 480
                            #max_wavelength_lick = 550

                            sigma_guess_lick = 100
                            fit_components_lick = ('with_gas')
                            lick_ppxf_with_errors = False
                            lick_save_plot = False
                            regul_err_lick = 0.04 #force some regularization to smooth the fit
                            ppxf_pop_noise_lick = 0.0163 #use a random noise value
                            ppxf_pop_age_range_lick = np.array([0,16])
                            ppxf_pop_met_range_lick = np.array([-2,0.8])

                            if lick_correct_emission == True:
                                print ('Removing the emission lines with ppxf...')
                            if dop_correction_lick == True:
                                print('Doppler correction with ppxf...')


                            emiles_resolution = 2.5

                            #setting up the other parameters for pPXF
                            convolve_temp_lick = True #convolve the templates to galaxy resolution to a better estimation of sigma
                            have_user_mask_lick = False
                            mask_ranges_lick = None
                            custom_emiles_lick = False
                            custom_emiles_folder_lick = None
                            custom_npz_lick = False
                            custom_npz_file_lick = None
                            mask_emission_lick = False
                            custom_temp_suffix_lick = None
                            best_param_lick = False
                            best_noise_estimate_lick = False
                            frac_chi_lick = 1
                            dust_correction_stars_lick = False
                            dust_correction_gas_lick = False
                            tied_balmer_lick = False
                            spec_name_lick = None
                            with_plots_lick = False
                            ppxf_pop_error_nsim_lick = None
                            lick_lg_age = True

                            #performing ppxf
                            if lick_constant_fwhm == True: # with a fixed delta lambda resolution, no problem

                                #issue a warning in case the resolution of EMILES templates is lower than the galaxy
                                if spec_lick_res_fwhm < emiles_resolution:
                                    print('WARNING: the resolution of the templates is REALLY lower than the galaxy. Consider to first reduce the resolution of your spectrum with the Degrade resolution task')

                                kinematics_lick, info_pop_lick, info_pop_mass_lick, mass_light_lick, errors_lick, galaxy_lick, bestfit_flux_lick, bestfit_wave_lick, bestfit_flux_gas_lick, residual_lick, chi_square_lick, age_err_lower_abs_lick, age_err_upper_abs_lick, met_err_lower_lick, met_err_upper_lick, alpha_err_lower_lick, alpha_err_upper_lick, mass_age_err_lower_abs_lick, mass_age_err_upper_abs_lick, mass_met_err_lower_lick, mass_met_err_upper_lick, mass_alpha_err_lower_lick, mass_alpha_err_upper_lick, emission_corrected_flux, pop_age, light_weights_age_bin, mass_weights_age_bin, cumulative_mass, snr_pop_lick, light_weights_lick, mass_weights_lick = span.ppxf_pop(lick_wavelength, lick_flux, min_wavelength_lick, max_wavelength_lick, spec_lick_res_fwhm, z_guess_lick_emission, sigma_guess_lick, fit_components_lick, with_plots_lick, lick_ppxf_with_errors, lick_save_plot, spec_name_lick, regul_err_lick, additive_degree_lick, multiplicative_degree_lick, tied_balmer_lick, stellar_library_lick, dust_correction_stars_lick, dust_correction_gas_lick, ppxf_pop_noise_lick, ppxf_pop_age_range_lick, ppxf_pop_met_range_lick, custom_emiles_lick, custom_emiles_folder_lick, custom_npz_lick, custom_npz_file_lick, mask_emission_lick, custom_temp_suffix_lick, best_param_lick, best_noise_estimate_lick, frac_chi_lick, convolve_temp_lick, have_user_mask_lick, mask_ranges_lick, ppxf_pop_error_nsim_lick, lick_lg_age, result_plot_dir)


                            #if I don't have a constant FWHM resolution:
                            if lick_constant_fwhm == False:
                                #considering a mean fwhm along the lick band. The errors for the indices used for stellar parameters are about 5%, so it's good for now.
                                mean_ref_lick_wavelength = 508
                                spec_lick_res_fwhm = mean_ref_lick_wavelength/spec_lick_res_r*10 #converting in A

                                #issue a warning in case the resolution of EMILES templates is lower than the galaxy
                                if spec_lick_res_fwhm < emiles_resolution:
                                    print('WARNING: the resolution of the templates is REALLY lower than the galaxy. Consider to first reduce the resolution of your spectrum with the Degrade resolution task')

                                kinematics_lick, info_pop_lick, info_pop_mass_lick, mass_light_lick, errors_lick, galaxy_lick, bestfit_flux_lick, bestfit_wave_lick, bestfit_flux_gas_lick, residual_lick, chi_square_lick, age_err_lower_abs_lick, age_err_upper_abs_lick, met_err_lower_lick, met_err_upper_lick, alpha_err_lower_lick, alpha_err_upper_lick, mass_age_err_lower_abs_lick, mass_age_err_upper_abs_lick, mass_met_err_lower_lick, mass_met_err_upper_lick, mass_alpha_err_lower_lick, mass_alpha_err_upper_lick, emission_corrected_flux, pop_age, light_weights_age_bin, mass_weights_age_bin, cumulative_mass, snr_pop_lick, light_weights_lick, mass_weights_lick = span.ppxf_pop(lick_wavelength, lick_flux, min_wavelength_lick, max_wavelength_lick, spec_lick_res_fwhm, z_guess_lick_emission, sigma_guess_lick, fit_components_lick, with_plots_lick, lick_ppxf_with_errors, lick_save_plot, spec_name_lick, regul_err_lick, additive_degree_lick, multiplicative_degree_lick, tied_balmer_lick, stellar_library_lick, dust_correction_stars_lick, dust_correction_gas_lick, ppxf_pop_noise_lick, ppxf_pop_age_range_lick, ppxf_pop_met_range_lick, custom_emiles_lick, custom_emiles_folder_lick, custom_npz_lick, custom_npz_file_lick, mask_emission_lick, custom_temp_suffix_lick, best_param_lick, best_noise_estimate_lick, frac_chi_lick, convolve_temp_lick, have_user_mask_lick, mask_ranges_lick, ppxf_pop_error_nsim_lick, lick_lg_age, result_plot_dir)


                            if lick_correct_emission == True:
                                lick_wavelength = bestfit_wave_lick/10
                                lick_flux = emission_corrected_flux #using the emission corrected flux from PPXF
                                lick_step = lick_wavelength[1] - lick_wavelength[0]

                                #rebinning linear
                                lick_wavelength, lick_flux, npoint_resampled = spman.resample(lick_wavelength, lick_flux, lick_step)


                            if dop_correction_lick == True: #CAUTION HERE: IF PPXF FINDS NO GAS COMPONENTS?
                                #rebinning linear if not done before
                                if lick_correct_emission == False:
                                    #rebinning linear
                                    lick_flux = galaxy_lick #using the galaxy flux from pPXF
                                    lick_wavelength = bestfit_wave_lick/10 #using the wavelength grid from pPXF
                                    lick_step = lick_wavelength[1] - lick_wavelength[0]
                                    lick_wavelength, lick_flux, npoint_resampled = spman.resample(lick_wavelength, lick_flux, lick_step) #Rebinning linear
                                lick_doppler_vel = (kinematics_lick[0])
                                dop_vel = lick_doppler_vel[0]
                                lick_wavelength, lick_flux = spman.dopcor(lick_wavelength, lick_flux, dop_vel, True) #doppler correction. The cosmological z correction has been already performed by the span.ppxf_pop function, prior to really run pPXF. Here I correct only for the real velocity component measured by the fit.

                            if radio_lick_sigma_auto == True:
                                sigma_lick_ppxf = (kinematics_lick[0])
                                sigma_to_correct_lick = sigma_lick_ppxf[1]



                        # 3) degrading the resolution, only if smaller than the lick system
                        if lick_constant_fwhm == True and spec_lick_res_fwhm < 8.4:
                            lick_degraded_wavelength, lick_degraded_flux = spman.degrade_to_lick(lick_wavelength, lick_flux, spec_lick_res_fwhm, lick_constant_fwhm)
                        elif lick_constant_fwhm == False and spec_lick_res_r > 600:
                            lick_degraded_wavelength, lick_degraded_flux = spman.degrade_to_lick(lick_wavelength, lick_flux, spec_lick_res_r, lick_constant_fwhm)
                        else:
                            print('WARNING: The resolution of the spectrum is smaller than the one needed for the Lick/IDS system. I will still calculate the Lick/IDS indices but the results might be inaccurate.')
                            lick_degraded_wavelength = lick_wavelength
                            lick_degraded_flux = lick_flux

                        # 4) Measuring the EW and doing plot
                        lick_single_index = False
                        lick_ew_plot = False
                        lick_ew_verbose = True
                        lick_ew_uncertainties = True
                        lick_ew_normalise_spec = True

                        id_lick_array, ew_lick_array, err_lick_array, snr_lick_ew_array, ew_lick_array_mag, err_lick_array_mag = ls.ew_measurement(lick_degraded_wavelength, lick_degraded_flux, lick_index_file, lick_single_index, lick_ew_plot, lick_ew_verbose, lick_ew_uncertainties, save_plot, spec_names_nopath[i], lick_ew_normalise_spec, result_plot_dir)

                        if i == 0:
                            print ('Measuring Lick indices:')
                            print (id_lick_array)

                        print ('')
                        print ('Spectrum: ', spec_names_nopath[i])
                        print ('Raw EWs (A): ')
                        print (np.round(ew_lick_array, decimals = 3))
                        print ('Raw EWs (Mag): ')
                        print (np.round(ew_lick_array_mag, decimals = 3))
                        print ('SNR: ')
                        print (np.round(snr_lick_ew_array), ' per pix')
                        print('')

                        # 5) Correcting the EW for sigma
                        # a) Correcting the EWs for a single value
                        if correct_ew_sigma == True and radio_lick_sigma_single == True:
                            corrected_lick_ew_array, corrected_lick_err_array, corrected_lick_ew_mag_array, corrected_lick_err_mag_array = ls.corr_ew_lick(ew_lick_array, err_lick_array, ew_lick_array_mag, sigma_lick_coeff_file, sigma_single_lick)

                            #updating the values:
                            ew_lick_array = corrected_lick_ew_array
                            err_lick_array = corrected_lick_err_array
                            ew_lick_array_mag = corrected_lick_ew_mag_array
                            err_lick_array_mag = corrected_lick_err_mag_array

                            print ('Corrected EWs for sigma:')
                            print (np.round(corrected_lick_ew_array, decimals = 3))
                            print ('Corrected uncertainties for sigma:')
                            print (np.round(corrected_lick_err_array, decimals = 3))

                        # b) Correcting the EWs for a list
                        if correct_ew_sigma == True and radio_lick_sigma_list == True:

                            # reading the sigma value file
                            if i == 0:
                                sigma_values = np.loadtxt(sigma_lick_file, usecols = [1])

                                #check if the length is the same of the spectra_number to correct
                                if len(sigma_values) != spectra_number:
                                    sg.popup ('The sigma list file for Lick correction has a length different from the number of spectra you want to correct!')

                            if len(sigma_values) == spectra_number:
                                corrected_lick_ew_array, corrected_lick_err_array, corrected_lick_ew_mag_array, corrected_lick_err_mag_array = ls.corr_ew_lick(ew_lick_array, err_lick_array, ew_lick_array_mag, sigma_lick_coeff_file, sigma_values[i])

                                #updating the values:
                                ew_lick_array = corrected_lick_ew_array
                                err_lick_array = corrected_lick_err_array
                                ew_lick_array_mag = corrected_lick_ew_mag_array
                                err_lick_array_mag = corrected_lick_err_mag_array

                        # c) Automatic correcting the EWs
                        if correct_ew_sigma == True and radio_lick_sigma_auto == True:
                            corrected_lick_ew_array, corrected_lick_err_array, corrected_lick_ew_mag_array, corrected_lick_err_mag_array = ls.corr_ew_lick(ew_lick_array, err_lick_array, ew_lick_array_mag, sigma_lick_coeff_file, sigma_to_correct_lick)

                            print ('Corrected EWs for sigma (A):')
                            print (np.round(corrected_lick_ew_array, decimals = 3))
                            print ('Corrected uncertainties for sigma')
                            print (np.round(corrected_lick_err_array, decimals = 3))

                            #uodating the values
                            ew_lick_array = corrected_lick_ew_array
                            err_lick_array = corrected_lick_err_array
                            ew_lick_array_mag = corrected_lick_ew_mag_array
                            err_lick_array_mag = corrected_lick_err_mag_array

                        #d) If no sigma correction
                        if correct_ew_sigma == False:
                            err_lick_array_mag = 0.434*abs(err_lick_array/ew_lick_array)
                            err_lick_array_mag = np.nan_to_num(err_lick_array_mag, nan=0)

                        #filling the file
                        for k in range(num_lick_indices):
                            df_ew_lick.at[i,ew_lick_id[k+len(spectra_lick_id)]]= round(ew_lick_array[k], 4)
                            df_ew_lick.at[i,ew_lick_id[k+num_lick_indices+ len(spectra_lick_id)]] = round(err_lick_array[k],4)
                            df_ew_lick.to_csv(ew_lick_file, index= False, sep=' ')
                            df_ew_lick_mag.at[i,ew_lick_id_mag[k+len(spectra_lick_id)]]= round(ew_lick_array_mag[k], 4)
                            df_ew_lick_mag.at[i,ew_lick_id_mag[k+num_lick_indices+ len(spectra_lick_id)]] = round(err_lick_array_mag[k],4)
                            df_ew_lick_mag.to_csv(ew_lick_file_mag, index= False, sep=' ')
                            df_snr_lick_ew.at[i,snr_lick_ew_id[k+len(spectra_lick_id)]]= round(snr_lick_ew_array[k], 4)
                            df_snr_lick_ew.to_csv(snr_lick_ew_file, index= False, sep=' ')

                        #creating new indices to save in a file for SSP interpolation
                        Hbeta.append(ew_lick_array[0])
                        Hbetae.append(err_lick_array[0])
                        Mg2.append(ew_lick_array_mag[1])
                        Mg2e.append(err_lick_array_mag[1])
                        Mgb.append(ew_lick_array[2])
                        Mgbe.append(err_lick_array[2])
                        Fe5270.append(ew_lick_array[3])
                        Fe5270e.append(err_lick_array[3])
                        Fe5335.append(ew_lick_array[4])
                        Fe5335e.append(err_lick_array[4])

                        # interpolation with models
                        if stellar_parameters_lick == True:

                            Hbeta_sp = ew_lick_array[0]
                            Hbetae_sp = err_lick_array[0]
                            Mg2_sp = ew_lick_array_mag[1]
                            Mg2e_sp= err_lick_array_mag[1]
                            Mgb_sp= ew_lick_array[2]
                            Mgbe_sp= err_lick_array[2]
                            Fe5270_sp=ew_lick_array[3]
                            Fe5270e_sp=err_lick_array[3]
                            Fe5335_sp=ew_lick_array[4]
                            Fe5335e_sp=err_lick_array[4]

                            Fem_sp = (Fe5270_sp+Fe5335_sp)/2
                            Feme_sp = np.sqrt((0.5*Fe5270e_sp)**2+(0.5*Fe5335e_sp)**2)
                            MgFe_sp = (np.sqrt(Mgb_sp*(0.72*Fe5270_sp+0.28*Fe5335_sp)))
                            MgFe_sp = np.nan_to_num(MgFe_sp, nan=0)
                            MgFee_sp = np.sqrt((((Fe5270_sp*18/25+Fe5335_sp*7/25)/(2*np.sqrt(Mgb_sp*(Fe5270_sp*18/25+Fe5335_sp*7/25))))*Mgbe_sp)**2+((Mgb_sp*18/25/(2*np.sqrt(Mgb_sp*(Fe5270_sp*18/25+Fe5335_sp*7/25))))*Fe5270e_sp)**2+((Mgb_sp*7/25/(2*np.sqrt(Mgb_sp*(Fe5270_sp*18/25+Fe5335_sp*7/25))))*Fe5335e_sp)**2)
                            MgFee_sp = np.nan_to_num(MgFee_sp, nan=0)

                            #Storing the indices in arrays to be passed to the lick_pop function and lick_grids
                            ssp_lick_indices_list = np.column_stack((Hbeta_sp, MgFe_sp, Fem_sp, Mgb_sp))
                            ssp_lick_indices = ssp_lick_indices_list.reshape(-1)
                            ssp_lick_indices_err_list = np.column_stack((Hbetae_sp, MgFee_sp, Feme_sp, Mgbe_sp))
                            ssp_lick_indices_err = ssp_lick_indices_err_list.reshape(-1)

                            #computing the age, metallicity and alpha, with uncertainties
                            age, met, alpha, err_age, err_met, err_alpha = span.lick_pop(ssp_lick_indices, ssp_lick_indices_err, ssp_model, interp_model)

                            print ('')
                            print ('Age (Gyr):', round(age,2), '+/-', round(err_age, 2))
                            print ('[M/H] (dex):', round(met, 2), '+/-', round(err_met,2))
                            print ('[Alpha/Fe]:', round(alpha, 2), '+/-', round(err_alpha,2))
                            print('')

                            #printing to file
                            df_ssp_param.at[i, 'age(Gyr)']= round(age,3)
                            df_ssp_param.at[i, 'err_age']= round(err_age,3)
                            df_ssp_param.at[i, 'met']= round(met,4)
                            df_ssp_param.at[i, 'err_met']= round(err_met,4)
                            df_ssp_param.at[i, 'alpha']= round(alpha,4)
                            df_ssp_param.at[i, 'err_alpha']= round(err_alpha,4)

                            #putting nans where needed
                            df_ssp_param.to_csv(ssp_param_file, na_rep='NaN', index= False, sep=' ')

                            #storing the indices values to be plotted
                            if i == 0:
                                Hbeta_plot = []
                                MgFe_plot = []
                                Fem_plot = []
                                Mgb_plot = []
                                Hbetae_plot = []
                                MgFee_plot = []
                                Feme_plot = []
                                Mgbe_plot = []
                                age_plot = []

                            Hbeta_plot.append(Hbeta_sp)
                            MgFe_plot.append(MgFe_sp)
                            Fem_plot.append(Fem_sp)
                            Mgb_plot.append(Mgb_sp)
                            Hbetae_plot.append(Hbetae_sp)
                            MgFee_plot.append(MgFee_sp)
                            Feme_plot.append(Feme_sp)
                            Mgbe_plot.append(Mgbe_sp)
                            age_plot.append(age)

                            if i == (spectra_number-1):


                                Hbeta_plot = np.array(Hbeta_plot)
                                MgFe_plot = np.array(MgFe_plot)
                                Fem_plot = np.array(Fem_plot)
                                Mgb_plot = np.array(Mgb_plot)
                                Hbetae_plot = np.array(Hbetae_plot)
                                MgFee_plot = np.array(MgFee_plot)
                                Feme_plot = np.array(Feme_plot)
                                Mgbe_plot = np.array(Mgbe_plot)

                                ssp_lick_indices_plot = np.column_stack((Hbeta_plot, MgFe_plot, Fem_plot, Mgb_plot))
                                ssp_lick_indices_err_plot = np.column_stack((Hbetae_plot, MgFee_plot, Feme_plot, Mgbe_plot))


                                #doing the plot
                                if save_plot == True:
                                    span.lick_grids(ssp_model, ssp_lick_indices_plot, ssp_lick_indices_err_plot, np.mean(age_plot), False, True, spectra_list_name, result_plot_dir)
                                else:
                                    span.lick_grids(ssp_model, ssp_lick_indices_plot, ssp_lick_indices_err_plot, np.mean(age_plot), True, False, 'none', result_plot_dir)
                                #I build the grids




                        if i == (spectra_number-1):
                            print ('File EW saved: ', ew_lick_file)
                            print ('File EW in Mag saved: ', ew_lick_file_mag)
                            print ('File SNR saved: ', snr_lick_ew_file)
                            if stellar_parameters_lick == True:
                                print ('File with the stellar parameters saved: ', ssp_param_file)

                    else:
                        print('Nothing to show')



            #5) LINE(S) FITTING

                #a) CaT fitting
                if (line_fitting == True and cat_band_fit == True ):
                    task_done2 = 1

                    #checking limits
                    if ( min(wave_interval_fit) < wave_limits[0] or max(wave_interval_fit) > wave_limits[1]):
                        print ('The window band is out of the spectrum range')

                    else:
                        #Performing the fitting of the CaT lines
                        cat_wave, cat_flux_norm, cat_fit, momentum = span.cat_fitting(wavelength,flux)

                        #finding the relative minima that will be the central CaT line wavelengths:
                        min_values_arg = argrelextrema(cat_fit, np.less)
                        min_values_arg_extracted = min_values_arg[0]

                        #if the fit fails a line:
                        try:
                            min_wave1 = round(cat_wave[min_values_arg_extracted[0]],1)
                        except IndexError:
                            min_wave1 = 0.
                        try:
                            min_wave2 = round(cat_wave[min_values_arg_extracted[1]],1)
                        except IndexError:
                            min_wave2 = 0.
                        try:
                            min_wave3 = round(cat_wave[min_values_arg_extracted[2]],1)
                        except IndexError:
                            min_wave3 = 0.
                        try:
                            min_flux1 = cat_fit[min_values_arg_extracted[0]]
                        except IndexError:
                            min_flux1 = 0.
                        try:
                            min_flux2 = cat_fit[min_values_arg_extracted[1]]
                        except IndexError:
                            min_flux2 = 0.
                        try:
                            min_flux3 = cat_fit[min_values_arg_extracted[2]]
                        except IndexError:
                            min_flux3 = 0.

                        #Differences in observed and calculated peaks
                        residual_wave1 = min_wave1-real_cat1
                        residual_wave2 = min_wave2-real_cat2
                        residual_wave3 = min_wave3-real_cat3

                        #converting the wavelength residuals in velocities
                        c = 299792.458
                        delta_rv1 = (residual_wave1/real_cat1)*c
                        delta_rv2 = (residual_wave2/real_cat2)*c
                        delta_rv3 = (residual_wave3/real_cat3)*c

                        #Assigning the sigma of the lines (in pixels)
                        sigma_cat1 = momentum[3]
                        sigma_cat2 = momentum[9]
                        sigma_cat3 = momentum[15]

                        #converting to velocities
                        sigma_cat1_vel = (sigma_cat1/min_wave1)*c
                        sigma_cat2_vel = (sigma_cat2/min_wave1)*c
                        sigma_cat3_vel = (sigma_cat3/min_wave1)*c

                        #residual spectrum
                        residual_flux = cat_flux_norm - cat_fit

                        #printing data from the fit
                        print ('Central wavelength of the fitted CaT lines (nm)')
                        print (min_wave1,min_wave2,min_wave3)
                        print ('Real central wavelength of the CaT lines (nm)')
                        print (real_cat1,real_cat2,real_cat3)
                        print ('Residuals (nm):')
                        print (residual_wave1,residual_wave2,residual_wave3)
                        print ('Residuals in km/s')
                        print (delta_rv1,delta_rv2,delta_rv3)
                        print ('Mean delta RV:')
                        print ((delta_rv1+delta_rv2+delta_rv3)/3)
                        print ('Sigma (nm)')
                        print (sigma_cat1, sigma_cat2, sigma_cat3)
                        print ('Sigma (km/s)')
                        print (sigma_cat1_vel,sigma_cat2_vel,sigma_cat3_vel)
                        print ('')


                        #EW measurement of the fitted lines
                        cat_single_index = True
                        cat_plot = False
                        cat_verbose = False
                        cat_with_uncertainties = True
                        cat_save_plot = False
                        cat_normalise_spec = False

                        #ca1
                        id_array, ew_array_ca1, err_array, snr_ew_array,ew_array_mag, err_array_mag = ls.ew_measurement(cat_wave, cat_fit, index_ca1, cat_single_index, cat_plot, cat_verbose, cat_with_uncertainties, cat_save_plot, spec_names_nopath[i],cat_normalise_spec, result_plot_dir)

                        #ca2
                        id_array, ew_array_ca2, err_array, snr_ew_array,ew_array_mag, err_array_mag = ls.ew_measurement(cat_wave, cat_fit, index_ca2, cat_single_index, cat_plot, cat_verbose, cat_with_uncertainties, cat_save_plot, spec_names_nopath[i],cat_normalise_spec, result_plot_dir)

                        #ca3
                        id_array, ew_array_ca3, err_array, snr_ew_array,ew_array_mag, err_array_mag = ls.ew_measurement(cat_wave, cat_fit, index_ca3, cat_single_index, cat_plot, cat_verbose, cat_with_uncertainties, cat_save_plot, spec_names_nopath[i],cat_normalise_spec, result_plot_dir)

                        #some infos
                        print ('Equivalent width from the fit (Ang):')
                        print ('Ca1  Ca2  Ca3')
                        print (round(ew_array_ca1,2), round(ew_array_ca2,2), round(ew_array_ca3,2))
                        print ('')

                        #writing values to the file
                        df_fit.at[i, 'ca1_wave']= round(min_wave1,2)
                        df_fit.at[i, 'ca2_wave']= round(min_wave2,2)
                        df_fit.at[i, 'ca3_wave']= round(min_wave3,2)
                        df_fit.at[i, 'dw_ca1']= round(residual_wave1,2)
                        df_fit.at[i, 'dw_ca2']= round(residual_wave2,2)
                        df_fit.at[i, 'dw_ca3']= round(residual_wave3,2)
                        df_fit.at[i, 'ew_ca1']= round(ew_array_ca1,2)
                        df_fit.at[i, 'ew_ca2']= round(ew_array_ca2,2)
                        df_fit.at[i, 'ew_ca3']= round(ew_array_ca3,2)

                        df_fit.to_csv(fit_file, index= False, sep=' ')

                        if i == (spectra_number-1):
                            print ('File saved: ', fit_file)
                            print('')

                        #Saving the fit plot
                        if (save_plot == True):

                            fig, (ax1, ax2) = plt.subplots(2, figsize = (8.5,8.5), gridspec_kw={'height_ratios': [3, 1]})

                            fig.suptitle('CaT lines fitting')
                            ax1.plot(cat_wave, cat_flux_norm, label = 'Spectrum')
                            ax1.plot(cat_wave, cat_fit, label = 'Fit line spec')
                            ax1.set_xlabel('Wavelength (nm)')
                            ax1.set_ylabel('Norm flux')
                            ax1.legend(fontsize = 10)

                            #plot residuals
                            ax2.plot(cat_wave, residual_flux, linewidth=0.5, label = 'Residuals')
                            ax2.hlines(y=0, xmin=min(cat_wave), xmax=max(cat_wave), linestyles='--', lw=2, linewidth=2, color='r')
                            ax2.set_xlabel('Wavelength (nm)')
                            ax2.set_ylabel('Residuals')
                            ax2.legend(fontsize = 10)

                            plt.savefig(result_plot_dir + '/'+ 'cat_fitting_' + spec_names_nopath[i] + '.png', format='png', dpi=300)
                            plt.close()


                # b) line fitting user line
                if (line_fitting == True and cat_band_fit == False):
                    task_done2 = 1


                    print ('*** Line fitting with combination of gaussian and a line for the slope ***')

                    #check on the limits of the parameters
                    wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

                    #checking limits
                    if (min(wave_interval_fit) < wave_limits[0] or max(wave_interval_fit) > wave_limits[1]):
                        print ('The window band is out of the spectrum range')

                    else:
                        #Performing the fitting of the line
                        line_wave, line_flux_norm, line_fit, momentum = span.line_fitting (wavelength, flux, wave_interval_fit, guess_param)

                        #finding the minimum that will be the central CaT line wavelengths:
                        if emission_line == False:
                            min_value_wave_arg = np.argmin(line_fit)
                            min_wave = line_wave[min_value_wave_arg]

                        #if I have emission I calculate the maximum!
                        if emission_line == True:
                            min_value_wave_arg = np.argmax(line_fit)
                            min_wave = line_wave[min_value_wave_arg]

                        #Assigning the sigma of the lines (in pixels)
                        sigma_line = abs(momentum[3])

                        #converting to velocities
                        c = 299792.458
                        sigma_line_vel = (sigma_line/min_wave)*c

                        #residual spectrum
                        residual_flux = line_flux_norm - line_fit

                        #printing data from the fit
                        print ('Central wavelength of the fitted line (nm)')
                        print (min_wave)
                        print ('Sigma (nm)')
                        print (sigma_line)
                        print ('Sigma (km/s)')
                        print (sigma_line_vel)

                        #writing values to the file
                        df_fit.at[i, 'line_wave']= round(min_wave,2)
                        df_fit.to_csv(fit_file, index= False, sep=' ')

                        if i == (spectra_number-1):
                            print ('File saved: ', fit_file)
                            print('')


                        if  (save_plot == True):
                            #plotting the fit result
                            fig, (ax1, ax2) = plt.subplots(2, figsize = (8.5,8.5), gridspec_kw={'height_ratios': [3, 1]})

                            fig.suptitle('line fitting')
                            ax1.plot(line_wave, line_flux_norm, label = 'Spectrum')
                            ax1.plot(line_wave, line_fit, label = 'Fit line spec')
                            ax1.set_xlabel('Wavelength (nm)')
                            ax1.set_ylabel('Norm flux')
                            ax1.legend(fontsize = 10)

                            #plot residuals
                            ax2.plot(line_wave, residual_flux, linewidth=0.5, label = 'Residuals')
                            ax2.hlines(y=0, xmin=min(line_wave), xmax=max(line_wave), linestyles='--', lw=2, linewidth=2, color='r')
                            ax2.set_xlabel('Wavelength (nm)')
                            ax2.set_ylabel('Residuals')
                            ax2.legend(fontsize = 10)

                            plt.savefig(result_plot_dir + '/'+ 'line_fitting_' + spec_names_nopath[i] + '.png', format='png', dpi=300)
                            plt.close()



            # 6) KINEMATICS WITH PPXF
                if (perform_kinematics == True):
                    task_done2 = 1

                    print ('*** Kinematics with the ppxf algorithm ***')

                    #wave limits of the spectrum
                    wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

                    #check on the limits of the input parameters
                    if wave1_kin < wave2_kin:
                        wave_limits_kin = (wave1_kin,wave2_kin)
                    elif wave1_kin > wave2_kin:
                        #I suppose the wavelength range is inverted:
                        wave1_kin_tmp = wave1_kin
                        wave1_kin = wave2_kin
                        wave2_kin = wave1_kin_tmp
                        wave_limits_kin = (wave1_kin, wave2_kin)

                    #checking limits
                    if ( wave1_kin < wave_limits[0] or wave2_kin > wave_limits[1]):
                        print ('The window band is out of the spectrum range')

                    else:
                        try:
                            if constant_resolution_lambda == True:
                                #fitting with ppxf
                                kinematics, error_kinematics, bestfit_flux, bestfit_wavelength, kin_component, snr_kin, error_kinematics_mc = span.ppxf_kinematics(wavelength, flux, wave1_kin, wave2_kin, resolution_kin, constant_resolution_lambda, resolution_kin_r, redshift_guess_kin, sigma_guess_kin, stellar_library_kin, additive_degree_kin, kin_moments, ppxf_kin_noise, gas_kin, no_gas_kin, kin_best_noise, with_errors_kin, ppxf_kin_custom_lib, ppxf_kin_lib_folder, ppxf_kin_custom_temp_suffix, ppxf_kin_dust_gas, ppxf_kin_dust_stars, ppxf_kin_tie_balmer, ppxf_kin_two_stellar_components, ppxf_kin_age_model1, ppxf_kin_met_model1, ppxf_kin_age_model2, ppxf_kin_met_model2, ppxf_kin_vel_model1, ppxf_kin_sigma_model1, ppxf_kin_vel_model2, ppxf_kin_sigma_model2, ppxf_kin_mask_emission, ppxf_kin_mc_sim)

                            if constant_resolution_lambda == False:
                                #fitting with ppxf
                                kinematics, error_kinematics, bestfit_flux, bestfit_wavelength, kin_component, snr_kin, error_kinematics_mc = span.ppxf_kinematics(wavelength, flux, wave1_kin, wave2_kin, resolution_kin, constant_resolution_lambda, resolution_kin_r, redshift_guess_kin, sigma_guess_kin, stellar_library_kin, additive_degree_kin, kin_moments, ppxf_kin_noise, gas_kin, no_gas_kin, kin_best_noise, with_errors_kin, ppxf_kin_custom_lib, ppxf_kin_lib_folder, ppxf_kin_custom_temp_suffix, ppxf_kin_dust_gas, ppxf_kin_dust_stars, ppxf_kin_tie_balmer, ppxf_kin_two_stellar_components, ppxf_kin_age_model1, ppxf_kin_met_model1, ppxf_kin_age_model2, ppxf_kin_met_model2, ppxf_kin_vel_model1, ppxf_kin_sigma_model1, ppxf_kin_vel_model2, ppxf_kin_sigma_model2, ppxf_kin_mask_emission, ppxf_kin_mc_sim)

                            kin_component = np.max(kin_component)

                            #Saving the single stellar component fit results
                            if kin_component == 0 and ppxf_kin_two_stellar_components == False:
                                vel = round(kinematics[0])
                                sigma = round(kinematics[1])
                                h3 = round(kinematics[2],3)
                                h4 = round(kinematics[3],3)
                                h5 = round(kinematics[4],3)
                                h6 = round(kinematics[5],3)
                                err_vel = round(error_kinematics[0])
                                err_sigma = round(error_kinematics[1])
                                err_h3 = round(error_kinematics[2],3)
                                err_h4 = round(error_kinematics[3],3)
                                err_h5 = round(error_kinematics[4],3)
                                err_h6 = round(error_kinematics[5],3)
                                #writing to file
                                df_kin.at[i, 'RV(km/s)']= vel
                                df_kin.at[i, 'Sigma(km/s)']= sigma
                                df_kin.at[i, 'H3']= h3
                                df_kin.at[i, 'H4']= h4
                                df_kin.at[i, 'H5']= h5
                                df_kin.at[i, 'H6']= h6
                                df_kin.at[i, 'errRV']= err_vel
                                df_kin.at[i, 'errSigma']= err_sigma
                                df_kin.at[i, 'errH3']= err_h3
                                df_kin.at[i, 'errH4']= err_h4
                                df_kin.at[i, 'errH5']= err_h5
                                df_kin.at[i, 'errH6']= err_h6
                                df_kin.at[i, 'S/N']= round(snr_kin)


                                df_kin.to_csv(kin_file, index= False, sep=' ')


                                if with_errors_kin == True:
                                    err_rv_kin_mc, err_sigma_kin_mc, err_h3_kin_mc, err_h4_kin_mc, err_h5_kin_mc, err_h6_kin_mc = np.round(error_kinematics_mc[0],3)

                                    df_kin_mc.at[i, 'RV(km/s)']= vel
                                    df_kin_mc.at[i, 'Sigma(km/s)']= sigma
                                    df_kin_mc.at[i, 'H3']= h3
                                    df_kin_mc.at[i, 'H4']= h4
                                    df_kin_mc.at[i, 'H5']= h5
                                    df_kin_mc.at[i, 'H6']= h6
                                    df_kin_mc.at[i, 'errRV']= err_rv_kin_mc
                                    df_kin_mc.at[i, 'errSigma']= err_sigma_kin_mc
                                    df_kin_mc.at[i, 'errH3']= err_h3_kin_mc
                                    df_kin_mc.at[i, 'errH4']= err_h4_kin_mc
                                    df_kin_mc.at[i, 'errH5']= err_h5_kin_mc
                                    df_kin_mc.at[i, 'errH6']= err_h6_kin_mc
                                    df_kin_mc.at[i, 'S/N']= round(snr_kin)

                                    df_kin_mc.to_csv(kin_file_mc, index= False, sep=' ')

                            #saving the two component stellar fit results
                            elif kin_component == 0 and ppxf_kin_two_stellar_components == True:

                                # adding the columns to the file
                                if i == 0:
                                    new_component = ['RV_2(km/s)', 'Sigma_2(km/s)', 'H3_2', 'H4_2', 'H5_2', 'H6_2', 'errRV_2','errSigma_2', 'errH3_2','errH4_2', 'errH5_2', 'errH6_2']
                                    df_kin[new_component] = 0. #filling with zeros

                                vel1 = round(kinematics[0][0])
                                sigma1 = round(kinematics[0][1])
                                h31 = round(kinematics[0][2],3)
                                h41 = round(kinematics[0][3],3)
                                h51 = round(kinematics[0][4],3)
                                h61 = round(kinematics[0][5],3)
                                err_vel1 = round(error_kinematics[0][0])
                                err_sigma1 = round(error_kinematics[0][1])
                                err_h31 = round(error_kinematics[0][2],3)
                                err_h41 = round(error_kinematics[0][3],3)
                                err_h51 = round(error_kinematics[0][4],3)
                                err_h61 = round(error_kinematics[0][5],3)

                                vel2 = round(kinematics[1][0])
                                sigma2 = round(kinematics[1][1])
                                h32 = round(kinematics[1][2],3)
                                h42 = round(kinematics[1][3],3)
                                h52 = round(kinematics[1][4],3)
                                h62 = round(kinematics[1][5],3)
                                err_vel2 = round(error_kinematics[1][0])
                                err_sigma2 = round(error_kinematics[1][1])
                                err_h32 = round(error_kinematics[1][2],3)
                                err_h42 = round(error_kinematics[1][3],3)
                                err_h52 = round(error_kinematics[1][4],3)
                                err_h62 = round(error_kinematics[1][5],3)

                                #filling the dataframe columns for component 1
                                df_kin.at[i, 'RV(km/s)']= vel1
                                df_kin.at[i, 'Sigma(km/s)']= sigma1
                                df_kin.at[i, 'H3']= h31
                                df_kin.at[i, 'H4']= h41
                                df_kin.at[i, 'H5']= h51
                                df_kin.at[i, 'H6']= h61
                                df_kin.at[i, 'errRV']= err_vel1
                                df_kin.at[i, 'errSigma']= err_sigma1
                                df_kin.at[i, 'errH3']= err_h31
                                df_kin.at[i, 'errH4']= err_h41
                                df_kin.at[i, 'errH5']= err_h51
                                df_kin.at[i, 'errH6']= err_h61
                                df_kin.at[i, 'S/N']= round(snr_kin)

                                #filling the dataframe columns for component 2
                                df_kin.at[i, 'RV_2(km/s)']= vel2
                                df_kin.at[i, 'Sigma_2(km/s)']= sigma2
                                df_kin.at[i, 'H3_2']= h32
                                df_kin.at[i, 'H4_2']= h42
                                df_kin.at[i, 'H5_2']= h52
                                df_kin.at[i, 'H6_2']= h62
                                df_kin.at[i, 'errRV_2']= err_vel2
                                df_kin.at[i, 'errSigma_2']= err_sigma2
                                df_kin.at[i, 'errH3_2']= err_h32
                                df_kin.at[i, 'errH4_2']= err_h42
                                df_kin.at[i, 'errH5_2']= err_h52
                                df_kin.at[i, 'errH6_2']= err_h62

                                #writing to file
                                df_kin.to_csv(kin_file, index= False, sep=' ')

                                # considering also the errorrw with MonteCarlo simulations
                                if with_errors_kin == True:

                                    #updating the dataframe with the second stellar component
                                    if i == 0:
                                        new_component_mc = ['RV_2(km/s)', 'Sigma_2(km/s)', 'H3_2', 'H4_2', 'H5_2', 'H6_2', 'errRV_2','errSigma_2', 'errH3_2','errH4_2', 'errH5_2', 'errH6_2']
                                        df_kin_mc[new_component_mc] = 0. #filling with zeros

                                    # extracting the MonteCarlo errors from the error array
                                    err_rv_kin_mc1, err_sigma_kin_mc1, err_h3_kin_mc1, err_h4_kin_mc1, err_h5_kin_mc1, err_h6_kin_mc1, err_rv_kin_mc2, err_sigma_kin_mc2, err_h3_kin_mc2, err_h4_kin_mc2, err_h5_kin_mc2, err_h6_kin_mc2  = np.round(error_kinematics_mc[0],3)

                                    # assigning to the dataframe the first component
                                    df_kin_mc.at[i, 'RV(km/s)']= vel1
                                    df_kin_mc.at[i, 'Sigma(km/s)']= sigma1
                                    df_kin_mc.at[i, 'H3']= h31
                                    df_kin_mc.at[i, 'H4']= h41
                                    df_kin_mc.at[i, 'H5']= h51
                                    df_kin_mc.at[i, 'H6']= h61
                                    df_kin_mc.at[i, 'errRV']= err_rv_kin_mc1
                                    df_kin_mc.at[i, 'errSigma']= err_sigma_kin_mc1
                                    df_kin_mc.at[i, 'errH3']= err_h3_kin_mc1
                                    df_kin_mc.at[i, 'errH4']= err_h4_kin_mc1
                                    df_kin_mc.at[i, 'errH5']= err_h5_kin_mc1
                                    df_kin_mc.at[i, 'errH6']= err_h6_kin_mc1
                                    df_kin_mc.at[i, 'S/N']= round(snr_kin)

                                    #assigning to the dataframe the second component
                                    df_kin_mc.at[i, 'RV_2(km/s)']= vel2
                                    df_kin_mc.at[i, 'Sigma_2(km/s)']= sigma2
                                    df_kin_mc.at[i, 'H3_2']= h32
                                    df_kin_mc.at[i, 'H4_2']= h42
                                    df_kin_mc.at[i, 'H5_2']= h52
                                    df_kin_mc.at[i, 'H6_2']= h62
                                    df_kin_mc.at[i, 'errRV_2']= err_rv_kin_mc2
                                    df_kin_mc.at[i, 'errSigma_2']= err_sigma_kin_mc2
                                    df_kin_mc.at[i, 'errH3_2']= err_h3_kin_mc2
                                    df_kin_mc.at[i, 'errH4_2']= err_h4_kin_mc2
                                    df_kin_mc.at[i, 'errH5_2']= err_h5_kin_mc2
                                    df_kin_mc.at[i, 'errH6_2']= err_h6_kin_mc2

                                    #writing the dataframe to file
                                    df_kin_mc.to_csv(kin_file_mc, index= False, sep=' ')


                            #Saving the stellar and gas fit results
                            else:
                                vel = round(kinematics[0][0])
                                sigma = round(kinematics[0][1])
                                h3 = round(kinematics[0][2],3)
                                h4 = round(kinematics[0][3],3)
                                h5 = round(kinematics[0][4],3)
                                h6 = round(kinematics[0][5],3)
                                err_vel = round(error_kinematics[0][0])
                                err_sigma = round(error_kinematics[0][1])
                                err_h3 = round(error_kinematics[0][2],3)
                                err_h4 = round(error_kinematics[0][3],3)
                                err_h5 = round(error_kinematics[0][4],3)
                                err_h6 = round(error_kinematics[0][5],3)

                                df_kin.at[i, 'RV(km/s)']= vel
                                df_kin.at[i, 'Sigma(km/s)']= sigma
                                df_kin.at[i, 'H3']= h3
                                df_kin.at[i, 'H4']= h4
                                df_kin.at[i, 'H5']= h5
                                df_kin.at[i, 'H6']= h6
                                df_kin.at[i, 'errRV']= err_vel
                                df_kin.at[i, 'errSigma']= err_sigma
                                df_kin.at[i, 'errH3']= err_h3
                                df_kin.at[i, 'errH4']= err_h4
                                df_kin.at[i, 'errH5']= err_h5
                                df_kin.at[i, 'errH6']= err_h6
                                df_kin.at[i, 'S/N']= int(snr_kin)

                                df_kin.to_csv(kin_file, index= False, sep=' ')

                                #writing also the kin gas file
                                if gas_kin == True:
                                    for t in range (1,kin_component+1):
                                        df_kin_gas.at[i, f'RV(km/s)_{t}']= round(kinematics[t][0])
                                        df_kin_gas.at[i, f'Sigma(km/s)_{t}']= round(kinematics[t][1])
                                        df_kin_gas.at[i, f'H3_{t}']= round(kinematics[t][2],3)
                                        df_kin_gas.at[i, f'H4_{t}']= round(kinematics[t][3],3)
                                        df_kin_gas.at[i, f'H5_{t}']= round(kinematics[t][4],3)
                                        df_kin_gas.at[i, f'H6_{t}']= round(kinematics[t][5],3)
                                        df_kin_gas.at[i, f'errRV_{t}']= round(error_kinematics[t][0])
                                        df_kin_gas.at[i, f'errSigma_{t}']= round(error_kinematics[t][1])
                                        df_kin_gas.at[i, f'errH3_{t}']= round(error_kinematics[t][2],3)
                                        df_kin_gas.at[i, f'errH4_{t}']= round(error_kinematics[t][3],3)
                                        df_kin_gas.at[i, f'errH5_{t}']= round(error_kinematics[t][4],3)
                                        df_kin_gas.at[i, f'errH6_{t}']= round(error_kinematics[t][5],3)

                                        df_kin_gas.to_csv(kin_file_gas, index= False, sep=' ')


                                if with_errors_kin == True:
                                    err_rv_kin_mc, err_sigma_kin_mc, err_h3_kin_mc, err_h4_kin_mc, err_h5_kin_mc, err_h6_kin_mc = np.round(error_kinematics_mc[0],3)

                                    df_kin_mc.at[i, 'RV(km/s)']= vel
                                    df_kin_mc.at[i, 'Sigma(km/s)']= sigma
                                    df_kin_mc.at[i, 'H3']= h3
                                    df_kin_mc.at[i, 'H4']= h4
                                    df_kin_mc.at[i, 'H5']= h5
                                    df_kin_mc.at[i, 'H6']= h6
                                    df_kin_mc.at[i, 'errRV']= err_rv_kin_mc
                                    df_kin_mc.at[i, 'errSigma']= err_sigma_kin_mc
                                    df_kin_mc.at[i, 'errH3']= err_h3_kin_mc
                                    df_kin_mc.at[i, 'errH4']= err_h4_kin_mc
                                    df_kin_mc.at[i, 'errH5']= err_h5_kin_mc
                                    df_kin_mc.at[i, 'errH6']= err_h6_kin_mc
                                    df_kin_mc.at[i, 'S/N']= int(snr_kin)

                                    df_kin_mc.to_csv(kin_file_mc, index= False, sep=' ')


                            if i == (spectra_number-1):
                                print ('File with stellar kinematics saved: ', kin_file)
                                if gas_kin == True:
                                    print ('File with gas kinematics saved: ', kin_file_gas)
                                if with_errors_kin == True:
                                    print ('File with stellar kinematics and MonteCarlo uncertainties saved: ', kin_file_mc)
                                print('')

                            #saving the fitted spectrum
                            file_fitted_kin = result_spec+'ppxf_kin_bestfit_' + spec_names_nopath[i] + '.fits'
                            uti.save_fits_2d(bestfit_wavelength, bestfit_flux, file_fitted_kin)
                            print ('Fit of the spectra saved to: ', file_fitted_kin)
                            print('')

                            if save_plot == True:
                                plt.plot(bestfit_wavelength, bestfit_flux)

                                # vel_string = str(vel)
                                # sigma_string = str(sigma)
                                # h3_string = str(h3)
                                # h4_string = str(h4)
                                # plt.title('v = '+ vel_string + ' km/s.  Sigma = '+ sigma_string + ' km/s.  H3 = ' + h3_string + '.  H4 = ' + h4_string)
                                # plt.savefig(result_plot_dir + '/'+ 'kin_ppxf_' + spec_names_nopath[i] + '.png', format='png', dpi=300)
                                # plt.clf()
                                # plt.close()




                                #plotting info for stellar single component
                                if kin_component == 0 and ppxf_kin_two_stellar_components == False:
                                    vel_string = str(int(kinematics[0]))
                                    sigma_string = str(int(kinematics[1]))
                                    h3_string = str(round(kinematics[2],3))
                                    h4_string = str(round(kinematics[3],3))
                                    plt.title('v = '+ vel_string + ' km/s.  Sigma = '+ sigma_string + ' km/s.  H3 = ' + h3_string + '.  H4 = ' + h4_string)
                                    plt.savefig(result_plot_dir + '/'+ 'kin_ppxf_' + spec_names_nopath[i] + '.png', format='png', dpi=300)
                                    plt.clf()
                                    plt.close()

                                    if np.any(kinematics) == 0: #if the return of the fit are all zeros, means that the fit has not been performed for the following reason:
                                        sg.popup ('Template resolution greater than galaxy spectrum. Fit aborted')
                                    #continue

                                #plotting info for stellar double component
                                elif kin_component == 0 and ppxf_kin_two_stellar_components == True:
                                    vel_string1 = str(int(kinematics[0][0]))
                                    sigma_string1 = str(int(kinematics[0][1]))
                                    h3_string1 = str(round(kinematics[0][2],3))
                                    h4_string1 = str(round(kinematics[0][3],3))
                                    vel_string2 = str(int(kinematics[1][0]))
                                    sigma_string2 = str(int(kinematics[1][1]))
                                    h3_string2 = str(round(kinematics[1][2],3))
                                    h4_string2 = str(round(kinematics[1][3],3))

                                    plt.title('v1 = '+ vel_string1 + ' km/s.  Sigma1 = '+ sigma_string1 + ' km/s.  v2 = ' + vel_string2 + '. Sigma2 = '+ sigma_string2 + ' km/s')
                                    plt.savefig(result_plot_dir + '/'+ 'kin_ppxf_' + spec_names_nopath[i] + '.png', format='png', dpi=300)
                                    plt.clf()
                                    plt.close()

                                    if np.any(kinematics) == 0: #if the return of the fit are all zeros, means that the fit has not been performed for the following reason:
                                        sg.popup ('Template resolution greater than galaxy spectrum. Fit aborted')
                                    #continue

                                #plotting info for stellar and gas components
                                else:
                                    vel_string = str(int(kinematics[0][0]))
                                    sigma_string = str(int(kinematics[0][1]))
                                    h3_string = str(round(kinematics[0][2],3))
                                    h4_string = str(round(kinematics[0][3],3))
                                    plt.title('v = '+ vel_string + ' km/s.  Sigma = '+ sigma_string + ' km/s.  H3 = ' + h3_string + '.  H4 = ' + h4_string)
                                    plt.savefig(result_plot_dir + '/'+ 'kin_ppxf_' + spec_names_nopath[i] + '.png', format='png', dpi=300)
                                    plt.clf()
                                    plt.close()

                                    if np.any(kinematics[0]) == 0: #if the return of the fit are all zeros, means that the fit has not been performed for the following reason:
                                        sg.popup ('Template resolution greater than galaxy spectrum. Fit aborted')

                        except:
                            print ('Something went wrong. Fit aborted')



            # 7) STELLAR POPULATIONS WITH PPXF
                if (stellar_pop == True):
                    task_done2 = 1

                    print ('*** Stellar populations with the ppxf algorithm ***')

                    #wave limits of the spectrum
                    wave_limits = np.array([wavelength[0], wavelength[len(wavelength)-1]])

                    #check on the limits of the input parameters
                    if wave1_pop < wave2_pop:
                        wave_limits_pop = (wave1_pop,wave2_pop)
                    if wave1_pop > wave2_pop:
                        #I suppose the wavelength range is inverted:
                        wave1_pop_tmp = wave1_pop
                        wave1_pop = wave2_pop
                        wave2_pop = wave1_pop_tmp
                        wave_limits_pop = (wave1_pop, wave2_pop)

                    #checking limits
                    if (wave1_pop < wave_limits[0] or wave2_pop > wave_limits[1]):
                        print ('The window band is out of the spectrum range')

                    if ppxf_pop_custom_lib == True and ppxf_pop_custom_npz == False:
                        matching_temp = glob.glob(os.path.join(ppxf_pop_lib_folder, ppxf_custom_temp_suffix))
                        if not matching_temp:
                            print ('Well, like I said, the templates you want to use does not exist. Stopping')

                    #doing it
                    try:
                        kinematics, info_pop, info_pop_mass, mass_light, errors, galaxy, bestfit_flux, bestfit_wave, bestfit_flux_gas, residual_flux, chi_square, age_err_lower_abs, age_err_upper_abs, met_err_lower, met_err_upper, alpha_err_lower, alpha_err_upper, mass_age_err_lower_abs, mass_age_err_upper_abs, mass_met_err_lower, mass_met_err_upper, mass_alpha_err_lower, mass_alpha_err_upper, emission_corrected_flux, pop_age, light_weights_age_bin, mass_weights_age_bin, cumulative_mass, snr_pop, light_weights, mass_weights = span.ppxf_pop(wavelength, flux, wave1_pop, wave2_pop, res_pop, z_pop, sigma_guess_pop, fit_components, False, with_errors, save_plot, spec_names_nopath[i], regul_err, additive_degree, multiplicative_degree,ppxf_pop_tie_balmer, stellar_library, ppxf_pop_dust_stars, ppxf_pop_dust_gas, ppxf_pop_noise, age_range_array, met_range_array, ppxf_pop_custom_lib, ppxf_pop_lib_folder, ppxf_pop_custom_npz, ppxf_pop_npz_file, ppxf_pop_mask, ppxf_custom_temp_suffix, ppxf_best_param, ppxf_best_noise_estimate, ppxf_frac_chi, ppxf_pop_convolve, ppxf_pop_want_to_mask, ppxf_pop_mask_ranges, ppxf_pop_error_nsim, ppxf_pop_lg_age, result_plot_dir)

                        #saving only the stellar parameters, which are stored depending on the presence of gas or not
                        try:
                            num_comp_kinematics = len(kinematics)
                            kin_stars = np.array(kinematics[0])
                            rv_pop_ppxf = kin_stars[0]
                            sigma_pop_ppxf = kin_stars[1]
                            h3_pop_ppxf = kin_stars[2]
                            h4_pop_ppxf = kin_stars[3]

                        except (ValueError, IndexError):
                            num_comp_kinematics = 0
                            kin_stars = kinematics

                            rv_pop_ppxf = kinematics[0]
                            sigma_pop_ppxf = kinematics[1]
                            h3_pop_ppxf = kinematics[2]
                            h4_pop_ppxf = kinematics[3]

                        age = info_pop[0]
                        met = info_pop[1]
                        mass_age = info_pop_mass[0]
                        mass_met = info_pop_mass[1]


                        # storing the values in the dataframes and save to disc
                        if stellar_library == 'sMILES' and ppxf_pop_custom_lib == False:
                            alpha = info_pop[2]
                            mass_alpha = info_pop_mass[2]

                        df_pop.at[i, 'RV(km/s)']= round(rv_pop_ppxf,2)
                        df_pop.at[i, 'Sigma(km/s)']= round(sigma_pop_ppxf,2)
                        df_pop.at[i, 'H3']= round(h3_pop_ppxf,3)
                        df_pop.at[i, 'H4']= round(h4_pop_ppxf,3)

                        df_pop.at[i, 'lum_met(dex)']= round(met,2)
                        df_pop.at[i, 'M/L']= round(mass_light,3)

                        df_pop.at[i, 'mass_met(dex)']= round(mass_met,3)
                        df_pop.at[i, 'Chi2']= round(chi_square,3)
                        df_pop.at[i, 'err_lum_met_lower(dex)']= round(met_err_lower,3)
                        df_pop.at[i, 'err_lum_met_upper(dex)']= round(met_err_upper,3)
                        df_pop.at[i, 'err_mass_met_lower(dex)']= round(mass_met_err_lower,3)
                        df_pop.at[i, 'err_mass_met_upper(dex)']= round(mass_met_err_upper,3)
                        df_pop.at[i, 'S/N']= round(snr_pop)

                        if ppxf_pop_lg_age == True:
                            df_pop.at[i, 'lum_lg_age(dex)']= round(age,2)
                            df_pop.at[i, 'mass_lg_age(dex)']= round(mass_age,2)
                            df_pop.at[i, 'err_lum_lg_age_lower(dex)']= round(age_err_lower_abs,2)
                            df_pop.at[i, 'err_lum_lg_age_upper(dex)']= round(age_err_upper_abs,2)
                            df_pop.at[i, 'err_mass_lg_age_lower(dex)']= round(mass_age_err_lower_abs,2)
                            df_pop.at[i, 'err_mass_lg_age_upper(dex)']= round(mass_age_err_upper_abs,2)
                        else:
                            df_pop.at[i, 'lum_age(Gyr)']= round(age,1)
                            df_pop.at[i, 'mass_age(Gyr)']= round(mass_age,1)
                            df_pop.at[i, 'err_lum_age_lower(Gyr)']= round(age_err_lower_abs,2)
                            df_pop.at[i, 'err_lum_age_upper(Gyr)']= round(age_err_upper_abs,2)
                            df_pop.at[i, 'err_mass_age_lower(Gyr)']= round(mass_age_err_lower_abs,2)
                            df_pop.at[i, 'err_mass_age_upper(Gyr)']= round(mass_age_err_upper_abs,2)


                        #In case I use the sMILES with alpha/Fe
                        if stellar_library == 'sMILES' and ppxf_pop_custom_lib == False:
                            df_pop.at[i, 'lum_alpha(dex)']= round(alpha,2)
                            df_pop.at[i, 'mass_alpha(dex)']= round(mass_alpha,2)
                            df_pop.at[i, 'err_lum_alpha_lower(dex)']= round(alpha_err_lower,2)
                            df_pop.at[i, 'err_lum_alpha_upper(dex)']= round(alpha_err_upper,2)
                            df_pop.at[i, 'err_mass_alpha_lower(dex)']= round(mass_alpha_err_lower,2)
                            df_pop.at[i, 'err_mass_alpha_upper(dex)']= round(mass_alpha_err_upper,2)


                        #storing to the file
                        df_pop.to_csv(pop_file, index= False, sep=' ')


                        # If I want also to measure stellar parameters with Lick/IDS indices
                        if stellar_parameters_lick_ppxf == True:

                            #Extracting the kinematics from the pPXF fit. THe walues to extract depends whether I have gas or not
                            try:
                                num_comp_kinematics = len(kinematics)
                                kin_stars = np.array(kinematics[0])
                                dop_vel_pop_ppxf = kin_stars[0]
                                sigma_pop_ppxf = kin_stars[1]


                            except (ValueError, IndexError):
                                num_comp_kinematics = 0
                                kin_stars = kinematics
                                dop_vel_pop_ppxf = kinematics[0]
                                sigma_pop_ppxf = kinematics[1]

                            #Extracting the wave (in nm) and emission corrected flux from the ppxf fit
                            lick_wavelength_ppxf = bestfit_wave/10
                            lick_flux_ppxf = emission_corrected_flux
                            lick_step_ppxf = lick_wavelength_ppxf[1] - lick_wavelength_ppxf[0]

                            #rebinning linear
                            lick_wavelength_ppxf, lick_flux_ppxf, npoint_resampled = spman.resample(lick_wavelength_ppxf, lick_flux_ppxf, lick_step_ppxf)
                            lick_constant_fwhm_ppxf = True

                            #Doppler correction from the velociy calculated by pPXF
                            lick_wavelength_ppxf, lick_flux_ppxf = spman.dopcor(lick_wavelength_ppxf, lick_flux_ppxf, dop_vel_pop_ppxf, True) #doppler correction. The cosmological z correction has been already performed by the span.ppxf_pop function, prior to really run pPXF. Here I correct only for the real velocity component measured by the fit.


                            # 3) degrading the resolution, only if smaller than the lick system
                            if res_pop < 8.4:
                                lick_degraded_wavelength_ppxf, lick_degraded_flux_ppxf = spman.degrade_to_lick(lick_wavelength_ppxf, lick_flux_ppxf, res_pop, lick_constant_fwhm_ppxf)
                            else:
                                print('WARNING: The resolution of the spectrum is smaller than the one needed for the Lick/IDS system. I will still calculate the Lick/IDS indices but the results might be inaccurate.')
                                lick_degraded_wavelength_ppxf = lick_wavelength_ppxf
                                lick_degraded_flux_ppxf = lick_flux_ppxf


                            # 4) Measuring the EW and doing plot
                            lick_single_index_ppxf = False
                            lick_ew_plot_ppxf = False
                            lick_verbose_ppxf = False
                            lick_with_uncertainties_ppxf = True
                            lick_save_plot_ppxf = False
                            lick_normalise_spec_ppxf = True

                            lick_id_array_ppxf, lick_ew_array_ppxf, lick_err_array_ppxf, lick_snr_ew_array_ppxf, lick_ew_array_mag_ppxf, lick_err_array_mag_ppxf = ls.ew_measurement(lick_degraded_wavelength_ppxf, lick_degraded_flux_ppxf, lick_index_file, lick_single_index_ppxf, lick_ew_plot_ppxf, lick_verbose_ppxf, lick_with_uncertainties_ppxf, lick_save_plot_ppxf, spec_names_nopath[i], lick_normalise_spec_ppxf, result_plot_dir)


                            # 5) Correcting the EWs for sigma
                            sigma_to_correct_lick_ppxf = sigma_pop_ppxf

                            #now correcting for real
                            corrected_lick_ew_array_ppxf, corrected_lick_err_array_ppxf, corrected_lick_ew_mag_array_ppxf, corrected_lick_err_mag_array_ppxf = ls.corr_ew_lick(lick_ew_array_ppxf, lick_err_array_ppxf, lick_ew_array_mag_ppxf, sigma_lick_coeff_file, sigma_to_correct_lick_ppxf)

                            #uodating the values
                            lick_ew_array_ppxf = corrected_lick_ew_array_ppxf
                            lick_err_array_ppxf = corrected_lick_err_array_ppxf
                            lick_ew_array_mag_ppxf = corrected_lick_ew_mag_array_ppxf
                            lick_err_array_mag_ppxf = corrected_lick_err_mag_array_ppxf

                            #assigning meaningful names to the indices used for stellar populations and creating the combined ones
                            Hbeta_ppxf = lick_ew_array_ppxf[0]
                            Hbetae_ppxf = lick_err_array_ppxf[0]
                            Mg2_ppxf = lick_ew_array_mag_ppxf[1]
                            Mg2e_ppxf = lick_err_array_mag_ppxf[1]
                            Mgb_ppxf = lick_ew_array_ppxf[2]
                            Mgbe_ppxf = lick_err_array_ppxf[2]
                            Fe5270_ppxf = lick_ew_array_ppxf[3]
                            Fe5270e_ppxf = lick_err_array_ppxf[3]
                            Fe5335_ppxf = lick_ew_array_ppxf[4]
                            Fe5335e_ppxf = lick_err_array_ppxf[4]
                            Fem_ppxf = (Fe5270_ppxf+Fe5335_ppxf)/2
                            Feme_ppxf = np.sqrt((0.5*Fe5270e_ppxf)**2+(0.5*Fe5335e_ppxf)**2)
                            MgFe_ppxf = (np.sqrt(Mgb_ppxf*(0.72*Fe5270_ppxf+0.28*Fe5335_ppxf)))
                            MgFe_ppxf = np.nan_to_num(MgFe_ppxf, nan=0)
                            MgFee_ppxf = np.sqrt((((Fe5270_ppxf*18/25+Fe5335_ppxf*7/25)/(2*np.sqrt(Mgb_ppxf*(Fe5270_ppxf*18/25+Fe5335_ppxf*7/25))))*Mgbe_ppxf)**2+((Mgb_ppxf*18/25/(2*np.sqrt(Mgb_ppxf*(Fe5270_ppxf*18/25+Fe5335_ppxf*7/25))))*Fe5270e_ppxf)**2+((Mgb_ppxf*7/25/(2*np.sqrt(Mgb_ppxf*(Fe5270_ppxf*18/25+Fe5335_ppxf*7/25))))*Fe5335e_ppxf)**2)
                            MgFee_ppxf = np.nan_to_num(MgFee_ppxf, nan=0)

                            ssp_lick_indices_list_ppxf = np.column_stack((Hbeta_ppxf, MgFe_ppxf, Fem_ppxf, Mgb_ppxf))
                            ssp_lick_indices_ppxf = ssp_lick_indices_list_ppxf.reshape(-1)
                            ssp_lick_indices_err_list_ppxf = np.column_stack((Hbetae_ppxf, MgFee_ppxf, Feme_ppxf, Mgbe_ppxf))
                            ssp_lick_indices_err_ppxf = ssp_lick_indices_err_list_ppxf.reshape(-1)

                            #Determining the stellar parameters
                            age, met, alpha, err_age, err_met, err_alpha = span.lick_pop(ssp_lick_indices_ppxf, ssp_lick_indices_err_ppxf, ssp_model_ppxf, interp_model_ppxf)

                            print ('')
                            print ('Age (Gyr):', round(age,2), '+/-', round(err_age, 2))
                            print ('[M/H] (dex):', round(met, 2), '+/-', round(err_met,2))
                            print ('[Alpha/Fe]:', round(alpha, 2), '+/-', round(err_alpha,2))
                            print('')


                            #Storing the results to a file
                            df_ssp_param_ppxf.at[i, 'Hbeta(A)']= round(Hbeta_ppxf,3)
                            df_ssp_param_ppxf.at[i, 'Hbeta_err(A)']= round(Hbetae_ppxf,3)
                            df_ssp_param_ppxf.at[i, 'Mg2(mag)']= round(Mg2_ppxf,3)
                            df_ssp_param_ppxf.at[i, 'Mg2_err(mag)']= round(Mg2e_ppxf,3)
                            df_ssp_param_ppxf.at[i, 'Mgb(A)']= round(Mgb_ppxf,3)
                            df_ssp_param_ppxf.at[i, 'Mgb_err(A)']= round(Mgbe_ppxf,3)
                            df_ssp_param_ppxf.at[i, 'Fem(A)']= round(Fem_ppxf,3)
                            df_ssp_param_ppxf.at[i, 'Fem_err(A)']= round(Feme_ppxf,3)
                            df_ssp_param_ppxf.at[i, 'MgFe(A)']= round(MgFe_ppxf,3)
                            df_ssp_param_ppxf.at[i, 'MgFe_err(A)']= round(MgFee_ppxf,3)
                            df_ssp_param_ppxf.at[i, 'age(Gyr)']= round(age,3)
                            df_ssp_param_ppxf.at[i, 'err_age']= round(err_age,3)
                            df_ssp_param_ppxf.at[i, 'met']= round(met,4)
                            df_ssp_param_ppxf.at[i, 'err_met']= round(err_met,4)
                            df_ssp_param_ppxf.at[i, 'alpha']= round(alpha,4)
                            df_ssp_param_ppxf.at[i, 'err_alpha']= round(err_alpha,4)

                            #putting nans where needed
                            df_ssp_param_ppxf.to_csv(ssp_param_file_ppxf, na_rep='NaN', index= False, sep=' ')


                        # at the last spectrum I print some info on the output window
                        if i == (spectra_number-1):
                            print ('File saved: ', pop_file)
                            if stellar_parameters_lick_ppxf == True:
                                print ('File with the Lick/IDS stellar parameters saved: ', ssp_param_file_ppxf)
                            print('')


                        #saving the spectra residuals and the stellar template
                        #saving the spectra
                        file_fit_pop = result_spec+'ppxf_fit_pop_residuals_' + spec_names_nopath[i] + '.fits'
                        file_fit_stellar_template = result_spec+'ppxf_fit_pop_stellar_template_' + spec_names_nopath[i] + '.fits'
                        file_spec_emission_corrected = result_spec+'ppxf_fit_pop_emission_corrected_' + spec_names_nopath[i] + '.fits'

                        #saving the SFH and weights
                        file_sfh = result_ppxf_pop_data_dir+'/'+spectra_list_name+'_ppxf_fit_pop_SFH_' + spec_names_nopath[i] + '.dat'
                        file_all_light_weights = result_ppxf_pop_data_dir+'/'+spectra_list_name+'_ppxf_fit_pop_light_weights_' + spec_names_nopath[i] + '.dat'
                        file_all_mass_weights = result_ppxf_pop_data_dir+'/'+spectra_list_name+'_ppxf_fit_pop_mass_weights_' + spec_names_nopath[i] + '.dat'


                        bestfit_wave = bestfit_wave/10.

                    #in case I don't have gas
                        try:
                            #saving the SFH with lg ages or with linear ages
                            if ppxf_pop_lg_age == True:
                                np.savetxt(file_sfh, np.column_stack([pop_age, light_weights_age_bin, mass_weights_age_bin]), header="lg_age(dex)\tlum_fraction\tmass_fraction", delimiter='\t')
                            else:
                                np.savetxt(file_sfh, np.column_stack([pop_age, light_weights_age_bin, mass_weights_age_bin]), header="age(Gyr)\tlum_fraction\tmass_fraction", delimiter='\t')

                            print ('File containing the luminosity and mass SFH saved: ', file_sfh)

                            #saving the light weights
                            np.savetxt(file_all_light_weights, light_weights.reshape(-1, light_weights.shape[-1]), fmt="%.8e", delimiter=' ', header="Light weights")
                            print ('File containing the light weights saved: ', file_all_light_weights)

                            #saving the mass weights
                            np.savetxt(file_all_mass_weights, mass_weights.reshape(-1, mass_weights.shape[-1]), fmt="%.8e", delimiter=' ', header="Mass weights")
                            print ('File containing the mass weights saved: ', file_all_mass_weights)

                            if bestfit_flux_gas == 0:

                                #saving the residual file
                                uti.save_fits_2d(bestfit_wave, residual_flux, file_fit_pop)

                                #saving the template without gas:
                                uti.save_fits_2d(bestfit_wave, bestfit_flux, file_fit_stellar_template)

                                print ('File containing the residuals of the fit saved: ', file_fit_pop)
                                print ('File containing the stellar fitted template: ', file_fit_stellar_template)
                                print('')

                        except ValueError: #considering also the gas template if I receive this error

                            #saving the residual file
                            uti.save_fits_2d(bestfit_wave, residual_flux, file_fit_pop)

                            #saving the best template without gas:
                            stellar_fit_flux = bestfit_flux-bestfit_flux_gas
                            uti.save_fits_2d(bestfit_wave, stellar_fit_flux, file_fit_stellar_template)

                            #saving the emission corrected spectra in linear step
                            uti.save_fits_2d(bestfit_wave, emission_corrected_flux, file_spec_emission_corrected)

                            print ('File containing the residuals of the fit saved: ', file_fit_pop)
                            print ('File containing the stellar fitted template: ', file_fit_stellar_template)
                            print ('File containing the emission corrected spectra (empty if no gas selected): ', file_spec_emission_corrected)
                            print('')

                    except Exception:
                        print ('Something went wrong with the fit. Maybe too small age-metallicity range, bad templates or you masked out all the spectrum? Skipping...')
                        print ('Something went wrong')


    #**************************************************************************************************************
    #**************************************************************************************************************
    #************************************ END TASKS ***************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************



            # system configuration and finalising

                #progress meter
                cancel_cond = 0
                if not sg.OneLineProgressMeter('Task progress', i+1, spectra_number, 'Processing spectra:', orientation='h',button_color=('white','red')):
                    print ('***CANCELLED***')
                    cancel_cond = 1
                    print ('')
                    break

                #Test to save only the final results, without the intermediate files
                if (save_intermediate_files == True and task_done2 == 0 ):
                    if i == 0:
                        sg.popup('Nothing to process!')
                    if not sg.OneLineProgressMeter('Task progress', i+1, spectra_number,  'single', 'Processing spectra:', orientation='h',button_color=('white','red')):
                        break

                if (save_intermediate_files == False and task_spec2 == 1):
                    file_final = result_spec+'proc_' + spec_names_nopath[i] + '.fits'
                    uti.save_fits(wavelength, flux, file_final)

                    #considering also the cont sub task whics saves the continuum!
                    if (continuum_sub == True):
                        file_cont = result_spec+'cont_' + spec_names_nopath[i] + '.fits'
                        uti.save_fits(wavelength, continuum_flux, file_cont)
                        print ('File saved: ', file_cont)

                    print ('File saved: ', file_final)
                    print('')
                elif (save_intermediate_files == False and task_done2 == 0 ):
                    if i == 0:
                        sg.popup('Nothing to process!')
                    continue

        if (event == 'Process all' and values['one_spec'] == True):
            sg.popup ('With one spectrum this button does not work. Use the process selected')
            continue



    ##################  END EVENTS ON THE SPECTRA LIST LOADED ##################
    #*********************************** END TASKS ******************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************


        # CREATING LICK IDS FILE FOR SSP
        if (ew_measurement == True and lick_ew == True and event == 'Process all' and cancel_cond == 0):

            #converting lists to numpy array
            Hbeta = np.array(Hbeta)
            Hbetae = np.array(Hbetae)
            Mg2=np.array(Mg2)
            Mg2e=np.array(Mg2e)
            Mgb=np.array(Mgb)
            Mgbe=np.array(Mgbe)
            Fe5270=np.array(Fe5270)
            Fe5270e=np.array(Fe5270e)
            Fe5335=np.array(Fe5335)
            Fe5335e=np.array(Fe5335e)

            #creating composite indices and uncertainties and getting rid of (eventual) NaNs
            Fem = (Fe5270+Fe5335)/2
            Feme = np.sqrt(Fe5270e**2+Fe5335e**2)*2
            MgFe = (np.sqrt(Mgb*(0.72*Fe5270+0.28*Fe5335)))
            MgFe = np.nan_to_num(MgFe, nan=0)
            MgFee = np.sqrt((((Fe5270*18/25+Fe5335*7/25)/(2*np.sqrt(Mgb*(Fe5270*18/25+Fe5335*7/25))))*Mgbe)**2+((Mgb*18/25/(2*np.sqrt(Mgb*(Fe5270*18/25+Fe5335*7/25))))*Fe5270e)**2+((Mgb*7/25/(2*np.sqrt(Mgb*(Fe5270*18/25+Fe5335*7/25))))*Fe5335e)**2)
            MgFee = np.nan_to_num(MgFee, nan=0)


            #saving the file
            data = {
                '#Spectra': spec_names_nopath,
                'Hbeta': np.round(Hbeta,3),
                'Hbetae': np.round(Hbetae,3),
                'Mg2': np.round(Mg2,3),
                'Mg2e': np.round(Mg2e,3),
                'Mgb': np.round(Mgb,3),
                'Mgbe': np.round(Mgbe,3),
                'Fe5270': np.round(Fe5270,3),
                'Fe5270e': np.round(Fe5270e,3),
                'Fe5335': np.round(Fe5335,3),
                'Fe5335e': np.round(Fe5335e,3),
                'Fem': np.round(Fem,3),
                'Feme': np.round(Feme,3),
                'MgFe': np.round(MgFe,3),
                'MgFee': np.round(MgFee,3)
                    }
            try:
                df = pd.DataFrame(data)
                file_path = result_ew_data_dir+'/'+spectra_list_name + '_lick_for_SSP_'+ timestamp + '_.dat'
                df.to_csv(file_path, sep=' ', index=False)
                print ('File with the Lick/IDS indices used for stellar parameters saved: ', file_path)
            except ValueError:
                print ('Nothing to save')


    #************************************** END PROGRAM ROUTINES **************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************
    #**************************************************************************************************************





    #************************************** SAVE AND LOAD PARAMETER VALUES *********************************************
        if event == 'Save parameters...':

            # Open a window to select the path to save the file
            filename = sg.popup_get_file('Save file as...', save_as=True, default_extension=".json", file_types=(("JSON Files", "*.json"),))

            #saving the file
            if filename:
                try:
                    save_settings(filename, keys, events, values)
                    print('User settings saved')
                    sg.popup_ok(f'Configuration file saved:\n{filename}')
                except json.JSONDecodeError:
                    sg.popup_error('Content not valid for JSON.')


        # listing all the parameters to be loaded
        if event == 'Load parameters...' or event == 'Restore default parameters':

            try:
                if event == 'Load parameters...':
                    filename = sg.popup_get_file('Select the file to load...', file_types=(("JSON Files", "*.json"),))
                    keys, events, loaded_values = load_settings(filename)
                    values.update(loaded_values)

                if event == 'Restore default parameters':
                    keys, events, loaded_values = load_settings(os.path.join(BASE_DIR, "system_files", "default_settings.json"))
                    values.update(loaded_values)

                #main gui tasks
                window['spec_list'].update(value=values.get('spec_list', ''))
                window['wave_units_nm'].update(value=values.get('wave_units_nm', True))
                window['wave_units_a'].update(value=values.get('wave_units_a', False))
                window['wave_units_mu'].update(value=values.get('wave_units_mu', False))
                window['show_hdr'].update(value=values.get('show_hdr', False))
                window['show_step'].update(value=values.get('show_step', False))
                window['show_res'].update(value=values.get('show_res', False))
                window['lambda_res_left'].update(value=values.get('lambda_res_left', ''))
                window['lambda_res_right'].update(value=values.get('lambda_res_right', ''))
                window['convert_spec'].update(value=values.get('convert_spec', False))
                window['convert_to_txt'].update(value=values.get('convert_to_txt', False))
                window['convert_to_fits'].update(value=values.get('convert_to_fits', False))
                window['compare_spec'].update(value=values.get('compare_spec', False))
                window['spec_to_compare'].update(value=values.get('spec_to_compare', ''))
                window['convert_flux'].update(value=values.get('convert_flux', False))
                window['convert_to_fnu'].update(value=values.get('convert_to_fnu', False))
                window['convert_to_fl'].update(value=values.get('convert_to_fl', False))
                window['show_snr'].update(value=values.get('show_snr', False))
                window['wave_snr'].update(value=values.get('wave_snr', ''))
                window['delta_wave_snr'].update(value=values.get('delta_wave_snr', ''))

                # spectra manipulation panel tasks
                cropping_spectrum = values['cropping']
                cropping_low_wave = values['cropping_low_wave']
                cropping_high_wave = values['cropping_high_wave']
                sigma_clipping = values['sigma_clip']
                wavelet_cleaning = values['wavelet_cleaning']
                sigma_wavelets = values['sigma_wavelets']
                wavelets_layers = values['wavelets_layers']
                dop_cor = values['dopcor']
                helio_corr = values['helio_corr']
                rebinning = values['rebin']
                rebinning_linear = values['rebin_pix_lin']
                rebin_step_pix = values['rebin_step_pix']
                rebinning_log = values['rebin_sigma_lin']
                rebin_step_sigma = values['rebin_step_sigma']
                degrade = values['degrade_resolution']
                normalize_wave = values['norm_spec']
                norm_wave = values['norm_wave']
                continuum_sub = values['cont_sub']
                sigma_broad = values['broadening_spec']
                sigma_to_add = values['sigma_to_add']
                add_noise = values['add_noise']
                noise_to_add = values['noise_to_add']
                filter_denoise = values['filter_denoise']
                average_all = values['avg_all']
                norm_and_average = values['norm_avg_all']
                do_nothing = values['none']
                sum_all = values['sum_all']
                normalize_and_sum_all = values['norm_sum_all']
                use_for_spec_an = values['use_for_spec_an']
                subtract_normalized_avg = values['subtract_norm_avg']
                subtract_normalized_spec = values['subtract_norm_spec']
                spectra_to_subtract = values['spec_to_sobtract']
                add_pedestal = values['add_pedestal']
                pedestal_to_add = values['pedestal_to_add']
                multiply = values['multiply']
                multiply_factor = values['multiply_factor']
                derivatives = values['derivatives']
                clip_factor = values['clip_factor']
                sigma_clip_resolution = values['res_spec_for_sigma_clip']
                sigma_clip_single_vel = values['single_vel_clip']
                sigma_clip_vel_value = values['clip_to_vel']
                sigma_clip_have_file = values['file_for_clip']
                sigma_clip_sigma_file = values['sigma_clip_file']
                dop_cor_single_shot_vel = values['dopcor_value']
                dop_cor_have_file =  values['file_for_dopcor']
                dop_cor_file =  values['dopcor_file']
                dop_cor_single_shot =  values['dopcor_single_value']
                dop_cor_have_vel = values['dop_cor_have_vel']
                dop_cor_have_z = values['dop_cor_have_z']
                helio_have_file = values['file_for_helio']
                helio_file = values['helio_file']
                helio_single_shot = values['helio_single_value']
                helio_single_shot_location = values['helio_location']
                helio_single_shot_date = values['helio_date']
                ra_obj = values['helio_ra']
                dec_obj = values['helio_dec']
                is_initial_res_r = values['is_initial_res_r']
                initial_res_r = values['degrade_from_r']
                res_degrade_to_r = values['res_degrade_to_r']
                final_res_r = values['degrade_to_r']
                res_degrade_to_fwhm = values['res_degrade_to_fwhm']
                final_res_r_to_fwhm = values['final_res_r_to_fwhm']
                is_initial_res_fwhm = values['is_initial_res_fwhm']
                initial_res_fwhm = values['degrade_from_l']
                final_res_fwhm  = values['degrade_to_l']
                cont_model_filtering = values['cont_model_filtering']
                cont_model_poly = values['cont_model_poly']
                cont_math_operation = values['markers_cont_operations']
                cont_want_to_maks = values['cont_want_to_maks']
                cont_mask_ranges_str = values['cont_mask_ranges']
                cont_poly_degree = values['cont_poly_degree']
                moving_average = values['moving_average']
                box_moving_avg = values['box_moving_avg']
                box_moving_avg_size = values['box_moving_avg_size']
                gauss_moving_avg = values['gauss_moving_avg']
                gauss_moving_avg_kernel = values['gauss_moving_avg_kernel']
                low_pass_filter = values['low_pass_filter']
                lowpass_cut_off = values['lowpass_cut_off']
                lowpass_order = values['lowpass_order']
                bandpass_filter = values['bandpass_filter']
                bandpass_lower_cut_off = values['bandpass_lower_cut_off']
                bandpass_upper_cut_off = values['bandpass_upper_cut_off']
                bandpass_order = values['bandpass_order']
                reorder_op = values['reorder_op']
                current_order = values.get('current_order', [])

                # Main GUI, spectral analysis tasks
                window['bb_fitting'].update(value=values['bb_fitting'],)
                window['xcorr'].update(value=values['xcorr'],)
                window['sigma_measurement'].update(value=values['sigma_measurement'],)
                window['ew_measurement'].update(value=values['ew_measurement'],)
                window['line_fitting'].update(value=values['line_fitting'],)
                window['ppxf_kin'].update(value=values['ppxf_kin'],)
                window['ppxf_pop'].update(value=values['ppxf_pop'],)
                sigma_coeff=values['sigma_coeff']
                sigma_corr=values['sigma_corr']
                window['save_intermediate_files'].update(value=values['save_intermediate_files'],)
                window['save_plots'].update(value=values['save_plots'],)

                #Blackbody parameters
                wave1_bb=values['left_wave_bb']
                wave2_bb=values['right_wave_bb']
                t_guess=values['t_guess_bb']

                #Cross-correlation parameters
                template_crosscorr=values['xcorr_template']
                lambda_units_template_crosscorr_nm=values['xcorr_template_wave_nm']
                lambda_units_template_crosscorr_a=values['xcorr_template_wave_a']
                lambda_units_template_crosscorr_mu=values['xcorr_template_wave_mu']
                smooth_template_crosscorr=values['xcorr_smooth_template']
                smooth_value_crosscorr=values['xcorr_smooth_template_value']
                low_wave_corr=values['xcorr_left_lambda']
                high_wave_corr=values['xcorr_right_lambda']
                is_vel_xcorr=values['is_vel_xcorr']
                is_z_xcorr=values['is_z_xcorr']
                low_vel_corr=values['xcorr_low_vel']
                high_vel_corr=values['xcorr_high_vel']
                low_z_corr = values['low_z_corr']
                high_z_corr = values['high_z_corr']

                #Velocity dispersion parameters
                template_sigma=values['sigma_template']
                lambda_units_template_sigma_nm=values['lambda_units_template_sigma_nm']
                lambda_units_template_sigma_a=values['lambda_units_template_sigma_a']
                lambda_units_template_sigma_mu=values['lambda_units_template_sigma_mu']
                band_cat=values['band_cat']
                band_halpha=values['band_halpha']
                band_nad=values['band_nad']
                band_h=values['band_h']
                band_k=values['band_k']
                resolution_spec=values['resolution_spec']
                resolution_template=values['resolution_template']
                band_custom=values['band_custom']
                low_wave_sigma=values['low_wave_sigma']
                high_wave_sigma=values['high_wave_sigma']
                low_wave_cont=values['low_wave_cont']
                high_wave_cont=values['high_wave_cont']

                #Line-strength parameters
                have_index_file=values['ew_idx_file']
                index_file=values['idx_file']
                single_index=values['single_index']
                idx_left_blue=values['left_wave_blue_cont']
                idx_right_blue=values['right_wave_blue_cont']
                idx_left_red=values['left_wave_red_cont']
                idx_right_red=values['right_wave_red_cont']
                idx_left_line=values['left_line']
                idx_right_line=values['right_line']
                lick_ew=values['ew_lick']
                lick_constant_fwhm=values['lick_constant_fwhm']
                spec_lick_res_fwhm=values['spec_lick_res_fwhm']
                lick_constant_r=values['lick_constant_r']
                spec_lick_res_r=values['spec_lick_res_r']
                lick_correct_emission=values['lick_correct_emission']
                z_guess_lick_emission=values['z_guess_lick_emission']
                dop_correction_lick=values['dop_correction_lick']
                correct_ew_sigma=values['correct_ew_sigma']
                radio_lick_sigma_auto=values['radio_lick_sigma_auto']
                radio_lick_sigma_single=values['radio_lick_sigma_single']
                sigma_single_lick=values['sigma_single_lick']
                radio_lick_sigma_list=values['radio_lick_sigma_list']
                sigma_lick_file=values['sigma_lick_file']
                stellar_parameters_lick=values['stellar_parameters_lick']
                ssp_model = values['ssp_model']
                have_index_file_corr=values['ew_corr_idx_file']
                index_file_corr=values['idx_corr_file']
                single_index_corr=values['ew_corr_single_idx']
                stellar_spectra_coeff_file=values['stellar_spectra_coeff_file']
                stellar_spectra_coeff_file=values['sigma_coeff_sample_list']
                lambda_units_coeff_nm=values['sigma_coeff_sample_list_wave_nm']
                lambda_units_coeff_a=values['sigma_coeff_sample_list_wave_a']
                lambda_units_coeff_mu=values['sigma_coeff_sample_list_wave_mu']
                smooth_stellar_sample=values['sigma_coeff_sample_smooth']
                smooth_value_sample=values['sigma_coeff_sample_smooth_sigma']
                sigma_vel_file=values['sigma_file']
                ew_list_file=values['ew_file_to_correct']
                sigma_coeff_file=values['coeff_sigma_file']

                #Line(s) fitting parameters
                cat_band_fit=values['cat_fit']
                usr_fit_line=values['line_fit_single']
                emission_line=values['emission_line']
                low_wave_fit=values['left_wave_fitting']
                high_wave_fit=values['right_wave_fitting']
                y0=values['y0']
                x0=values['x0']
                a=values['a']
                sigma=values['sigma']
                m=values['m']
                c=values['c']

                #Stars and gas kinematics parameters
                wave1_kin=values['left_wave_ppxf_kin']
                wave2_kin=values['right_wave_ppxf_kin']
                stellar_library_kin = values['stellar_library_kin']
                constant_resolution_lambda=values['constant_resolution_lambda']
                resolution_kin=values['ppxf_resolution']
                constant_resolution_r=values['constant_resolution_r']
                resolution_kin_r=values['ppxf_resolution_r']
                sigma_guess_kin=values['sigma_guess_kin']
                redshift_guess_kin=values['redshift_guess_kin']
                additive_degree_kin=values['additive_degree_kin']
                gas_kin = values['gas_kin']
                no_gas_kin = values['no_gas_kin']
                kin_best_noise = values['kin_best_noise']
                with_errors_kin = values['with_errors_kin']
                kin_moments = values['kin_moments']
                ppxf_kin_noise = values['ppxf_kin_noise']
                ppxf_kin_preloaded_lib = values['ppxf_kin_preloaded_lib']
                ppxf_kin_custom_lib = values['ppxf_kin_custom_lib']
                ppxf_kin_lib_folder = values['ppxf_kin_lib_folder']
                ppxf_kin_custom_temp_suffix = values['ppxf_kin_custom_temp_suffix']
                ppxf_kin_tie_balmer = values['ppxf_kin_tie_balmer']
                ppxf_kin_dust_stars = values['ppxf_kin_dust_stars']
                ppxf_kin_dust_gas = values['ppxf_kin_dust_gas']
                ppxf_kin_two_stellar_components = values['ppxf_kin_two_stellar_components']
                ppxf_kin_age_model1 = values['ppxf_kin_age_model1']
                ppxf_kin_met_model1 = values['ppxf_kin_met_model1']
                ppxf_kin_age_model2 = values['ppxf_kin_age_model2']
                ppxf_kin_met_model2 = values['ppxf_kin_met_model2']
                ppxf_kin_vel_model1 = values['ppxf_kin_vel_model1']
                ppxf_kin_sigma_model1 = values['ppxf_kin_sigma_model1']
                ppxf_kin_vel_model2 = values['ppxf_kin_vel_model2']
                ppxf_kin_sigma_model2 = values['ppxf_kin_sigma_model2']
                ppxf_kin_mask_emission = values['ppxf_kin_mask_emission']
                ppxf_kin_mc_sim = values['ppxf_kin_mc_sim']

                #Stellar populations and SHF parameters
                wave1_pop=values['left_wave_ppxf_pop']
                wave2_pop=values['right_wave_ppxf_pop']
                res_pop=values['resolution_ppxf_pop']
                sigma_guess_pop=values['sigma_guess_pop']
                z_pop=values['ppxf_z_pop']
                pop_with_gas=values['gas_pop']
                ppxf_pop_tie_balmer=values['ppxf_pop_tie_balmer']
                ppxf_pop_noise=values['ppxf_pop_noise']
                ppxf_min_age = values['ppxf_min_age']
                ppxf_max_age = values['ppxf_max_age']
                ppxf_min_met = values['ppxf_min_met']
                ppxf_max_met = values['ppxf_max_met']
                pop_without_gas=values['no_gas_pop']
                regul_err=values['regul_err']
                additive_degree=values['additive_degree']
                multiplicative_degree=values['multiplicative_degree']
                stellar_library = values['stellar_library']
                with_errors=values['ppxf_err_pop']
                ppxf_pop_preloaded_lib = values['ppxf_pop_preloaded_lib']
                ppxf_pop_custom_lib = values['ppxf_pop_custom_lib']
                ppxf_pop_lib_folder = values['ppxf_pop_lib_folder']
                ppxf_pop_custom_npz = values['ppxf_pop_custom_npz']
                ppxf_pop_npz_file = values['ppxf_pop_npz_file']
                ppxf_pop_mask = values['ppxf_pop_mask']
                ppxf_custom_temp_suffix = values['ppxf_custom_temp_suffix']
                ppxf_best_param = values['ppxf_best_param']
                ppxf_best_noise_estimate = values['ppxf_best_noise_estimate']
                ppxf_frac_chi = values['ppxf_frac_chi']
                ppxf_pop_convolve = values['ppxf_pop_convolve']
                ppxf_pop_want_to_mask = values['ppxf_pop_want_to_mask']
                ppxf_pop_mask_ranges_str = values['ppxf_pop_mask_ranges_str']
                ppxf_pop_dust_stars = values['ppxf_pop_dust_stars']
                ppxf_pop_dust_gas = values['ppxf_pop_dust_gas']
                ppxf_pop_error_nsim = values['ppxf_pop_error_nsim']
                ppxf_pop_lg_age = values['ppxf_pop_lg_age']
                stellar_parameters_lick_ppxf = values['stellar_parameters_lick_ppxf']
                ssp_model_ppxf = values['ssp_model_ppxf']
                interp_model_ppxf = values['interp_model_ppxf']

                #loading the arrays needed to SPAN from the loaded values
                cont_mask_ranges = eval(cont_mask_ranges_str)
                wave_interval_corr = np.array([low_wave_corr,high_wave_corr])
                vel_interval_corr = np.array([low_vel_corr,high_vel_corr])
                z_interval_corr = np.array([low_z_corr,high_z_corr])
                index_usr = np.array([idx_left_blue, idx_right_blue, idx_left_red, idx_right_red, idx_left_line, idx_right_line]).T
                wave_interval_fit = np.array([low_wave_fit,high_wave_fit])
                guess_param = [y0,x0,a,sigma,m,c]
                age_range_array = np.array([ppxf_min_age, ppxf_max_age])
                met_range_array = np.array([ppxf_min_met, ppxf_max_met])
                ppxf_pop_mask_ranges = eval(ppxf_pop_mask_ranges_str)

                # Long-slit (2D) extraction parameters
                file_path_spec_extr= values['file_path']
                trace_y_range_str= values['trace_y_range']
                poly_degree_str= values['poly_degree']
                extract_y_range_str= values['extract_y_range']
                snr_threshold_str= values['snr']
                pixel_scale_str= values['pix_scale']

                # DATACUBE EXTRACTION PARAMETERS
                ifs_run_id= values['ifs_run_id']
                ifs_input= values['ifs_input']
                ifs_redshift= values['ifs_redshift']
                ifs_routine_read_default= values['ifs_routine_read']
                ifs_origin= values['ifs_origin']
                ifs_lmin_tot= values['ifs_lmin_tot']
                ifs_lmax_tot= values['ifs_lmax_tot']
                ifs_min_snr_mask= values['ifs_min_snr_mask']
                ifs_mask= values['ifs_mask']
                ifs_target_snr= values['ifs_target_snr']
                ifs_preloaded_routine= values['ifs_preloaded_routine']
                ifs_user_routine= values['ifs_user_routine']
                ifs_user_routine_file= values['ifs_user_routine_file']
                ifs_manual_bin = values['ifs_manual_bin']
                ifs_voronoi = values['ifs_voronoi']

                sg.Popup('Settings loaded')
                print('Settings loaded')
            except Exception as e:
                sg.Popup('Problem loading parameters. Please, verify the settings file')
                print ('Problem loading parameters. Please, verify the settings file')
                continue


        keys.append(event)
        events.append(event)


    ########################### AT LAST: END OF THE PROGRAM! ####################################

    window.close()


if __name__ == "__main__":
    main()
